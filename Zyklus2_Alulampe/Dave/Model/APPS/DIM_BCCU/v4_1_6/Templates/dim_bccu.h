/**
 * @file dim_bccu.h
 * @date 2016-07-15
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * DIM_BCCU v4.1.6 - DIM_BCCU APP configures the dimming engine registers of the Brightness and Color Control Unit (BCCU).
 *                   It also provides dynamic APIs to high level APPs such as DALI_CG and LED_LAMP.
 *
 * Copyright (c) 2015-2016, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16
 *     - Initial version.<br>
 *
 * 2015-05-07
 *     - Function prototypes DIM_BCCU_SetDimCurveAndDither(),DIM_BCCU_IsDitherEnable() are added.<br>
 *     - Code snippet modified due to review feedbacks.<br>
 *     - DIM_BCCU_DitherDisable(),DIM_BCCU_DitherEnable() and DIM_BCCU_SetDimCurve() function prototype are removed.<br>
 *     - XMC_ASSERT is added in all API's.<br>
 *     - Comments are added for XMC_ASSERT().<br>
 *
 * 2015-06-20
 *     - Version check added for XMCLib dependency.<br>
 *
 * @endcond
 *
 */

#ifndef DIM_BCCU_H
#define DIM_BCCU_H

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/

#include <xmc_bccu.h>
#include <DAVE_common.h>
#include "dim_bccu_conf.h"
#include "../GLOBAL_BCCU/global_bccu.h"

/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
       (XMC_LIB_MINOR_VERSION >= 0U) && \
       (XMC_LIB_PATCH_VERSION >= 0U)))
#error "DIM_BCCU requires XMC Peripheral Library v2.0.0 or higher"
#endif

 /**********************************************************************************************************************
 * ENUMS
 **********************************************************************************************************************/

/**
* @ingroup DIM_BCCU_enumerations
* @{
*/

/**
*  Defines status of DIM_BCCU.
*/
typedef enum DIM_BCCU_STATUS
{
  DIM_BCCU_STATUS_SUCCESS = 0, /**< Status Success if initialization is successful */
  DIM_BCCU_STATUS_FAILURE    /**< Status Failure if initialization is failed */
} DIM_BCCU_STATUS_t;

/**
*  Defines DIM_BCCU engine enabled or disabled at initialization.
*/
typedef enum DIM_BCCU_ENABLE_AT_INIT
{
  DIM_BCCU_ENABLE_AT_INIT_FALSE = 0,  /**< BCCU Dimming Engine Disabled */
  DIM_BCCU_ENABLE_AT_INIT_TRUE  /**< BCCU Dimming Engine Enabled */
} DIM_BCCU_ENABLE_AT_INIT_t;

/**
*  Defines DIM_BCCU engine number.
*/
typedef enum DIM_BCCU_ENGINE_NUM
{
  DIM_BCCU_ENGINE_NUM_0 = 0, /**< BCCU Dimming Engine 0 */
  DIM_BCCU_ENGINE_NUM_1, /**< BCCU Dimming Engine 1 */
  DIM_BCCU_ENGINE_NUM_2 /**< BCCU Dimming Engine 2 */
} DIM_BCCU_ENGINE_NUM_t;
/**
* @}
*/
/**********************************************************************************************************************
 * DATA STRUCTURES
 **********************************************************************************************************************/
/**
* @ingroup DIM_BCCU_datastructures.
* @{
*/

/**
*  Defines APP configuration parameters.
*/
typedef struct DIM_BCCU
{
  BCCU_DE_Type *const bccu_de_regs; /**< BCCU Dimming Engine Register Pointer */
  const XMC_BCCU_DIM_CONFIG_t *const config; /**< Dimming Engine configuration Structure Pointer */
  GLOBAL_BCCU_t *const global_bccu_handleptr; /**< GLOBAL_BCCU APP handle Pointer */
  DIM_BCCU_ENABLE_AT_INIT_t enable_at_start; /**< BCCU Dimming Engine status at initialization */
  DIM_BCCU_ENGINE_NUM_t dim_engine_num;  /**< BCCU Dimming Engine Number */
  uint32_t dim_lvl; /**< Initial Dimming Level  */
} DIM_BCCU_t;

/**
* @}
*/

/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/

/* Support for C++ codebase */
#ifdef __cplusplus
extern "C" {
#endif

  /**
* @ingroup DIM_BCCU_apidoc
* @{
*/

/**
* @brief Get DIM_BCCU APP version
* @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
*
* \par<b>Description: </b><br>
* The function can be used to check application software compatibility with a
* specific version of the APP.
*
* Example Usage:
*
* @code
* #include <DAVE.h>
*
*   int main(void) {
*   DAVE_STATUS_t status;
*    DAVE_APP_VERSION_t version;
*   status = DAVE_Init();// DIM_BCCU_Init() will be called within DAVE_Init()
*   version = DIM_BCCU_GetAppVersion();
*   if (version.major != 4U) {
*     // Probably, not the right version.
*   }
*
*   // More code here
*   while(1) {
*
*   }
*   return (1);
* }
* @endcode<BR>
*/

DAVE_APP_VERSION_t DIM_BCCU_GetAppVersion(void);

/**
* @brief Initializes a DIM_BCCU APP instance based on user configuration.
* @param handle Pointer pointing to APP data structure. Refer @ref DIM_BCCU_t for details.
* @return DIM_BCCU_STATUS_t APP status. Refer @ref DIM_BCCU_STATUS_t for details.
*
* \par<b>Description: </b><br>
* Initializes dimming engine of BCCU module, target dimming level and dimming engine start at initialization.
* It configures registers DTT,DEEN,DLS and DESTRCON.
*
* \par<b>Example Usage:</b><br>
*
* @code
* #include <DAVE.h>
* int main(void)
* {
*   DAVE_STATUS_t status;
*   status = DAVE_Init();// DIM_BCCU_Init() will be called within DAVE_Init()
*   if (status == DAVE_STATUS_FAILURE)
*   {
*     XMC_DEBUG(("DAVE APPs initialization failed with status %d\n", status));
*     while(1U)
*     {
*     }
*   }
*
*   while(1)
*   {
*
*   }
*  return (1);
* }
*
* @endcode<BR>
*/

DIM_BCCU_STATUS_t DIM_BCCU_Init(DIM_BCCU_t *handle);

/**
* @brief Enable dimming Engine.
* @param handle Pointer pointing to APP data structure. Refer @ref DIM_BCCU_t for details.
* @return none.
*
* \par<b>Description: </b><br>
* This function enables the dimming engine by configuring DEEN register. Dimming engine enable can be initially configured
* in the DIM_BCCU GUI. If that is not done, the dimming engine can be enabled any time by this function.
*
* \par<b>Example Usage:</b><br>
* Step1: Instantiate 1 PDM_BCCU and 1 DIM_BCCU APPs.<br>
* Step2: Deselect bypass dimming input in PDM_BCCU GUI.<br>
* Step3: Make HW signal connection from DIM_BCCU's dimming_level_output_output to PDM_BCCU's dimming_level_input.<br>
*
* @code
* #include <DAVE.h>
* int main(void)
* {
*   DAVE_STATUS_t status;
*   status = DAVE_Init();// DIM_BCCU_Init() will be called within DAVE_Init()
*   if (status == DAVE_STATUS_FAILURE)
*   {
*     XMC_DEBUG(("DAVE APPs initialization failed with status %d\n", status));
*     while(1U)
*     {
*     }
*   }
*  DIM_BCCU_Enable(&DIM_BCCU_0);
*  // Set Target Level 50%
*  DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 2048);
*  // Start Dimming
*  DIM_BCCU_StartDimming(&DIM_BCCU_0);
*  // Wait for Completion
*  DIM_BCCU_AwaitFadeCompletion(&DIM_BCCU_0);
*
*  while(1)
*  {
*
*  }
*
* return (1);
* }
*
* @endcode<BR>
*/

void DIM_BCCU_Enable(DIM_BCCU_t *handle);
/**
* @brief Disable Dimming Engine.
* @param handle Pointer pointing to APP data structure. Refer @ref DIM_BCCU_t for details.
* @return none.
*
* \par<b>Description: </b><br>
* Disable dimming engine by configuring DEEN register.
*
* \par<b>Example Usage:</b><br>
* Step1: Instantiate 1 PDM_BCCU and 1 DIM_BCCU APPs.<br>
* Step2: Deselect bypass dimming input in PDM_BCCU GUI.<br>
* Step3: Make HW signal connection from DIM_BCCU's dimming_level_output_output to PDM_BCCU's dimming_level_input.<br>
*
* @code
* #include <DAVE.h>
* int main(void)
* {
*   DAVE_STATUS_t status;
*   status = DAVE_Init();// DIM_BCCU_Init() will be called within DAVE_Init()
*   if (status == DAVE_STATUS_FAILURE)
*   {
*     XMC_DEBUG(("DAVE APPs initialization failed with status %d\n", status));
*     while(1U)
*     {
*     }
*   }
*  DIM_BCCU_Enable(&DIM_BCCU_0);
*  // Set Target Level 50%
*  DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 2048);
*  // Start Dimming
*  DIM_BCCU_StartDimming(&DIM_BCCU_0);
*  // Wait for Completion
*  DIM_BCCU_AwaitFadeCompletion(&DIM_BCCU_0);
*  //disable dimming engine
*  DIM_BCCU_Disable(&DIM_BCCU_0);
*
*  while(1)
*  {
*
*  }
*
* return (1);
* }
*
* @endcode<BR>
*/

void DIM_BCCU_Disable(DIM_BCCU_t *handle);
/**
* @brief Start dimming process.
* @param handle Pointer pointing to APP data structure. Refer @ref DIM_BCCU_t for details.
* @return none.
*
* \par<b>Description: </b><br>
* Initiate target dimming level shadow transfer. The dimming process will start and the dimming level will change
* towards the target. Cleared by hardware when the dimming process is complete and the target has been reached.
* Every time the dimming level is to be changed, this function has to be called.
*
* \par<b>Example Usage:</b><br>
* Step1: Instantiate 1 PDM_BCCU and 1 DIM_BCCU APPs.<br>
* Step2: Enable dimming engine in DIM_BCCU APP GUI.<br>
* Step3: Deselect bypass dimming input in PDM_BCCU APP GUI.<br>
* Step4: Make HW signal connection from DIM_BCCU's dimming_level_output to PDM_BCCU's dimming_level_input.<br>
*
* @code
* #include <DAVE.h>
* int main(void)
* {
*   DAVE_STATUS_t status;
*   status = DAVE_Init();// DIM_BCCU_Init() will be called within DAVE_Init()
*   if (status == DAVE_STATUS_FAILURE)
*   {
*     XMC_DEBUG(("DAVE APPs initialization failed with status %d\n", status));
*     while(1U)
*     {
*     }
*   }
*   // Set Target Level 12.5%
*   DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 512);
*   // Start Dimming
*   DIM_BCCU_StartDimming(&DIM_BCCU_0);
*   // Wait for Completion
*   DIM_BCCU_AwaitFadeCompletion(&DIM_BCCU_0);
*
*   while(1)
*   {
*
*   }
* return (1);
* }
*
* @endcode<BR>
*/

void DIM_BCCU_StartDimming(DIM_BCCU_t *handle);
/**
* @brief Abort dimming process.
* @param handle Pointer pointing to APP data structure. Refer @ref DIM_BCCU_t for details.
* @return none.<BR>
*
* \par<b>Description: </b><br>
* This function halts the dimming process immediately by writing a register bit DESTRCON_DEyA, before the target is reached.
*
* \par<b>Example Usage:</b><br>
* Step1: Instantiate 1 PDM_BCCU and 1 DIM_BCCU APPs.<br>
* Step2: Enable dimming engine in DIM_BCCU APP GUI.<br>
* Step3: Deselect bypass dimming input in PDM_BCCU APP GUI.<br>
* Step4: Make HW signal connection from DIM_BCCU's dimming_level_output to PDM_BCCU's dimming_level_input.<br>
*
* @code
* #include <DAVE.h>
* int main(void)
* {
*   DAVE_STATUS_t status;
*   status = DAVE_Init();// DIM_BCCU_Init() will be called within DAVE_Init()
*   if (status == DAVE_STATUS_FAILURE)
*   {
*     XMC_DEBUG(("DAVE APPs initialization failed with status %d\n", status));
*     while(1U)
*     {
*     }
*   }

*   while(1)
*   {
*     // Set Target Level 50%
*     DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 2048);
*     // Start Dimming
*     DIM_BCCU_StartDimming(&DIM_BCCU_0);
*
*     // some user code here
*
*     // the user has decided that a new target needs to be reached --> first abort current process
*     DIM_BCCU_AbortDimming(&DIM_BCCU_0);
*
*     // new target
*     // Set Target Level to 12.5%
*     DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 512);
*     // Start Dimming
*     DIM_BCCU_StartDimming(&DIM_BCCU_0);
*
*     // the 12.5% target will be reached eventually
*
*   }
* return (1);
* }
*
* @endcode<BR>
*/

void DIM_BCCU_AbortDimming(DIM_BCCU_t *handle);
/**
* @brief Set target dimming level.
* @param handle Pointer pointing to APP data structure. Refer @ref DIM_BCCU_t for details.
* @param dimlevel target dimming level, Range:0-4095
* @return none.
*
* \par<b>Description: </b><br>
* Configures the new target dimming level by programming the Dimming Level Shadow register (DLSz).
*
* \par<b>Example Usage:</b><br>
* Step1: Instantiate 1 PDM_BCCU and 1 DIM_BCCU APPs.<br>
* Step2: Enable dimming engine in DIM_BCCU APP GUI.<br>
* Step3: Deselect bypass dimming input in PDM_BCCU APP GUI.<br>
* Step4: Make HW signal connection from DIM_BCCU's dimming_level_output to PDM_BCCU's dimming_level_input.<br>
*
* @code
* #include <DAVE.h>
* int main(void)
* {
*   DAVE_STATUS_t status;
*   status = DAVE_Init();// DIM_BCCU_Init() will be called within DAVE_Init()
*   if (status == DAVE_STATUS_FAILURE)
*   {
*     XMC_DEBUG(("DAVE APPs initialization failed with status %d\n", status));
*     while(1U)
*     {
*     }
*   }
*   while(1)
*   {
*     // Set Target Level 12.5%
*     DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 512);
*     // Start Dimming
*     DIM_BCCU_StartDimming(&DIM_BCCU_0);
*     // Wait for Completion
*     DIM_BCCU_AwaitFadeCompletion(&DIM_BCCU_0);
*
*     // Set Target Level to 0%
*     DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 0);
*     // Start Dimming
*     DIM_BCCU_StartDimming(&DIM_BCCU_0);
*     // Wait for Completion
*     DIM_BCCU_AwaitFadeCompletion(&DIM_BCCU_0);
*   }
*  return (1);
* }
*
* @endcode<BR>
*/

void DIM_BCCU_SetDimLvl(DIM_BCCU_t *handle, uint32_t dimlevel);
/**
* @brief Get actual dimming level.
* @param handle Pointer pointing to APP data structure. Refer @ref DIM_BCCU_t for details.
* @return uint32_t actual dimming level. Range:0-4095
*
* \par<b>Description: </b><br>
* Retrieves current dimming level by reading register DLz.
*
* \par<b>Example Usage:</b>Demonstrates the smooth color changes in the LED, also changes LED brightness in exponential form.<br>
* Step1: Instantiate 1 PDM_BCCU and 1 DIM_BCCU APPs.<br>
* Step2: Enable dimming engine in DIM_BCCU APP GUI.<br>
* Step3: Deselect bypass dimming input in PDM_BCCU APP GUI.<br>
* Step4: Make HW signal connection from DIM_BCCU's dimming_level_output to PDM_BCCU's dimming_level_input.<br>
*
* @code
* #include <DAVE.h>
* int main(void)
* {
*   DAVE_STATUS_t status;
*   uint32_t dim_val;
*   status = DAVE_Init();// DIM_BCCU_Init() will be called within DAVE_Init()
*   if (status == DAVE_STATUS_FAILURE)
*   {
*     XMC_DEBUG(("DAVE APPs initialization failed with status %d\n", status));
*     while(1U)
*     {
*     }
*   }
*
*   while(1)
*   {
*     // Set Target Level 12.5%
*     DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 512);
*     // Start Dimming
*     DIM_BCCU_StartDimming(&DIM_BCCU_0);
*     // Wait for Completion
*     DIM_BCCU_AwaitFadeCompletion(&DIM_BCCU_0);
*
*     // user code
*
*     // let's check if the current dimming level is really 12.5%
*     dim_val  = DIM_BCCU_GetDimLvl(&DIM_BCCU_0);
*
*     // if dimming value is not expected change the level
*     // Set Target Level to 0%
*     DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 0);
*     // Start Dimming
*     DIM_BCCU_StartDimming(&DIM_BCCU_0);
*     // Wait for Completion
*     DIM_BCCU_AwaitFadeCompletion(&DIM_BCCU_0);
*   }
*  return (1);
* }
*
* @endcode<BR>
*/

uint32_t DIM_BCCU_GetDimLvl(DIM_BCCU_t *handle);

/**
* @brief Get dimming curve.
* @param handle Pointer pointing to APP data structure. Refer @ref DIM_BCCU_t for details.
* @return XMC_BCCU_DIM_CURVE_t dimming curve. Refer @ref XMC_BCCU_DIM_CURVE_t for details.
*
* \par<b>Description: </b><br>
* Returns dimming curve (coarse of fine).
*
*\par<b>Example Usage:</b><br>
* Step1: Instantiate 1 PDM_BCCU and 1 DIM_BCCU APPs.<br>
* Step2: Enable dimming engine in DIM_BCCU APP GUI.<br>
* Step3: Deselect bypass dimming input in PDM_BCCU APP GUI.<br>
* Step4: Make HW signal connection from DIM_BCCU's dimming_level_output to PDM_BCCU's dimming_level_input.<br>
*
* @code
* #include <DAVE.h>
* int main(void)
* {
*   DAVE_STATUS_t status;
*   XMC_BCCU_DIM_CURVE_t dim_curve;
*   status = DAVE_Init();// DIM_BCCU_Init() will be called within DAVE_Init()
*   if (status == DAVE_STATUS_FAILURE)
*   {
*     XMC_DEBUG(("DAVE APPs initialization failed with status %d\n", status));
*     while(1U)
*     {
*     }
*   }
*
*   while(1)
*   {
*
*     // Set Target Level 12.5%
*     DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 512);
*     // Start Dimming
*     DIM_BCCU_StartDimming(&DIM_BCCU_0);
*     // Wait for Completion
*     DIM_BCCU_AwaitFadeCompletion(&DIM_BCCU_0);
*
*     // ohh!! dimming is not as per expected
*     // check for dimming curve
*     dim_curve = DIM_BCCU_GetDimCurve(&DIM_BCCU_0); // get dimming curve
*     // coarse curve
*     // let's use fine curve (without dither)
*     if (dim_curve != XMC_BCCU_DIM_CURVE_FINE)
*     {
*       // set dimming curve
*       DIM_BCCU_SetDimCurveAndDither(&DIM_BCCU_0, 0, XMC_BCCU_DIM_CURVE_FINE);
*     }
*
*
*   }
*  return (1);
* }
*
* @endcode<BR>
*/

XMC_BCCU_DIM_CURVE_t DIM_BCCU_GetDimCurve(DIM_BCCU_t *handle);

/**
* @brief Get dither status.
* @param handle Pointer pointing to APP data structure. Refer @ref DIM_BCCU_t for details.
* @return uint32_t. Dither enable status. \b Range: 1-Enabled or 0-Disabled
*
* \par<b>Description: </b><br>
* Retrieves dither enable status by reading the register bit BCCU_DE_DTT_DTEN. <br>
*
* \par<b>Example Usage:</b><br>
* Step1: Instantiate 1 PDM_BCCU and 1 DIM_BCCU APPs.<br>
* Step2: Enable dimming engine in DIM_BCCU APP GUI.<br>
* Step3: Deselect bypass dimming input in PDM_BCCU APP GUI.<br>
* Step4: Make HW signal connection from DIM_BCCU's dimming_level_output to PDM_BCCU's dimming_level_input.<br>
*
* @code
* #include <DAVE.h>
* int main(void)
* {
*   DAVE_STATUS_t status;
*   XMC_BCCU_DIM_CURVE_t dim_curve;
*   status = DAVE_Init();// DIM_BCCU_Init() will be called within DAVE_Init()
*   if (status == DAVE_STATUS_FAILURE)
*   {
*     XMC_DEBUG(("DAVE APPs initialization failed with status %d\n", status));
*     while(1U)
*     {
*     }
*   }
*
*   while(1)
*   {
*     // Set Target Level 12.5%
*     // Set Target Level 12.5%
*     DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 512);
*     // Start Dimming
*     DIM_BCCU_StartDimming(&DIM_BCCU_0);
*     // Wait for Completion
*     DIM_BCCU_AwaitFadeCompletion(&DIM_BCCU_0);
*
*     // ohh!! dimming is not as per expected
*     // check for dimming curve
*     dim_curve = DIM_BCCU_GetDimCurve(&DIM_BCCU_0); // get dimming curve
*     // fine curve
*     // let's use coarse curve (with dither)
*     if (dim_curve != XMC_BCCU_DIM_CURVE_FINE)
*     {
*       DIM_BCCU_SetDimCurveAndDither(&DIM_BCCU_0, 1, XMC_BCCU_DIM_CURVE_COARSE); // set dimming curve
*       if (DIM_BCCU_IsDitherEnable(&DIM_BCCU_0))
*       {
*         // checking dither status
*       }
*     }
*
*  }
*  return (1);
* }
*
* @endcode<BR>
*/

uint32_t DIM_BCCU_IsDitherEnable(DIM_BCCU_t *handle);

/**
* @brief Configure dimming curve and dither.
* @param handle Pointer pointing to APP data structure. Refer @ref DIM_BCCU_t for details.
* @param curve dimming curve XMC_BCCU_DIM_CURVE_t. Refer @ref XMC_BCCU_DIM_CURVE_t for details.
* @return none.
*
* \par<b>Description: </b><br>
* Configures the shape of the dimming curve and enables/disables dither by writing into register DTTz.\n\n
*
* \par<b>Example Usage:</b><br>
* Step1: Instantiate 1 PDM_BCCU and 1 DIM_BCCU APPs.<br>
* Step2: Enable dimming engine in DIM_BCCU APP GUI.<br>
* Step3: Deselect bypass dimming input in PDM_BCCU APP GUI.<br>
* Step4: Make HW signal connection from DIM_BCCU's dimming_level_output to PDM_BCCU's dimming_level_input.<br>
*
* @code
* #include <DAVE.h>
* int main(void)
* {
*   DAVE_STATUS_t status;
*   XMC_BCCU_DIM_CURVE_t dim_curve;
*   status = DAVE_Init();// DIM_BCCU_Init() will be called within DAVE_Init()
*   if (status == DAVE_STATUS_FAILURE)
*   {
*     XMC_DEBUG(("DAVE APPs initialization failed with status %d\n", status));
*     while(1U)
*     {
*     }
*   }
*
*   while(1)
*   {
*     // Set Target Level 12.5%
*     // Set Target Level 12.5%
*     DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 512);
*     // Start Dimming
*     DIM_BCCU_StartDimming(&DIM_BCCU_0);
*     // Wait for Completion
*     DIM_BCCU_AwaitFadeCompletion(&DIM_BCCU_0);
*
*     // ohh!! dimming is not as per expected
*     // check for dimming curve
*     dim_curve = DIM_BCCU_GetDimCurve(&DIM_BCCU_0); // get dimming curve
*     // coarse curve
*     // let's use fine curve (without dither)
*     if (dim_curve != XMC_BCCU_DIM_CURVE_FINE)
*     {
*       DIM_BCCU_SetDimCurveAndDither(&DIM_BCCU_0, 0, XMC_BCCU_DIM_CURVE_FINE); // set dimming curve
*     }
*
*  }
*  return (1);
* }
*
* @endcode<BR>
*/

void DIM_BCCU_SetDimCurveAndDither(DIM_BCCU_t *handle, uint32_t dither, XMC_BCCU_DIM_CURVE_t curve);

 /**
* @brief Returns dimming completion status.
* @param handle Pointer pointing to APP data structure. Refer @ref DIM_BCCU_t for details.
* @return uint32_t status of dimming completion. Range: 0-Completed or 1-start change towards the target.
*
* \par<b>Description: </b><br>
* Retrieves dimming completion status dimming engine by reading the register bit DESTRCON_DEyS. By calling this function,
* the user can check whether the dimming process has finished.
*
* \par<b>Example Usage:</b><br>
* Step1: Instantiate 1 PDM_BCCU and 1 DIM_BCCU APPs.<br>
* Step2: Enable dimming engine in DIM_BCCU APP GUI.<br>
* Step3: Deselect bypass dimming input in PDM_BCCU APP GUI.<br>
* Step4: Make HW signal connection from DIM_BCCU's dimming_level_output to PDM_BCCU's dimming_level_input.<br>
*
* @code
* #include <DAVE.h>
* int main(void)
* {
*   DAVE_STATUS_t status;
*   uint32_t dim_status;
*   status = DAVE_Init();// DIM_BCCU_Init() will be called within DAVE_Init()
*   if (status == DAVE_STATUS_FAILURE)
*   {
*     XMC_DEBUG(("DAVE APPs initialization failed with status %d\n", status));
*     while(1U)
*     {
*     }
*   }
*
*   while(1)
*   {
*     // Set Target Level 12.5%
*     DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 512);
*     // Start Dimming
*     DIM_BCCU_StartDimming(&DIM_BCCU_0);
*     // Wait for Completion
*     while(dim_status!=1) {
*       dim_status = DIM_BCCU_FadeCompletionStatus(&DIM_BCCU_0);  // check for dimming process completion
*     }
*   }
*  return (1);
* }
*
* @endcode<BR>
*/

uint32_t DIM_BCCU_FadeCompletionStatus(DIM_BCCU_t *handle);

/**
* @brief Waits until dimming process is finished.
* @param handle Pointer pointing to APP data structure. Refer @ref DIM_BCCU_t for details.
* @return none.
*
* \par<b>Description: </b><br>
* Keep polling until fading has completed.
*
* \par<b>Example Usage:</b><br>
* Step1: Instantiate 1 PDM_BCCU and 1 DIM_BCCU APPs.<br>
* Step2: Enable dimming engine in DIM_BCCU APP GUI.<br>
* Step3: Deselect bypass dimming input in PDM_BCCU APP GUI.<br>
* Step4: Make HW signal connection from DIM_BCCU's dimming_level_output to PDM_BCCU's dimming_level_input.<br>
*
* @code
* #include <DAVE.h>
* int main(void)
* {
*   DAVE_STATUS_t status;
*   status = DAVE_Init();// DIM_BCCU_Init() will be called within DAVE_Init()
*   if (status == DAVE_STATUS_FAILURE)
*   {
*     XMC_DEBUG(("DAVE APPs initialization failed with status %d\n", status));
*     while(1U)
*     {
*     }
*   }
*
*   while(1)
*   {
*     // Set Target Level 12.5%
*     DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 512);
*     // Start Dimming
*     DIM_BCCU_StartDimming(&DIM_BCCU_0);
*     // Wait for Completion
*     DIM_BCCU_AwaitFadeCompletion(&DIM_BCCU_0);
*   }
*  return (1);
* }
*
* @endcode<BR>
*/

void DIM_BCCU_AwaitFadeCompletion(DIM_BCCU_t *handle);

/**
* @brief Set dimming clock divider value.
* @param handle Pointer pointing to APP data structure. Refer @ref DIM_BCCU_t for details.
* @param dimdiv dimming clock divider value.
* @return none.<BR>
*
* \par<b>Description: </b><br>
* \a Dimdiv can be used to adjust the fade rate of the dimming process.
*
* \par<b>Example Usage:</b><br>
* Step1: Instantiate 1 PDM_BCCU and 1 DIM_BCCU APPs.<br>
* Step2: Enable dimming engine in DIM_BCCU APP GUI.<br>
* Step3: Deselect bypass dimming input in PDM_BCCU APP GUI.<br>
* Step4: Make HW signal connection from DIM_BCCU's dimming_level_output to PDM_BCCU's dimming_level_input.<br>
*
* @code
* #include <DAVE.h>
* int main(void)
* {
*   DAVE_STATUS_t status;
*   status = DAVE_Init();// DIM_BCCU_Init() will be called within DAVE_Init()
*   if (status == DAVE_STATUS_FAILURE)
*   {
*     XMC_DEBUG(("DAVE APPs initialization failed with status %d\n", status));
*     while(1U)
*     {
*     }
*   }
*
*   while(1)
*   {
*
*     // set dimming clock divider to slow dimming
*     DIM_BCCU_SetDimDiv(&DIM_BCCU_0, 1023);
*     // Set Target Level 12.5%
*     DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 512);
*     // Start Dimming
*     DIM_BCCU_StartDimming(&DIM_BCCU_0);
*     // Wait for Completion
*     DIM_BCCU_AwaitFadeCompletion(&DIM_BCCU_0);
*
*     DIM_BCCU_SetDimDiv(&DIM_BCCU_0, 10);
*     // Set Target Level to 0%
*     DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 0);
*     // Start Dimming
*     DIM_BCCU_StartDimming(&DIM_BCCU_0);
*     // Wait for Completion
*     DIM_BCCU_AwaitFadeCompletion(&DIM_BCCU_0);
*   }
*  return (1);
* }
*
* @endcode<BR>
*/

void DIM_BCCU_SetDimDiv(DIM_BCCU_t *handle, uint32_t dimdiv);

/**
* @brief Get dimming clock divider value.
* @param handle Pointer pointing to APP data structure. Refer @ref DIM_BCCU_t for details.
* @return uint32_t Dimming Clock Divider.
*
* \par<b>Example Usage:</b><br>
* Step1: Instantiate 1 PDM_BCCU and 1 DIM_BCCU APPs.<br>
* Step2: Enable dimming engine in DIM_BCCU APP GUI.<br>
* Step3: Deselect bypass dimming input in PDM_BCCU APP GUI.<br>
* Step4: Make HW signal connection from DIM_BCCU's dimming_level_output to PDM_BCCU's dimming_level_input.<br>
*
* @code
* #include <DAVE.h>
* int main(void)
* {
*   DAVE_STATUS_t status;
*   uint32_t dim_div;
*   status = DAVE_Init();// DIM_BCCU_Init() will be called within DAVE_Init()
*
*   if (status == DAVE_STATUS_FAILURE)
*   {
*     XMC_DEBUG(("DAVE APPs initialization failed with status %d\n", status));
*     while(1U)
*     {
*     }
*   }
*
*   while(1)
*   {
*     // Set Target Level 12.5%
*     DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 512);
*     // Start Dimming
*     DIM_BCCU_StartDimming(&DIM_BCCU_0);
*     // Wait for Completion
*     DIM_BCCU_AwaitFadeCompletion(&DIM_BCCU_0);
*
*     // Set Target Level to 0%
*     DIM_BCCU_SetDimLvl(&DIM_BCCU_0, 0);
*     // Start Dimming
*     DIM_BCCU_StartDimming(&DIM_BCCU_0);
*     // Wait for Completion
*     DIM_BCCU_AwaitFadeCompletion(&DIM_BCCU_0);
*
*     // ohh!! dimming is not as per expected, it seems to be fast, let us check
*     dim_div = DIM_BCCU_GetDimDiv(&DIM_BCCU_0);
*     if (dim_div <= 200)
*     {
*       DIM_BCCU_SetDimDiv(&DIM_BCCU_0, 200); // set dimming clock divider
*     }
*
*     // let's try it again
*
*
*   }
*  return (1);
* }
*
* @endcode<BR>
*/

uint32_t DIM_BCCU_GetDimDiv(DIM_BCCU_t *handle);

/**
* @}
*/

#ifdef __cplusplus
}
#endif

  /* Include APP extern file */
#include "dim_bccu_extern.h"



#endif /* DIM_BCCU_H */
