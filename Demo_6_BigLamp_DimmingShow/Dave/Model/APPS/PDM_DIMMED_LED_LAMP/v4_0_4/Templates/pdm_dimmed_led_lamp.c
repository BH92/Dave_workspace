/**
 * @file PDM_DIMMED_LED_LAMP.c
 * @date 2016-07-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * PDM_DIMMED_LED_LAMP v4.0.4 - Creates a virtual lamp with up to 9 BCCU channels,optionally controls the peak current using various internal driver methods.
 *                              The APP provides a run-time functions to change a color, dimming level and adjustable peak current reference.
 *
 * Copyright (c) 2015-2016, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-10-08:
 *     - Initial version.<br>
 *
 * 2016-07-08:
 *     - Fixed incorrect case for an included header.<br>
 *
 * @endcond
 *
 */
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/

#include "pdm_dimmed_led_lamp.h"

/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/


/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/


/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/
#if (1U == PDM_DIMMED_LED_LAMP_PEAK_CUR_CTRL_ENABLE)
static PDM_DIMMED_LED_LAMP_STATUS_t PDM_DIMMED_LED_LAMP_lPeakCurCtrlInit(PDM_DIMMED_LED_LAMP_t *handle, uint32_t count);
#endif

/*
 * @brief API to retrieve the version of the PDM_DIMMED_LED_LAMP
 *
 * @return DAVE_APP_VERSION_t Structure containing major version, minor version
 *         and patch version.
 */
DAVE_APP_VERSION_t PDM_DIMMED_LED_LAMP_GetAppVersion(void)
{
  DAVE_APP_VERSION_t version;

  version.major = (uint8_t)PDM_DIMMED_LED_LAMP_MAJOR_VERSION;
  version.minor = (uint8_t)PDM_DIMMED_LED_LAMP_MINOR_VERSION;
  version.patch = (uint8_t)PDM_DIMMED_LED_LAMP_PATCH_VERSION;

  return (version);
}

#if (1U == PDM_DIMMED_LED_LAMP_PEAK_CUR_CTRL_ENABLE)
PDM_DIMMED_LED_LAMP_STATUS_t PDM_DIMMED_LED_LAMP_lPeakCurCtrlInit(PDM_DIMMED_LED_LAMP_t *handle, uint32_t count)
{
  PDM_DIMMED_LED_LAMP_STATUS_t status;
  status = PDM_DIMMED_LED_LAMP_STATUS_SUCCESS;

#if (1U == PDM_DIMMED_LED_LAMP_PWM_CCU4_APP_USED)
  if((PDM_DIMMED_LED_LAMP_CTRL_METHOD_SLOW_DCDC == handle->method) || (PDM_DIMMED_LED_LAMP_CTRL_METHOD_SIMPLE_DCDC == handle->method))
  {
    status = (PDM_DIMMED_LED_LAMP_STATUS_t) PWM_CCU4_Init (handle->peak_cur_ctrl_ccu4[count]);
  }
#if(1U == PDM_DIMMED_LED_LAMP_SIMPLE_DCDC_USED)
if(PDM_DIMMED_LED_LAMP_CTRL_METHOD_SIMPLE_DCDC == handle->method)
{
/* GPIO initialization based on UI */
  XMC_GPIO_Init(handle->gpio_config_out[count]->port, handle->gpio_config_out[count]->pin, handle->gpio_config_out[count]->config);
  XMC_GPIO_Init(handle->gpio_config_in[count]->port, handle->gpio_config_in[count]->pin, handle->gpio_config_in[count]->config);
}
#endif
#endif
#if (1U == PDM_DIMMED_LED_LAMP_PWM_CCU8_APP_USED)
  if((PDM_DIMMED_LED_LAMP_CTRL_METHOD_FAST_DCDC == handle->method) && (PDM_DIMMED_LED_LAMP_STATUS_SUCCESS == status))
  {
    status = (PDM_DIMMED_LED_LAMP_STATUS_t) PWM_CCU8_Init (handle->peak_cur_ctrl_ccu8[count]);
  }
#endif

    status = (PDM_DIMMED_LED_LAMP_STATUS_t) COMP_REF_Init (handle->peak_cur_ctrl_comp[count]);

  return (status);
}
#endif

/**
 * Function which initializes the BCCU peripheral registers using PDM_BCCU & DIM_BCCU APPs
 */
PDM_DIMMED_LED_LAMP_STATUS_t PDM_DIMMED_LED_LAMP_Init(PDM_DIMMED_LED_LAMP_t *handle)
{
  uint32_t count = 0U;
  uint32_t channel_mask = 0U;
  PDM_DIMMED_LED_LAMP_STATUS_t status;
  status = PDM_DIMMED_LED_LAMP_STATUS_SUCCESS;

  /* Checks input parameters when XMC_ASSERT is enabled. Useful for Debugging */
#if (1U == PDM_DIMMED_LED_LAMP_DIMAPP_USED)
  XMC_ASSERT("PDM_DIMMED_LED_LAMP APP handle function pointer uninitialized", (((handle != NULL) && (handle->led[0] != NULL)) &&
            ((handle->dim_engine != NULL) && (handle->config != NULL) && (handle->led_channel_mask <= 511U) &&
            (handle->linearwalk_prescaler <= 1023U) && (handle->dim_div <= 1023U) && (handle->dim_prescaler <= 4095U) &&
            (handle->dim_no <= 2U) && (handle->no_of_leds_used <= 9U))));
#else
  XMC_ASSERT("PDM_DIMMED_LED_LAMP APP handle function pointer uninitialized", (((handle != NULL) && (handle->led[0] != NULL)) &&
            ((handle->led_channel_mask <= 511U) && (handle->linearwalk_prescaler <= 1023U) &&
            (handle->dim_div <= 1023U) && (handle->dim_prescaler <= 4095U) && (handle->dim_no <= 2U) &&
            (handle->no_of_leds_used <= 9U))));
#endif

  do
  {
    status = (PDM_DIMMED_LED_LAMP_STATUS_t) PDM_BCCU_Init(handle->led[count]);
    channel_mask |= ((uint32_t)1U << handle->led[count]->channel_no);
#if (1U == PDM_DIMMED_LED_LAMP_PEAK_CUR_CTRL_ENABLE)
    if((PDM_DIMMED_LED_LAMP_CTRL_METHOD_DIRECT_PDM != handle->method) && (PDM_DIMMED_LED_LAMP_STATUS_SUCCESS == status))
    {
      status = PDM_DIMMED_LED_LAMP_lPeakCurCtrlInit(handle, count);
    }
#endif
    count++;
  } while ((count < (handle->no_of_leds_used)) && (status == PDM_DIMMED_LED_LAMP_STATUS_SUCCESS));

  if (PDM_DIMMED_LED_LAMP_STATUS_SUCCESS == status)
  {
    /* Updating the channel mask into PDM_DIMMED_LED_LAMP handle */
    handle->led_channel_mask = (uint16_t)channel_mask;
#if (1U == PDM_DIMMED_LED_LAMP_DIMAPP_USED)
    if (true == handle->dimming_used)
    {
      status = (PDM_DIMMED_LED_LAMP_STATUS_t) DIM_BCCU_Init (handle->dim_engine);
      /* Updating the dimming engine number into PDM_DIMMED_LED_LAMP handle */
      handle->dim_no = (uint8_t)(handle->dim_engine->dim_engine_num);
    }
#endif
  }
  return (status);
}


/**
 * @brief Function which configures desired color for mapped channels run time by solver.
 *
 * @param  handle with pointers to static and dynamic content.
 * @return none.<BR>
 */
void PDM_DIMMED_LED_LAMP_SetColor(PDM_DIMMED_LED_LAMP_t *handle)
{
  XMC_ASSERT("PDM_DIMMED_LED_LAMP APP handle function pointer uninitialized", (handle != NULL));
  uint32_t count = 0U;
  BCCU_CH_Type *ch_ptr;
  for (count = 0U; count < handle->no_of_leds_used; count++)
  {
    ch_ptr = handle->led[count]->bccu_ch;
    XMC_BCCU_CH_SetTargetIntensity(ch_ptr, handle->config->led_intensity[count]);
    XMC_BCCU_CH_SetLinearWalkPrescaler(ch_ptr, handle->linearwalk_prescaler);
  }

  XMC_BCCU_ConcurrentStartLinearWalk(handle->led[0]->bccu_regs, handle->led_channel_mask);
}

/**
 * @brief Function which configures desired color and linear walk prescaler for mapped channels run time by solver.
 *
 * @param  handle with pointers to static and dynamic content.
 * @param linearwalk_prescaler
 * @return none.<BR>
 */
void PDM_DIMMED_LED_LAMP_SetColorAdv(PDM_DIMMED_LED_LAMP_t *handle, uint32_t linearwalk_prescaler)
{
  XMC_ASSERT("PDM_DIMMED_LED_LAMP APP handle function pointer uninitialized", (handle != NULL));
  uint32_t count;
  BCCU_CH_Type *ch_ptr;
  for (count = 0U; count < handle->no_of_leds_used; count++)
  {
    ch_ptr = handle->led[count]->bccu_ch;
    XMC_BCCU_CH_SetTargetIntensity(ch_ptr, handle->config->led_intensity[count]);
    XMC_BCCU_CH_SetLinearWalkPrescaler(ch_ptr, linearwalk_prescaler);
  }

  XMC_BCCU_ConcurrentStartLinearWalk(handle->led[0]->bccu_regs, handle->led_channel_mask);
}

/**
 * @brief Function which aborts color change for mapped channels run time by solver.
 *
 * @param  handle with pointers to static and dynamic content.
 * @return none.<BR>
 */
void PDM_DIMMED_LED_LAMP_AbortColorChange(PDM_DIMMED_LED_LAMP_t *handle)
{
  XMC_ASSERT("PDM_DIMMED_LED_LAMP APP handle function pointer uninitialized", (handle != NULL));
  XMC_BCCU_ConcurrentAbortLinearWalk(handle->led[0]->bccu_regs, handle->led_channel_mask);
}

#if (1U == PDM_DIMMED_LED_LAMP_DIMAPP_USED)
/**
 * Function which configures target dimming level
 */
void PDM_DIMMED_LED_LAMP_SetDimLevelExponential(PDM_DIMMED_LED_LAMP_t *handle)
{
  XMC_ASSERT("PDM_DIMMED_LED_LAMP APP handle function pointer uninitialized", (handle != NULL));
  BCCU_Type *global_ptr;
  BCCU_DE_Type *dim_ptr;
  global_ptr = handle->led[0]->bccu_regs;
  dim_ptr = handle->dim_engine->bccu_de_regs;

  XMC_BCCU_SetDimClockPrescaler(global_ptr, handle->dim_prescaler);
  XMC_BCCU_DIM_SetDimDivider(dim_ptr, handle->dim_div);
  XMC_BCCU_DIM_SetTargetDimmingLevel(dim_ptr, handle->config->dim_level);
  XMC_BCCU_StartDimming(global_ptr, handle->dim_no);
}
/**
 * @brief Function which configures target dimming level, dimming clock divider and dimming engine clock (dclk)
 * prescaler values run time for mapped dimming engine.
 *
 * @param  handle with pointers to static and dynamic content.
 * @param dim_div
 * @param dim_prescaler
 * @return none.<BR>
 */
void PDM_DIMMED_LED_LAMP_SetDimLevelExponentialAdv(PDM_DIMMED_LED_LAMP_t *handle, uint32_t dim_div ,uint32_t dim_prescaler)
{
  XMC_ASSERT("PDM_DIMMED_LED_LAMP APP handle function pointer uninitialized", (handle != NULL));
  BCCU_Type *global_ptr;
  BCCU_DE_Type *dim_ptr;
  global_ptr = handle->led[0]->bccu_regs;
  dim_ptr = handle->dim_engine->bccu_de_regs;

  XMC_BCCU_SetDimClockPrescaler(global_ptr, dim_prescaler);
  XMC_BCCU_DIM_SetDimDivider(dim_ptr, dim_div);
  XMC_BCCU_DIM_SetTargetDimmingLevel(dim_ptr, handle->config->dim_level);
  XMC_BCCU_StartDimming(global_ptr, handle->dim_no);
}

/**
 * @brief Function which aborts dimming process run time.
 *
 * @param  handle with pointers to static and dynamic content.
 * @return none.<BR>
 */
void PDM_DIMMED_LED_LAMP_AbortDimming(PDM_DIMMED_LED_LAMP_t *handle)
{
  XMC_ASSERT("PDM_DIMMED_LED_LAMP APP handle function pointer uninitialized", (handle != NULL));
  XMC_BCCU_AbortDimming(handle->led[0]->bccu_regs, handle->dim_no);
}
#endif


#if (1U == PDM_DIMMED_LED_LAMP_PEAK_CUR_CTRL_ENABLE)
PDM_DIMMED_LED_LAMP_STATUS_t PDM_DIMMED_LED_LAMP_SetOffTime(PDM_DIMMED_LED_LAMP_t *handle)
{
  XMC_ASSERT("PDM_DIMMED_LED_LAMP APP handle function pointer uninitialized", (handle != NULL));
  PDM_DIMMED_LED_LAMP_STATUS_t status;
  uint32_t count = 0U;
  uint32_t duty = 0U;
  status = PDM_DIMMED_LED_LAMP_STATUS_FAILURE;

  do
  {
	/* Duty = 100 - (OFF_Time(in ns) * 100) * PWM_Freq (in hz) */
	 duty = 10000U - (uint32_t)((handle->peak_cur_ctrl_freq * handle->config->peakcur_ctrl_offtime[count]) / 100U);
#if (1U == PDM_DIMMED_LED_LAMP_PWM_CCU8_APP_USED)
    if(PDM_DIMMED_LED_LAMP_CTRL_METHOD_FAST_DCDC == handle->method)
    {
      status = (PDM_DIMMED_LED_LAMP_STATUS_t) PWM_CCU8_SetDutyCycleSymmetric(handle->peak_cur_ctrl_ccu8[count],
                                       XMC_CCU8_SLICE_COMPARE_CHANNEL_1, duty);
    }
#endif
#if (1U == PDM_DIMMED_LED_LAMP_PWM_CCU4_APP_USED)
    if((PDM_DIMMED_LED_LAMP_CTRL_METHOD_SLOW_DCDC == handle->method) || (PDM_DIMMED_LED_LAMP_CTRL_METHOD_SIMPLE_DCDC == handle->method))
    {
      status = (PDM_DIMMED_LED_LAMP_STATUS_t) PWM_CCU4_SetDutyCycle(handle->peak_cur_ctrl_ccu4[count], duty);
    }
#endif
    count++;
  } while ((count < (handle->no_of_leds_used)) && (status == PDM_DIMMED_LED_LAMP_STATUS_SUCCESS));

  return (status);
}
#endif

#if ((1U == PDM_DIMMED_LED_LAMP_PEAK_CUR_CTRL_ENABLE) && (1U == PDM_DIMMED_LED_LAMP_PEAK_CUR_INTERNAL_REF))
PDM_DIMMED_LED_LAMP_STATUS_t PDM_DIMMED_LED_LAMP_SetPeakReference(PDM_DIMMED_LED_LAMP_t *handle)
{
  XMC_ASSERT("PDM_DIMMED_LED_LAMP APP handle function pointer uninitialized", (handle != NULL));
  PDM_DIMMED_LED_LAMP_STATUS_t status;
  uint32_t count = 0U;
  uint32_t scaled_reference_value = 0U;
  status = PDM_DIMMED_LED_LAMP_STATUS_FAILURE;

  do
  {
    if(PDM_DIMMED_LED_LAMP_PEAK_CUR_REF_EXTERNAL != handle->config->peak_cur_ctrl_ref[count])
    {
      /* scaled_reference_value = (Peak Reference(mV) * COMP_REF_SCALING_FACTOR)/1000 */
      scaled_reference_value = (uint32_t) ((handle->config->peak_cur_ctrl_refval[count] * COMP_REF_SCALING_FACTOR) / 1000U);
      status = (PDM_DIMMED_LED_LAMP_STATUS_t) COMP_REF_UpdateReferenceValue(handle->peak_cur_ctrl_comp[count], scaled_reference_value);
    }
    count++;
  } while ((count < (handle->no_of_leds_used)) && (status == PDM_DIMMED_LED_LAMP_STATUS_SUCCESS));

  return (status);
}
#endif
