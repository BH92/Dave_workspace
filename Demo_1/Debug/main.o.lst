   1              	 .cpu cortex-m0
   2              	 .fpu softvfp
   3              	 .eabi_attribute 20,1
   4              	 .eabi_attribute 21,1
   5              	 .eabi_attribute 23,3
   6              	 .eabi_attribute 24,1
   7              	 .eabi_attribute 25,1
   8              	 .eabi_attribute 26,1
   9              	 .eabi_attribute 30,6
  10              	 .eabi_attribute 34,0
  11              	 .eabi_attribute 18,4
  12              	 .code 16
  13              	 .file "main.c"
  14              	 .text
  15              	.Ltext0:
  16              	 .cfi_sections .debug_frame
  17              	 .section .text.XMC_GPIO_SetOutputHigh,"ax",%progbits
  18              	 .align 2
  19              	 .code 16
  20              	 .thumb_func
  22              	XMC_GPIO_SetOutputHigh:
  23              	.LFB41:
  24              	 .file 1 "C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc/xmc_gpio.h"
   1:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** /**
   2:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @file xmc_gpio.h
   3:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @date 2015-06-20
   4:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
   5:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @cond
   6:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****   *************************************************************************************************
   7:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * XMClib v2.1.6 - XMC Peripheral Driver Library 
   8:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
   9:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Copyright (c) 2015-2016, Infineon Technologies AG
  10:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * All rights reserved.                        
  11:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *                                             
  12:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * following conditions are met:   
  14:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *                                                                              
  15:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  16:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * disclaimer.                        
  17:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * 
  18:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  19:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  20:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * 
  21:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  22:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * products derived from this software without specific prior written permission.                  
  23:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *                                                                              
  24:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  31:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *                                                                              
  32:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Infineon Technologies AG dave@infineon.com).                                                    
  34:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
  35:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  36:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Change History
  37:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * --------------
  38:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  39:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * 2015-02-20:
  40:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Initial draft<br>
  41:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Documentation improved <br>
  42:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *      
  43:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * 2015-06-20:
  44:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Removed version macros and declaration of GetDriverVersion API
  45:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  46:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @endcond
  47:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  48:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  49:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
  50:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** #ifndef XMC_GPIO_H
  51:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_H
  52:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
  53:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
  54:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * HEADER FILES
  55:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
  56:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
  57:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc_common.h"
  58:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
  59:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** /**
  60:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @addtogroup XMClib XMC Peripheral Library
  61:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @{
  62:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  63:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
  64:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** /**
  65:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @addtogroup GPIO
  66:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @brief General Purpose Input Output (GPIO) driver for the XMC microcontroller family.
  67:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  68:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * GPIO driver provide a generic and very flexible software interface for all standard digital I/O 
  69:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Each port slice has individual interfaces for the operation as General Purpose I/O and it furthe
  70:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * connectivity to the on-chip periphery and the control for the pad characteristics. 
  71:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  72:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * The driver is divided into Input and Output mode.
  73:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  74:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Input mode features:
  75:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Configuration structure XMC_GPIO_CONFIG_t and initialization function XMC_GPIO_Init()
  76:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of weak pull-up or pull-down device. Configuration structure XMC_GPIO_MO
  77:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC1
  78:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of input hysteresis. XMC_GPIO_SetInputHysteresis()
  79:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
  80:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  81:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * 
  82:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Output mode features:
  83:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of push pull/open drain and Alternate output. Configuration structure XM
  84:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC4
  85:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of pad driver strength. Configuration structure XMC_GPIO_OUTPUT_STRENGTH
  86:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
  87:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  88:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of initial output level. Configuration structure XMC_GPIO_OUTPUT_LEVEL_t
  89:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  90:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *@{
  91:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  92:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  
  93:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
  94:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * MACROS
  95:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
  96:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
  97:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Pos PORT0_IOCR0_PC0_Pos
  98:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Msk PORT0_IOCR0_PC0_Msk
  99:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 100:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Size 				(8U)
 101:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 											
 102:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 103:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_CHECK_OUTPUT_LEVEL(level) ((level == XMC_GPIO_OUTPUT_LEVEL_LOW) || \
 104:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****                                             (level == XMC_GPIO_OUTPUT_LEVEL_HIGH))
 105:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****                                             
 106:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_CHECK_HWCTRL(hwctrl) ((hwctrl == XMC_GPIO_HWCTRL_DISABLED) || \
 107:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****                                        (hwctrl == XMC_GPIO_HWCTRL_PERIPHERAL1) || \
 108:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****                                        (hwctrl == XMC_GPIO_HWCTRL_PERIPHERAL2))                    
 109:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****                                             
 110:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 111:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * ENUMS
 112:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 113:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 114:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 115:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 116:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Defines output level of a pin. Use type \a XMC_GPIO_OUTPUT_LEVEL_t for this enum.
 117:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 118:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** typedef enum XMC_GPIO_OUTPUT_LEVEL
 119:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** {
 120:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_OUTPUT_LEVEL_LOW  = 0x10000U, /**<  Reset bit */
 121:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_OUTPUT_LEVEL_HIGH = 0x1U, 	/**< Set bit  */
 122:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** } XMC_GPIO_OUTPUT_LEVEL_t;
 123:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 124:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 125:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Defines direct hardware control characteristics of the pin . Use type \a XMC_GPIO_HWCTRL_t for t
 126:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 127:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** typedef enum XMC_GPIO_HWCTRL
 128:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** {
 129:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_DISABLED     = 0x0U, /**<  Software control only */
 130:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_PERIPHERAL1  = 0x1U, /**<  HWI0/HWO0 control path can override the software confi
 131:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_PERIPHERAL2  = 0x2U  /**<  HWI1/HWO1 control path can override the software confi
 132:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** } XMC_GPIO_HWCTRL_t;
 133:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 134:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 135:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * DEVICE FAMILY EXTENSIONS
 136:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 137:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 138:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  #if UC_FAMILY == XMC1
 139:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc1_gpio.h"
 140:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** #elif UC_FAMILY == XMC4
 141:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc4_gpio.h"
 142:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** #else
 143:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** #error "xmc_gpio.h: family device not supported"
 144:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** #endif
 145:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 146:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 147:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * API PROTOTYPES
 148:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 149:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 150:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** #ifdef __cplusplus
 151:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** extern "C" {
 152:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** #endif
 153:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 154:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 155:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 156:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	  Constant pointer pointing to GPIO port, to access port registers like Pn_OUT,Pn_O
 157:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	  Port pin number.
 158:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  config GPIO configuration data structure. Refer data structure @ref XMC_GPIO_CONFIG_t fo
 159:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 160:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 161:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 162:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 163:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC1
 164:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Initializes input / output mode settings like, pull up / pull down devices,hysteresis, push pull
 165:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Also configures alternate function outputs and clears hardware port control for a selected \a po
 166:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \a config provides selected I/O settings. It configures hardware registers Pn_IOCR,Pn_OUT, Pn_OM
 167:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
 168:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC4
 169:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Initializes input / output mode settings like, pull up / pull down devices,push pull /open drain
 170:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Also configures alternate function outputs and clears hardware port control for selected \a port
 171:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * It configures hardware registers Pn_IOCR,Pn_OUT,Pn_OMR,Pn_PDISC and Pn_PDR.\n
 172:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
 173:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 174:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 175:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *  None
 176:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 177:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 178:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * This API is called in definition of DAVE_init by code generation and therefore should not be exp
 179:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * for the normal operation. Use other APIs only after DAVE_init is called successfully (returns DA
 180:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 181:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 182:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 183:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 184:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  
 185:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const c
 186:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  
 187:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 188:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 189:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	Constant pointer pointing to GPIO port, to access hardware register Pn_IOCR.
 190:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	Port pin number.
 191:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  mode input / output functionality selection. Refer @ref XMC_GPIO_MODE_t for valid values
 192:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 193:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 194:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 195:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 196:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Sets digital input and output driver functionality and characteristics of a GPIO port pin. It co
 197:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * registers Pn_IOCR. \a mode is initially configured during initialization in XMC_GPIO_Init(). Cal
 198:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * the port direction functionality as needed later in the program.
 199:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 200:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 201:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *  None
 202:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 203:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 204:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 205:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** void XMC_GPIO_SetMode(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_MODE_t mode);
 206:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 207:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 208:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 209:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 210:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	 Constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 211:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	 Port pin number.
 212:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  level output level selection. Refer @ref XMC_GPIO_OUTPUT_LEVEL_t for valid values.
 213:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 214:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 215:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 216:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 217:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Set port pin output level to high or low.It configures hardware registers Pn_OMR.\a level is ini
 218:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * configured during initialization in XMC_GPIO_Init(). Call this API to alter output level as need
 219:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 220:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 221:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *  XMC_GPIO_SetOutputHigh(), XMC_GPIO_SetOutputLow().
 222:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 223:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 224:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().
 225:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 226:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 227:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 228:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 229:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputLevel(XMC_GPIO_PORT_t *const port, const uint8_t pin, const 
 230:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** {
 231:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 232:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid output level", XMC_GPIO_CHECK_OUTPUT_LEVEL(level));
 233:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****   
 234:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = (uint32_t)level << pin;
 235:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** }
 236:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 237:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 238:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 239:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 240:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	Port pin number.
 241:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 242:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 243:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 244:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 245:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *  Sets port pin output to high. It configures hardware registers Pn_OMR.
 246:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 247:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *  \par<b>Related APIs:</b><BR>
 248:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *  XMC_GPIO_SetOutputLow()
 249:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 250:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 251:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().\n
 252:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value 
 253:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 254:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 255:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 256:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 257:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** {
  25              	 .loc 1 257 0
  26              	 .cfi_startproc
  27 0000 80B5     	 push {r7,lr}
  28              	.LCFI0:
  29              	 .cfi_def_cfa_offset 8
  30              	 .cfi_offset 7,-8
  31              	 .cfi_offset 14,-4
  32 0002 82B0     	 sub sp,sp,#8
  33              	.LCFI1:
  34              	 .cfi_def_cfa_offset 16
  35 0004 00AF     	 add r7,sp,#0
  36              	.LCFI2:
  37              	 .cfi_def_cfa_register 7
  38 0006 7860     	 str r0,[r7,#4]
  39 0008 0A1C     	 mov r2,r1
  40 000a FB1C     	 add r3,r7,#3
  41 000c 1A70     	 strb r2,[r3]
 258:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 259:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 260:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = (uint32_t)0x1U << pin;
  42              	 .loc 1 260 0
  43 000e FB1C     	 add r3,r7,#3
  44 0010 1B78     	 ldrb r3,[r3]
  45 0012 0122     	 mov r2,#1
  46 0014 9A40     	 lsl r2,r2,r3
  47 0016 7B68     	 ldr r3,[r7,#4]
  48 0018 5A60     	 str r2,[r3,#4]
 261:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** }
  49              	 .loc 1 261 0
  50 001a BD46     	 mov sp,r7
  51 001c 02B0     	 add sp,sp,#8
  52              	 
  53 001e 80BD     	 pop {r7,pc}
  54              	 .cfi_endproc
  55              	.LFE41:
  57              	 .section .text.XMC_GPIO_SetOutputLow,"ax",%progbits
  58              	 .align 2
  59              	 .code 16
  60              	 .thumb_func
  62              	XMC_GPIO_SetOutputLow:
  63              	.LFB42:
 262:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 263:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 264:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 265:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 266:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	port pin number.
 267:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 268:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return  None
 269:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 270:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *\par<b>Description:</b><br>
 271:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Sets port pin output to low. It configures hardware registers Pn_OMR.\n
 272:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 273:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>>
 274:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * XMC_GPIO_SetOutputHigh()
 275:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 276:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *\par<b>Note:</b><br>
 277:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().
 278:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value 
 279:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 280:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 281:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 282:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 283:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** {
  64              	 .loc 1 283 0
  65              	 .cfi_startproc
  66 0000 80B5     	 push {r7,lr}
  67              	.LCFI3:
  68              	 .cfi_def_cfa_offset 8
  69              	 .cfi_offset 7,-8
  70              	 .cfi_offset 14,-4
  71 0002 82B0     	 sub sp,sp,#8
  72              	.LCFI4:
  73              	 .cfi_def_cfa_offset 16
  74 0004 00AF     	 add r7,sp,#0
  75              	.LCFI5:
  76              	 .cfi_def_cfa_register 7
  77 0006 7860     	 str r0,[r7,#4]
  78 0008 0A1C     	 mov r2,r1
  79 000a FB1C     	 add r3,r7,#3
  80 000c 1A70     	 strb r2,[r3]
 284:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 285:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** 
 286:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = 0x10000U << pin;
  81              	 .loc 1 286 0
  82 000e FB1C     	 add r3,r7,#3
  83 0010 1B78     	 ldrb r3,[r3]
  84 0012 8022     	 mov r2,#128
  85 0014 5202     	 lsl r2,r2,#9
  86 0016 9A40     	 lsl r2,r2,r3
  87 0018 7B68     	 ldr r3,[r7,#4]
  88 001a 5A60     	 str r2,[r3,#4]
 287:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_gpio.h **** }
  89              	 .loc 1 287 0
  90 001c BD46     	 mov sp,r7
  91 001e 02B0     	 add sp,sp,#8
  92              	 
  93 0020 80BD     	 pop {r7,pc}
  94              	 .cfi_endproc
  95              	.LFE42:
  97 0022 C046     	 .section .text.DIGITAL_IO_SetOutputHigh,"ax",%progbits
  98              	 .align 2
  99              	 .code 16
 100              	 .thumb_func
 102              	DIGITAL_IO_SetOutputHigh:
 103              	.LFB49:
 104              	 .file 2 "C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO/digital_io.h"
   1:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** /*
   2:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
   3:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * @file digital_io.h
   4:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * @date 2015-12-22
   5:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
   6:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * NOTE:
   7:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * This file is generated by DAVE. Any manual modification done to this file will be lost when the 
   8:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
   9:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * @cond
  10:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  11:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * DIGITAL_IO v4.0.14 - The DIGITAL_IO APP is used to configure a port pin as digital Input/Output.
  12:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  13:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * Copyright (c) 2015, Infineon Technologies AG
  14:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * All rights reserved.
  15:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  16:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  17:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * following conditions are met:
  18:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  19:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  20:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   disclaimer.
  21:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  22:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  23:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   following disclaimer in the documentation and/or other materials provided with the distributio
  24:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  25:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  26:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   products derived from this software without specific prior written permission.
  27:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  28:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  29:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  30:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  31:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  32:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  33:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  34:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  35:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  36:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  37:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * with Infineon Technologies AG (dave@infineon.com).
  38:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  39:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  40:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * Change History
  41:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * --------------
  42:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  43:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2015-02-16
  44:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Initial version
  45:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  46:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2015-04-22
  47:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - XMC_ASSERT is added in static inline functions.<br>
  48:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  49:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2015-06-20
  50:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Version check added for XMCLib dependency.<br>
  51:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  52:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2015-12-22
  53:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Added hardware controlled IO feature.
  54:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  55:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * @endcond
  56:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  57:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  */
  58:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  59:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** /**************************************************************************************************
  60:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * HEADER FILES
  61:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  62:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  63:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** #ifndef DIGITAL_IO_H
  64:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** #define DIGITAL_IO_H
  65:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  66:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** #include <xmc_gpio.h>
  67:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** #include <DAVE_common.h>
  68:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** #include "digital_io_conf.h"
  69:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  70:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** /**************************************************************************************************
  71:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * MACROS
  72:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  73:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** #if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
  74:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****        (XMC_LIB_MINOR_VERSION >= 0U) && \
  75:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****        (XMC_LIB_PATCH_VERSION >= 0U)))
  76:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** #error "DIGITAL_IO requires XMC Peripheral Library v2.0.0 or higher"
  77:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** #endif
  78:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  79:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  /*************************************************************************************************
  80:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * ENUMS
  81:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  82:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  83:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
  84:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @ingroup DIGITAL_IO_enumerations
  85:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @{
  86:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** */
  87:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  88:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
  89:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Initialization status of DIGITAL_IO APP.
  90:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** */
  91:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** typedef enum DIGITAL_IO_STATUS
  92:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** {
  93:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****   DIGITAL_IO_STATUS_OK = 0U,/**< 0=Status OK */
  94:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****   DIGITAL_IO_STATUS_FAILURE = 1U/**< 1=Status Failed */
  95:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** } DIGITAL_IO_STATUS_t;
  96:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  97:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
  98:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @}
  99:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 100:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 101:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** /**************************************************************************************************
 102:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * DATA STRUCTURES
 103:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
 104:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 105:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @ingroup DIGITAL_IO_datastructures
 106:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @{
 107:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 108:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 109:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 110:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Initialization data structure of DIGITAL_IO APP
 111:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 112:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** typedef struct DIGITAL_IO
 113:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 114:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_GPIO_PORT_t *const gpio_port;             /**< port number */
 115:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****   const XMC_GPIO_CONFIG_t gpio_config;          /**< mode, initial output level and pad driver stre
 116:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****   const uint8_t gpio_pin;                       /**< pin number */
 117:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****   const XMC_GPIO_HWCTRL_t hwctrl;               /**< Hardware port control */
 118:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** } DIGITAL_IO_t;
 119:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 120:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 121:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 122:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @}
 123:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 124:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 125:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 126:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** /**************************************************************************************************
 127:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  * API Prototypes
 128:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
 129:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 130:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 131:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** #ifdef __cplusplus
 132:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** extern "C" {
 133:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** #endif
 134:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 135:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 136:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @ingroup DIGITAL_IO_apidoc
 137:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @{
 138:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 139:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 140:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 141:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 142:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 143:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Get DIGITAL_IO APP version
 144:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 145:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 146:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description: </b><br>
 147:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * The function can be used to check application software compatibility with a
 148:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * specific version of the APP.
 149:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 150:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 151:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 152:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 153:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include <DAVE.h>
 154:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 155:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 156:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 157:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t init_status;
 158:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_APP_VERSION_t version;
 159:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 160:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   // Initialize DIGITAL_IO APP:
 161:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   // DIGITAL_IO_Init() is called from within DAVE_Init().
 162:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   init_status = DAVE_Init();
 163:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(init_status == DAVE_STATUS_SUCCESS)
 164:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 165:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     version = DIGITAL_IO_GetAppVersion();
 166:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     if (version.major != 4U) {
 167:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     // Probably, not the right version.
 168:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 169:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 170:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 171:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     // More code here
 172:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     while(1) {
 173:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 174:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 175:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     return (1);
 176:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *  }
 177:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @endcode<BR>
 178:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 179:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 180:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** DAVE_APP_VERSION_t DIGITAL_IO_GetAppVersion(void);
 181:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 182:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 183:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 184:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to initialize the port pin as per UI settings.
 185:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 186:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return DIGITAL_IO_STATUS_t DIGITAL_IO APP status. Refer @ref DIGITAL_IO_STATUS_t structure for d
 187:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 188:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 189:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function initializes GPIO port registers IOCR,PDISC,OMR,PDR/PHCR to configure pin direction,
 190:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * and pad driver strength/hysteresis.
 191:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 192:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 193:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * None
 194:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 195:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 196:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 197:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include <DAVE.h>//Declarations from DAVE Code Generation (includes SFR declaration)
 198:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 199:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 200:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t status;
 201:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   status = DAVE_Init();  //(DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_In
 202:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(status == DAVE_STATUS_SUCCESS)
 203:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 204:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG("DAVE Apps initialization success\n");
 205:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 206:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   else
 207:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 208:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 209:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     while(1U)
 210:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     {
 211:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 212:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 213:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   //Placeholder for user application code. The while loop below can be replaced with user applica
 214:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   while(1U)
 215:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 216:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 217:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return 1U;
 218:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *  }
 219:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 220:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 221:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 222:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** DIGITAL_IO_STATUS_t DIGITAL_IO_Init(const DIGITAL_IO_t *const handler);
 223:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 224:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 225:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 226:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to set port pin high.
 227:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 228:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return None
 229:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 230:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 231:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function configures port output modification register Pn_OMR, to make port pin to high level
 232:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 233:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 234:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *  DIGITAL_IO_SetOutputLow()
 235:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 236:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 237:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 238:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include <DAVE.h>//Declarations from DAVE Code Generation (includes SFR declaration)
 239:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 240:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 241:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t status;
 242:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   status = DAVE_Init();  //(DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_In
 243:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(status == DAVE_STATUS_SUCCESS)
 244:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 245:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG("DAVE Apps initialization success\n");
 246:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 247:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   else
 248:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 249:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 250:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     while(1U)
 251:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     {
 252:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 253:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 254:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   //Placeholder for user application code. The while loop below can be replaced with user applica
 255:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_0);
 256:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   while(1U)
 257:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 258:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *     // Add application code here
 259:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 260:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 261:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return (1);
 262:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * }
 263:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 264:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 265:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 266:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** __STATIC_INLINE void DIGITAL_IO_SetOutputHigh(const DIGITAL_IO_t *const handler)
 267:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 105              	 .loc 2 267 0
 106              	 .cfi_startproc
 107 0000 80B5     	 push {r7,lr}
 108              	.LCFI6:
 109              	 .cfi_def_cfa_offset 8
 110              	 .cfi_offset 7,-8
 111              	 .cfi_offset 14,-4
 112 0002 82B0     	 sub sp,sp,#8
 113              	.LCFI7:
 114              	 .cfi_def_cfa_offset 16
 115 0004 00AF     	 add r7,sp,#0
 116              	.LCFI8:
 117              	 .cfi_def_cfa_register 7
 118 0006 7860     	 str r0,[r7,#4]
 268:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_ASSERT("DIGITAL_IO_SetOutputHigh: handler null pointer", handler != NULL);
 269:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 119              	 .loc 2 269 0
 120 0008 7B68     	 ldr r3,[r7,#4]
 121 000a 1A68     	 ldr r2,[r3]
 122 000c 7B68     	 ldr r3,[r7,#4]
 123 000e 1B7B     	 ldrb r3,[r3,#12]
 124 0010 101C     	 mov r0,r2
 125 0012 191C     	 mov r1,r3
 126 0014 FFF7FEFF 	 bl XMC_GPIO_SetOutputHigh
 270:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** }
 127              	 .loc 2 270 0
 128 0018 BD46     	 mov sp,r7
 129 001a 02B0     	 add sp,sp,#8
 130              	 
 131 001c 80BD     	 pop {r7,pc}
 132              	 .cfi_endproc
 133              	.LFE49:
 135 001e C046     	 .section .text.DIGITAL_IO_SetOutputLow,"ax",%progbits
 136              	 .align 2
 137              	 .code 16
 138              	 .thumb_func
 140              	DIGITAL_IO_SetOutputLow:
 141              	.LFB50:
 271:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 272:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 273:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to reset port pin.
 274:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 275:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return None
 276:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 277:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 278:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function configures port output modification register Pn_OMR, to make port pin to low level.
 279:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 280:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 281:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * DIGITAL_IO_SetOutputHigh()
 282:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 283:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 284:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 285:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *  #include <DAVE.h>//Declarations from DAVE Code Generation (includes SFR declaration)
 286:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *  int main(void)
 287:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *  {
 288:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *    DAVE_STATUS_t status;
 289:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *    status = DAVE_Init();  //(DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_I
 290:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *    if(status == DAVE_STATUS_SUCCESS)
 291:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *    {
 292:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *      XMC_DEBUG("DAVE Apps initialization success\n");
 293:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *    }
 294:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *    else
 295:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *    {
 296:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *      XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 297:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *      while(1U)
 298:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *      {
 299:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *      }
 300:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *    }
 301:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *    //Placeholder for user application code. The while loop below can be replaced with user applic
 302:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *    DIGITAL_IO_SetOutputLow(&DIGITAL_IO_0);
 303:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *    while(1U)
 304:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *    {
 305:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *      // Add application code here
 306:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *    }
 307:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 308:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return (1);
 309:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** * }
 310:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 311:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 312:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 313:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** __STATIC_INLINE void DIGITAL_IO_SetOutputLow(const DIGITAL_IO_t *const handler)
 314:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 142              	 .loc 2 314 0
 143              	 .cfi_startproc
 144 0000 80B5     	 push {r7,lr}
 145              	.LCFI9:
 146              	 .cfi_def_cfa_offset 8
 147              	 .cfi_offset 7,-8
 148              	 .cfi_offset 14,-4
 149 0002 82B0     	 sub sp,sp,#8
 150              	.LCFI10:
 151              	 .cfi_def_cfa_offset 16
 152 0004 00AF     	 add r7,sp,#0
 153              	.LCFI11:
 154              	 .cfi_def_cfa_register 7
 155 0006 7860     	 str r0,[r7,#4]
 315:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_ASSERT("DIGITAL_IO_SetOutputLow: handler null pointer", handler != NULL);
 316:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 156              	 .loc 2 316 0
 157 0008 7B68     	 ldr r3,[r7,#4]
 158 000a 1A68     	 ldr r2,[r3]
 159 000c 7B68     	 ldr r3,[r7,#4]
 160 000e 1B7B     	 ldrb r3,[r3,#12]
 161 0010 101C     	 mov r0,r2
 162 0012 191C     	 mov r1,r3
 163 0014 FFF7FEFF 	 bl XMC_GPIO_SetOutputLow
 317:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO\digital_io.h **** }
 164              	 .loc 2 317 0
 165 0018 BD46     	 mov sp,r7
 166 001a 02B0     	 add sp,sp,#8
 167              	 
 168 001c 80BD     	 pop {r7,pc}
 169              	 .cfi_endproc
 170              	.LFE50:
 172 001e C046     	 .section .text.XMC_VADC_GROUP_GetResult,"ax",%progbits
 173              	 .align 2
 174              	 .code 16
 175              	 .thumb_func
 177              	XMC_VADC_GROUP_GetResult:
 178              	.LFB234:
 179              	 .file 3 "C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc/xmc_vadc.h"
   1:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
   2:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @file xmc_vadc.h
   3:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @date 2016-03-09
   4:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
   5:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @cond
   6:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** ***************************************************************************************************
   7:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMClib v2.1.6 - XMC Peripheral Driver Library 
   8:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
   9:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Copyright (c) 2015-2016, Infineon Technologies AG
  10:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * All rights reserved.                        
  11:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                                             
  12:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * following conditions are met:   
  14:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                                                                              
  15:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  16:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * disclaimer.                        
  17:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * 
  18:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  19:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  20:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * 
  21:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  22:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * products derived from this software without specific prior written permission.                  
  23:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                                                                              
  24:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  31:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                                                                              
  32:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Infineon Technologies AG dave@infineon.com).                                                    
  34:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
  35:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  36:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Change History
  37:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * --------------
  38:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  39:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-02-15:
  40:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Initial <br>
  41:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *      
  42:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-02-20:
  43:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Revised for XMC1201 device.<br>
  44:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *   
  45:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-04-27:
  46:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added new APIs for SHS.<br>
  47:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added New APIs for trigger edge selection.<BR>
  48:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added new APIs for Queue flush entries, boundary selection, Boundary node pointer.<BR>
  49:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Revised GatingMode APIs and EMUX Control Init API.<BR>
  50:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  51:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-06-20:
  52:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Removed version macros and declaration of GetDriverVersion API
  53:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-06-25:
  54:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - BFL configuration in channel initialization fixed.
  55:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  56:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-07-28:
  57:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - CLOCK_GATING_SUPPORTED and PERIPHERAL_RESET_SUPPORTED macros used
  58:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Clubbed the macro definitions for XMC13 XMC12 and XMC14
  59:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Clubbed the macro definitions for XMC44 XMC47 and XMC48
  60:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - New APIs Created.
  61:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GLOBAL_SetIndividualBoundary
  62:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_SetIndividualBoundary
  63:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_GetAlias
  64:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_GetInputClass
  65:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ChannelSetIclass
  66:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ChannelGetResultAlignment
  67:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ChannelGetInputClass
  68:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_SetResultSubtractionValue
  69:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  70:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-12-01:
  71:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added:
  72:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - XMC4300 device supported
  73:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  74:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed:
  75:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - XMC_VADC_GLOBAL_TriggerEvent API updated. OR operation removed. 
  76:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - XMC_VADC_GLOBAL_ClearEvent API updated. Multiple events triggering on clearing the event i
  77:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Wrong MACRO name defined in xmc_vadc_map.h file corrected for XMC4200/4100 devices.
  78:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *       XMC_VADC_G3_SAMPLE renamed to XMC_VADC_G1_SAMPLE
  79:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  80:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-12-01:
  81:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - New APIs Created.
  82:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled
  83:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_QueueIsArbitrationSlotEnabled
  84:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed the analog calibration voltage for XMC1100 to external reference upper supply range.
  85:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed the XMC_VADC_GLOBAL_StartupCalibration() for XMC1100.
  86:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  87:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2016-03-09:
  88:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Optimization of write only registers
  89:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  90:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2016-03-18:
  91:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed XMC_VADC_GLOBAL_SHS_IsConverterReady(): API checks the STEPCFG register for the read
  92:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *       SHSCFG SFR. 
  93:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  94:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @endcond 
  95:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  96:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
  97:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
  98:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #ifndef XMC_VADC_H
  99:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_H
 100:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  
 101:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
 102:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * HEADER FILES
 103:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
 104:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #include <xmc_common.h>
 105:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #include <xmc_scu.h>
 106:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #include <xmc_vadc_map.h>
 107:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 108:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 109:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @addtogroup XMClib XMC Peripheral Library
 110:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @{
 111:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 112:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  
 113:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 114:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @addtogroup VADC
 115:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @brief Versatile Analog to Digital Converter (VADC) driver for XMC microcontroller family.
 116:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 117:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The XMC microcontroller provides a series of analog input channels connected to a cluster of Ana
 118:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Converters using the Successive Approximation Register (SAR) principle to convert analog input v
 119:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * to discrete digital values.
 120:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \if XMC1
 121:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The XMC1x is based on Sample & Hold converters, where a cluster contains 2 Sample&Hold units whi
 122:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * converter.
 123:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \endif
 124:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 125:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Each converter of the ADC cluster can operate independent of the others, controlled by a dedicat
 126:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * registers and triggered by a dedicated group request source. The results of each channel can be 
 127:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * dedicated channel-specific result register or in a group-specific result register.<BR>
 128:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 129:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The Versatile Analog to Digital Converter module (VADC) of the XMC comprises a set of converter 
 130:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * can be operated either independently or via a common request source that emulates a background c
 131:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Each converter block is equipped with a dedicated input multiplexer and dedicated request source
 132:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * which together build separate groups.
 133:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 134:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \if XMC4
 135:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @image html "vadc_overview_xmc4x.png"
 136:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \else
 137:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @image html "vadc_overview_xmc1x.png"
 138:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \endif
 139:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 140:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The VADC LLD is split into GLOBAL and GROUP related APIs.<BR>
 141:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <B>GLOBAL: </B><BR>
 142:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <UL>
 143:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Global APIs act on the entire ADC module. Configures global configuration registers</LI>
 144:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Allows configuration of the background request source of the VADC.</LI>
 145:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>The clock related configurations for the VADC module are configured in the Global APIs/</LI>
 146:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>The Global API names are prefixed by the \b XMC_VADC_GLOBAL_ and they accept ::XMC_VADC_GLOB
 147:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     one of its arguments.</LI>
 148:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configures the background request source of the VADC. The APIs which act on the background r
 149:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     are prefixed by \b XMC_VADC_GLOBAL_Background</LI>
 150:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configures the sample and hold unit of the VADC. The APIs which act on the SHS related regis
 151:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     are prefixed by \b XMC_VADC_GLOBAL_SHS_</LI>
 152:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * </UL><BR>
 153:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 154:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <B>GROUP: </B><BR>
 155:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <UL>
 156:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Group APIs act on a VADC group. Configures the group configuration registers</LI>
 157:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configures the queue request source of the VADC. The APIs which act on the queue related reg
 158:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     are prefixed by \b XMC_VADC_GROUP_Queue</LI>
 159:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configures the scan request source of the VADC. The APIs which act on the scan related regis
 160:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     are prefixed by \b XMC_VADC_GROUP_Scan</LI>
 161:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configuration of the channels of each group are done by the API which have a prefix as
 162:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     \b XMC_VADC_GROUP_Channel.</LI>
 163:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>The Group API names are prefixed by the \b XMC_VADC_GROUP_ and they accept ::XMC_VADC_GROUP_
 164:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     one of its arguments.</LI>
 165:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * </UL><BR>
 166:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @{
 167:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 168:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  
 169:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
 170:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * MACROS
 171:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
 172:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 173:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if ((UC_SERIES == XMC42)||(UC_SERIES == XMC41) || (UC_SERIES == XMC43))
 174:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE         (1U) /*  Defines the availability of group resource in a d
 175:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE         (1U) /*  Defines the availability of scan request resource
 176:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE         (1U) /*  Defines the availability of queue request resourc
 177:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE          (1U) /*  Defines the availability of external multiplexer 
 178:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 179:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE      (1U) /*  Defines the availability of boundary check suppor
 180:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS    (1U) /*  Defines the availability of synchronous request s
 181:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS      (2U) /*  Defines the maximum number of groups available in
 182:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT    (1U) /*  Defines the availability of boundary flags in a d
 183:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE       (1U) /*  Defines the external multiplexer channel selectio
 184:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 185:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE           (0U) /* Defines the availability of sample and hold module
 186:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE  (1U) /* Define the availability of a source specific resul
 187:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 188:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 189:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (UC_SERIES == XMC44 || UC_SERIES == XMC47 || UC_SERIES == XMC48)
 190:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE         (1U) /*  Defines the availability of group resource in a d
 191:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE         (1U) /*  Defines the availability of scan request resource
 192:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE         (1U) /*  Defines the availability of queue request resourc
 193:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE          (1U) /*  Defines the availability of external multiplexer 
 194:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 195:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE      (1U) /*  Defines the availability of boundary check suppor
 196:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS    (1U) /*  Defines the availability of synchronous request s
 197:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS      (4U) /*  Defines the maximum number of groups available in
 198:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT    (1U) /*  Defines the availability of boundary flags in a d
 199:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE       (1U) /*  Defines the external multiplexer channel selectio
 200:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 201:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE           (0U) /* Defines the availability of sample and hold module
 202:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE  (1U) /* Define the availability of a source specific resul
 203:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 204:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 205:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (UC_SERIES == XMC45)
 206:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE         (1U) /*  Defines the availability of group resource in a d
 207:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE         (1U) /*  Defines the availability of scan request resource
 208:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE         (1U) /*  Defines the availability of queue request resourc
 209:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE          (1U) /*  Defines the availability of external multiplexer 
 210:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 211:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE      (1U) /*  Defines the availability of boundary check suppor
 212:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS    (1U) /*  Defines the availability of synchronous request s
 213:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS      (4U) /*  Defines the maximum number of groups available in
 214:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT    (0U) /*  Defines the availability of boundary flags in a d
 215:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE       (0U) /*  Defines the external multiplexer channel selectio
 216:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 217:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE           (0U) /* Defines the availability of sample and hold module
 218:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE  (0U) /* Define the availability of a source specific resul
 219:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 220:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 221:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (UC_SERIES == XMC14 || UC_SERIES == XMC13 || UC_SERIES == XMC12)
 222:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE         (1U) /*  Defines the availability of group resource in a d
 223:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE         (1U) /*  Defines the availability of scan request resource
 224:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE         (1U) /*  Defines the availability of queue request resourc
 225:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE          (1U) /*  Defines the availability of external multiplexer 
 226:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 227:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE      (1U) /*  Defines the availability of boundary check suppor
 228:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS    (1U) /*  Defines the availability of synchronous request s
 229:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS      (2U) /*  Defines the maximum number of groups available in
 230:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT    (1U) /*  Defines the availability of boundary flags in a d
 231:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE       (1U) /*  Defines the external multiplexer channel selectio
 232:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 233:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE           (1U) /* Defines the availability of sample and hold module
 234:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE  (1U) /* Define the availability of a source specific resul
 235:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 236:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 237:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (UC_SERIES == XMC11)
 238:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE         (0U) /*  Defines the availability of group resource in a d
 239:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE         (0U) /*  Defines the availability of scan request resource
 240:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE         (0U) /*  Defines the availability of queue request resourc
 241:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE          (0U) /*  Defines the availability of external multiplexer 
 242:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 243:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE      (0U) /*  Defines the availability of boundary check suppor
 244:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS    (0U) /*  Defines the availability of synchronous request s
 245:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS      (2U) /*  Defines the maximum number of groups available in
 246:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT    (0U) /*  Defines the availability of boundary flags in a d
 247:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_START_UP_CAL_ACTIVE (3U) /*  Defines the need for SHS startup calibration acti
 248:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     XMC1100 devices */
 249:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_CONV_ENABLE_FOR_XMC11   (*(uint32_t*) 0x40010500UL) /*  Defines the additional err
 250:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     XMC1100 device for effective working*/ 
 251:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE       (0U) /*  Defines the external multiplexer channel selectio
 252:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 253:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE           (0U) /* Defines the availability of sample and hold module
 254:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE  (0U) /* Define the availability of a source specific resul
 255:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 256:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 257:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_NUM_PORTS               (16U) /* Defines the number of hardware ports that can be 
 258:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     as triggers and gating signals */
 259:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 260:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_NUM_RESULT_REGISTERS    (16U) /* Defines the number of result holding registers pe
 261:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 262:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_NUM_CHANNELS_PER_GROUP  (8U)  /**< Defines the number of ADC channels per group */
 263:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 264:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
 265:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * ENUMS
 266:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
 267:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef uint16_t XMC_VADC_RESULT_SIZE_t; /**< Type defined the converted result size to unsigned 16
 268:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef VADC_GLOBAL_TypeDef XMC_VADC_GLOBAL_t; /**< Type defined the device header file vadc global
 269:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                              type to VADC type*/
 270:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 271:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_GROUP_AVAILABLE == 1U)
 272:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef VADC_G_TypeDef XMC_VADC_GROUP_t; /**< Type defined the device header file vadc group regist
 273:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                              type to VADC Group type*/
 274:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 275:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 276:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_AVAILABLE == 1U)
 277:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef SHS_Type XMC_VADC_GLOBAL_SHS_t; /**< Type defined the sample and hold register structure*/
 278:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 279:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 280:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the return status after execution of VADC specific API's. Use @ref XMC_VADC_STATUS_t fo
 281:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 282:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_STATUS
 283:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 284:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STATUS_SUCCESS = 0,   /**< Returned when the API has been able to fulfill the callers re
 285:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STATUS_ERROR          /**< Returned when the API cannot fulfill the request */
 286:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_STATUS_t;
 287:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 288:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 289:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the various service requests lines. Each group can raise up to 4 service requests indep
 290:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  all groups together have the possibility of raising 4 module wide service requests. Use @ref XM
 291:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  enumeration.
 292:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 293:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SR
 294:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 295:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_GROUP_SR0 = 0, /**< Group specific Service Request-0 */
 296:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_GROUP_SR1,     /**< Group specific Service Request-1 */
 297:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_GROUP_SR2,     /**< Group specific Service Request-2 */
 298:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_GROUP_SR3,     /**< Group specific Service Request-3 */
 299:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_SHARED_SR0,    /**< Module Wide Common Service Request-0 */
 300:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_SHARED_SR1,    /**< Module Wide Common Service Request-1 */
 301:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_SHARED_SR2,    /**< Module Wide Common Service Request-2 */
 302:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_SHARED_SR3    /**< Module Wide Common Service Request-3 */
 303:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SR_t;
 304:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 305:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 306:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the mode of operation of a channel, when an ongoing conversion gets interrupted in betw
 307:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Use @ref XMC_VADC_STARTMODE_t for this enumeration.
 308:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 309:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_STARTMODE
 310:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 311:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STARTMODE_WFS = 0, /**< An ongoing conversion completes without interruption */
 312:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STARTMODE_CIR,     /**< An ongoing conversion can be interrupted and resumed later*/
 313:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STARTMODE_CNR     /**< An ongoing conversion can be interrupted and never resumed */
 314:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_STARTMODE_t;
 315:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 316:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 317:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the edge sensitivity of the trigger signal which can assert a conversion.
 318:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Use @ref XMC_VADC_TRIGGER_EDGE_t for this enumeration.
 319:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 320:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_TRIGGER_EDGE
 321:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 322:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_TRIGGER_EDGE_NONE = 0, /**< No external trigger. Conversion request can be asserted by s
 323:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_TRIGGER_EDGE_FALLING,  /**< The falling edge of the external trigger can assert conversi
 324:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_TRIGGER_EDGE_RISING,   /**< The rising edge of the external trigger can assert conversio
 325:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_TRIGGER_EDGE_ANY       /**< Both the edges can assert conversion request */
 326:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_TRIGGER_EDGE_t;
 327:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 328:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 329:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the external trigger input selection possibilities, to assert a conversion. Refer the V
 330:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  section of the reference manual for details of peripherals which can be used. Also refer xmc_va
 331:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  detailed definitions of the peripherals which can take the control of these enumeration items.
 332:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Use @ref XMC_VADC_TRIGGER_INPUT_SELECT_t for this enumeration.
 333:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 334:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_TRIGGER_INPUT_SELECT
 335:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 336:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_A = 0, /**< Trigger select signal A */
 337:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_B,     /**< Trigger select signal B */
 338:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_C,     /**< Trigger select signal C */
 339:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_D,     /**< Trigger select signal D */
 340:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_E,     /**< Trigger select signal E */
 341:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_F,     /**< Trigger select signal F */
 342:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_G,     /**< Trigger select signal G */
 343:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_H,     /**< Trigger select signal H */
 344:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_I,     /**< Trigger select signal I */
 345:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_J,     /**< Trigger select signal J */
 346:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_K,     /**< Trigger select signal K */
 347:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_L,     /**< Trigger select signal L */
 348:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_M,     /**< Trigger select signal M */
 349:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_N,     /**< Trigger select signal N */
 350:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_O,     /**< Trigger select signal O */
 351:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_P      /**< Trigger select signal P */
 352:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   
 353:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_TRIGGER_INPUT_SELECT_t;
 354:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 355:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 356:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the external gating input selection possibilities, to gate the conversion requests. Ref
 357:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  interconnects section of the reference manual for details of peripherals which can be used. Als
 358:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  xmc_vadc_map.h file for detailed definitions of the peripherals which can take the control of t
 359:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  items. Use @ref XMC_VADC_GATE_INPUT_SELECT_t for this enumeration.
 360:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 361:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GATE_INPUT_SELECT
 362:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 363:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_A = 0, /**< Gating select signal A */
 364:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_B,     /**< Gating select signal B */
 365:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_C,     /**< Gating select signal C */
 366:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_D,     /**< Gating select signal D */
 367:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_E,     /**< Gating select signal E */
 368:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_F,     /**< Gating select signal F */
 369:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_G,     /**< Gating select signal G */
 370:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_H,     /**< Gating select signal H */
 371:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_I,     /**< Gating select signal I */
 372:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_J,     /**< Gating select signal J */
 373:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_K,     /**< Gating select signal K */
 374:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_L,     /**< Gating select signal L */
 375:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_M,     /**< Gating select signal M */
 376:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_N,     /**< Gating select signal N */
 377:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_O,     /**< Gating select signal O */
 378:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_P      /**< Gating select signal P */
 379:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   
 380:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GATE_INPUT_SELECT_t;
 381:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 382:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 383:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the condition for gating the conversion requests. It can be used to set the ENGT field
 384:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * of ASMR/BSMR/QMR register respectively for auto_scan/background_scan/queue request sources.
 385:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Use @ref XMC_VADC_GATEMODE_t for this enumeration.
 386:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 387:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GATEMODE
 388:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 389:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GATEMODE_BLOCK = 0,  /**< External triggers are permanently blocked */
 390:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GATEMODE_IGNORE,     /**< External triggers are unconditionally passed */
 391:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GATEMODE_ACTIVEHIGH, /**< External trigger is passed only if the gate signal is high */
 392:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GATEMODE_ACTIVELOW  /**< External trigger is passed only if the gate signal is low */
 393:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GATEMODE_t;
 394:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 395:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 396:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the conversion result handling mode. Use @ref XMC_VADC_DMM_t for this enumeration.
 397:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 398:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_DMM
 399:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 400:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_DMM_REDUCTION_MODE = 0, /**< Standard Data reduction mode*/
 401:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_DMM_FILTERING_MODE,     /**< Provide option to select Finite Impulse Response Filter (FI
 402:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                         Infinite Impulse Response Filter (IIR)*/
 403:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_DMM_DIFFERENCE_MODE,    /**< Difference mode is selected*/
 404:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_DMM_t;
 405:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 406:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 407:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the conversion mode. It defines the resolution of conversion. Use XMC_VADC_CONVMODE_t f
 408:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 409:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CONVMODE
 410:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 411:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CONVMODE_12BIT       = 0,  /**< Results of conversion are 12bits wide */
 412:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CONVMODE_10BIT       = 1,  /**< Results of conversion are 10bits wide */
 413:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CONVMODE_8BIT        = 2,  /**< Results of conversion are 8bits wide */
 414:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CONVMODE_FASTCOMPARE = 5  /**< Input signal compared with a preset range */
 415:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CONVMODE_t;
 416:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 417:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 418:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the output of a fast compare mode. Use @ref XMC_VADC_FAST_COMPARE_t for
 419:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  this enumeration.
 420:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 421:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_FAST_COMPARE
 422:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 423:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_FAST_COMPARE_LOW = 0, /**< Input lower than than programmed reference */
 424:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_FAST_COMPARE_HIGH ,   /**< Input higher than than programmed reference */
 425:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_FAST_COMPARE_UNKNOWN  /**< Unknown, Conversion probably still ongoing */
 426:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_FAST_COMPARE_t;
 427:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  
 428:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 429:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the type of scan request source to be used. It can choose between auto scan and backgrou
 430:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * source methods. Use @ref XMC_VADC_SCAN_TYPE_t for this enumeration.
 431:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 432:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SCAN_TYPE
 433:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 434:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SCAN_TYPE_GROUPSCAN = 0, /**< Auto scan mode of operation selected. Also called as Group
 435:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SCAN_TYPE_BACKGROUND    /**< Background scan mode of operation selected. Also called as 
 436:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SCAN_TYPE_t;
 437:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 438:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 439:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the behavior of load event for the scan request source. Use @ref XMC_VADC_SCAN_LOAD_t fo
 440:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 441:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SCAN_LOAD
 442:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 443:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SCAN_LOAD_OVERWRITE = 0, /**< The old set of channels is discarded in favor of the new s
 444:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                          awaiting conversion */
 445:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SCAN_LOAD_COMBINE       /**< The new set of channels are combined with the pending chann
 446:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                          previous set */
 447:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SCAN_LOAD_t;
 448:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 449:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 450:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the conversion classes that can be selected for each channel. The enumeration members ho
 451:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * global classes. The conversion classes decides the properties of conversion, like resolution, sa
 452:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Use @ref XMC_VADC_CHANNEL_CONV_t for this enumeration.
 453:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 454:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 455:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_CONV
 456:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 457:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 = 0, /**< Conversion property set-0 specific to the group */
 458:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_CONV_GROUP_CLASS1,     /**< Conversion property set-1 specific to the group */
 459:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0,    /**< Conversion property set-0, Module wide */
 460:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS1    /**< Conversion property set-1, Module wide */
 461:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_CONV_t;
 462:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 463:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 464:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the references to boundary values used for limit checking feature. Each of these can be 
 465:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * either an upper bound or a lower bound. Use @ref XMC_VADC_CHANNEL_BOUNDARY_t for this enumeratio
 466:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 467:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 468:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_BOUNDARY
 469:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 470:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0 = 0, /**< Group specific Boundary-0 value */
 471:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND1,     /**< Group specific Boundary-1 value */
 472:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND0,    /**< Module wide Boundary-0 value */
 473:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND1    /**< Module wide Boundary-1 value */
 474:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_BOUNDARY_t;
 475:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 476:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 477:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the voltage which the capacitor is charged to. Used in Broken wire detection feature. Us
 478:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @ref XMC_VADC_CHANNEL_BWDCH_t for this enumeration.
 479:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 480:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_BWDCH
 481:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 482:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BWDCH_VAGND = 0, /**< Capacitor pre-charged to ground*/
 483:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BWDCH_VAREF     /**< Capacitor pre-charged to reference voltage*/
 484:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_BWDCH_t;
 485:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 486:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 487:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Defines the criteria for event generation by the channel. Use @ref XMC_VADC_CHANNEL_EVGEN_t fo
 488:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 489:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_EVGEN
 490:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 491:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_NEVER     = 0,  /**< No event generated */
 492:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_INBOUND   = 1U, /**< Event generated when the result is within the normal 
 493:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_COMPHIGH  = 1U, /**< Event generated when the result of fast compare opera
 494:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_OUTBOUND  = 2U, /**< Event generated when the result is outside the normal
 495:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_COMPLOW   = 2U, /**< Event generated when the result result of fast compar
 496:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_ALWAYS    = 3U /**< Event generated always after conversion - unconditiona
 497:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_EVGEN_t;
 498:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 499:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 500:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the reference voltage selection for conversion. Use @ref XMC_VADC_CHANNEL_REF_t for this
 501:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 502:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_REF
 503:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 504:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_REF_INTREF = 0, /**< Internal VARef */
 505:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_REF_ALT_CH0    /**< External voltage available on Channel-0 of the perticular gr
 506:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_REF_t;
 507:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  
 508:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 509:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the criteria for boundary flag assertion. Use @ref XMC_VADC_CHANNEL_BOUNDARY_CONDITION_t
 510:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * enumeration.
 511:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 512:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_BOUNDARY_CONDITION
 513:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 514:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_CONDITION_ABOVE_BAND = 0, /**< Set Boundary condition criteria to asser
 515:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_CONDITION_BELOW_BAND     /**< Set Boundary condition criteria to assert
 516:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_BOUNDARY_CONDITION_t;
 517:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  
 518:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 519:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the event which can lead to a global service request assertion. Use @ref XMC_VADC_GLOBAL
 520:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * enumeration.
 521:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 522:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GLOBAL_EVENT
 523:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 524:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_EVENT_BKGNDSOURCE = VADC_GLOBEFLAG_SEVGLB_Msk, /**< Background scan request sourc
 525:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_EVENT_RESULT      = VADC_GLOBEFLAG_REVGLB_Msk  /**< Global result event */
 526:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_EVENT_t;
 527:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  
 528:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 529:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the power modes of a VADC Group. Use @ref XMC_VADC_GROUP_POWERMODE_t for this enumeratio
 530:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 531:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_POWERMODE
 532:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 533:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_POWERMODE_OFF       = 0, /**< Group is powered down */
 534:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_POWERMODE_RESERVED1,     /**< Reserved */
 535:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_POWERMODE_RESERVED2,     /**< Reserved */
 536:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_POWERMODE_NORMAL        /**< Group is powered up */
 537:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_POWERMODE_t;
 538:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 539:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 540:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the status of a VADC group (also known as kernel). Use @ref XMC_VADC_GROUP_STATE_t for 
 541:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 542:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_STATE
 543:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 544:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_STATE_IDLE = 0, /**< Idle and can convert if requested */
 545:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_STATE_BUSY      /**< Busy with an ongoing conversion */
 546:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_STATE_t;
 547:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 548:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 549:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the reference to sample time and conversion mode settings. Use @ref XMC_VADC_GROUP_CONV
 550:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  enumeration.
 551:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 552:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_CONV
 553:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 554:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_CONV_STD = 0, /**< Settings pertaining to channels directly attached to VADC modul
 555:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_CONV_EMUX    /**< Settings pertaining to channels connected to VADC via EMUX */
 556:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_CONV_t;
 557:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 558:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 559:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the request source arbiter behavior. Use @ref XMC_VADC_GROUP_ARBMODE_t for this enumera
 560:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 561:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_ARBMODE
 562:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 563:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_ARBMODE_ALWAYS = 0, /**< Arbiter runs all the time */
 564:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_ARBMODE_ONDEMAND    /**< Arbiter runs only if a conversion request is asserted by 
 565:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                           request sources */
 566:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_ARBMODE_t;
 567:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 568:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 569:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the EMUX mode of operation. Use @ref XMC_VADC_GROUP_EMUXMODE_t for this enumeration.
 570:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 571:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_EMUXMODE
 572:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 573:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXMODE_SWCTRL = 0,     /**< Perform EMUX in Software control mode*/
 574:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXMODE_STEADYMODE,     /**< Perform EMUX in Steady mode (Use EMUX set value)*/
 575:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXMODE_SINGLEMODE,     /**< Perform EMUX in Single step mode*/
 576:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXMODE_SEQUENCEMODE,   /**< Perform EMUX in Sequence mode*/
 577:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_EMUXMODE_t;
 578:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 579:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 580:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the EMUX channel selection encoding scheme. Use @ref XMC_VADC_GROUP_EMUXCODE_t for this
 581:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 582:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_EMUXCODE
 583:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 584:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXCODE_BINARY = 0, /**< A linearly incrementing code serves are MUX-SEL */
 585:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXCODE_GRAY       /**< The MUX-SEL is gray encoded */
 586:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_EMUXCODE_t;
 587:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 588:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 589:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the service request set used. Use @ref XMC_VADC_GROUP_IRQ_t for this enumeration.
 590:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 591:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_IRQ
 592:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 593:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_IRQ_KERNEL = 0, /**< Refers to Group specific service request */
 594:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_IRQ_SHARED     /**< Refers to Module wide service request */
 595:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_IRQ_t;
 596:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 597:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 598:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the alignment of the converted result. Use @ref XMC_VADC_RESULT_ALIGN_t for this enumer
 599:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 600:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_RESULT_ALIGN
 601:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 602:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_ALIGN_LEFT = 0,  /**< Always align result to left */
 603:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_ALIGN_RIGHT      /**< Always align result to right */
 604:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_RESULT_ALIGN_t;
 605:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 606:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_RESULT_SUBTRATION 
 607:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 608:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_12BIT_LEFT_ALIGN  = 0U,  /**< Always align result to left */
 609:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_12BIT_RIGHT_ALIGN = 0U,  /**< Always align result to right */
 610:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_10BIT_LEFT_ALIGN  = 2U,  /**< Always align result to left */
 611:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_10BIT_RIGHT_ALIGN = 0U,  /**< Always align result to right */
 612:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_8BIT_LEFT_ALIGN   = 4U,  /**< Always align result to left */
 613:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_8BIT_RIGHT_ALIGN  = 0U,  /**< Always align result to right */
 614:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_RESULT_SUBTRATION_t;
 615:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 616:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 617:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the request source arbitration priority. Use @ref XMC_VADC_GROUP_RS_PRIORITY_t for this
 618:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 619:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_RS_PRIORITY
 620:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 621:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GROUP_RS_PRIORITY_0 = 0, /**< Lowest priority for the request source*/
 622:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GROUP_RS_PRIORITY_1,     /**< Second lowest priority for the request source*/
 623:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GROUP_RS_PRIORITY_2,     /**< Second highest priority for the request source*/
 624:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GROUP_RS_PRIORITY_3,     /**< Highest priority for the request source*/
 625:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }XMC_VADC_GROUP_RS_PRIORITY_t;
 626:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 627:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 628:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the various modes for the boundary flag. Use @ref XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_t f
 629:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 630:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_BOUNDARY_FLAG_MODE
 631:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 632:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_DISABLED = 0,       /**< Disable boundary flag*/
 633:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED,            /**< Always enable boundary*/
 634:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED_ACTIVE_LOW, /**< Enable boundary flag when gate level
 635:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED_ACTIVE_HIGH /**< Enable boundary flag when gate level
 636:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_t;
 637:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 638:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 639:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 640:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the boundary select for Channel. Use @ref XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_t for this 
 641:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 642:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_BOUNDARY_SELECT
 643:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 644:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_SELECT_LOWER_BOUND = 0U,       /**< Select the lower boundary*/
 645:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_SELECT_UPPER_BOUND = 2U        /**< Selects the upper boundary*/
 646:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }XMC_VADC_BOUNDARY_SELECT_t;
 647:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 648:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 649:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 650:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the group indices. Use @ref XMC_VADC_GROUP_INDEX_t for this enumeration.
 651:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 652:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_INDEX
 653:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 654:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GROUP_INDEX_0   = 0,
 655:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GROUP_INDEX_1,
 656:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_MAXIMUM_NUM_GROUPS > 2U)
 657:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GROUP_INDEX_2,
 658:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GROUP_INDEX_3
 659:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 660:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }XMC_VADC_GROUP_INDEX_t;
 661:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 662:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 663:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** * Defines channel alias.
 664:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** * All enum items are available for channels 0 and 1. Other Channels can accept only XMC_VADC_CHANNE
 665:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** */
 666:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_ALIAS
 667:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 668:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_DISABLED = -1,
 669:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH0 = 0,
 670:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH1 = 1,
 671:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH2 = 2,
 672:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH3 = 3,
 673:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH4 = 4,
 674:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH5 = 5,
 675:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH6 = 6,
 676:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH7 = 7
 677:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_ALIAS_t;
 678:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 679:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_AVAILABLE == 1U)
 680:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 681:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the gain calibration selection.
 682:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 683:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SHS_GAIN_LEVEL
 684:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 685:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_GAIN_LEVEL_0 = SHS_CALOC0_CALOFFVAL0_Pos, /**< Select the calibration value for gain
 686:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_GAIN_LEVEL_1 = SHS_CALOC0_CALOFFVAL1_Pos, /**< Select the calibration value for gain
 687:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_GAIN_LEVEL_2 = SHS_CALOC0_CALOFFVAL2_Pos, /**< Select the calibration value for gain
 688:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_GAIN_LEVEL_3 = SHS_CALOC0_CALOFFVAL3_Pos  /**< Select the calibration value for gain
 689:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }XMC_VADC_SHS_GAIN_LEVEL_t;
 690:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 691:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 692:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the Delta sigma loop.
 693:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 694:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SHS_LOOP_CH
 695:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 696:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_LOOP_CH_0 = SHS_LOOP_LPCH0_Pos, /**< Select Delta-sigma loop 0*/
 697:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_LOOP_CH_1 = SHS_LOOP_LPCH1_Pos /**< Select Delta-sigma loop 1*/
 698:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }XMC_VADC_SHS_LOOP_CH_t;
 699:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 700:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 701:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Provides the order in which the SHS should do the calibration
 702:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 703:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER
 704:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 705:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER_POST_CONV = 0, /**< Calibration occur after conversion take
 706:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER_PRE_CONV   /**< Calibration occur before conversion takes p
 707:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER_t;
 708:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 709:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 710:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
 711:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 712:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Provides possible routing values for the boundary flag.
 713:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 714:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_BOUNDARY_NODE
 715:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 716:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_BOUNDARY_FLAG_0 = 0U, /**<Route the Group boundary flag to Common b
 717:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_BOUNDARY_FLAG_1,      /**<Route the Group boundary flag to Common b
 718:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_BOUNDARY_FLAG_2,      /**<Route the Group boundary flag to Common b
 719:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_BOUNDARY_FLAG_3,      /**<Route the Group boundary flag to Common b
 720:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_SR_LINE_0,  /**<Route the Group boundary flag to Common Service Req
 721:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_SR_LINE_1,  /**<Route the Group boundary flag to Common Service Req
 722:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_SR_LINE_2,  /**<Route the Group boundary flag to Common Service Req
 723:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_SR_LINE_3   /**<Route the Group boundary flag to Common Service Req
 724:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }XMC_VADC_BOUNDARY_NODE_t;
 725:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 726:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
 727:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * DATA STRUCTURES
 728:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
 729:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /*Anonymous structure/union guard start*/
 730:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if defined(__CC_ARM)
 731:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   #pragma push
 732:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   #pragma anon_unions
 733:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #elif defined(__TASKING__)
 734:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   #pragma warning 586
 735:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 736:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 737:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 738:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure initializing the VADC scan request source. Use type @ref XMC_VADC_SCAN_CONFIG_t for t
 739:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 740:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_SCAN_CONFIG
 741:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 742:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t conv_start_mode  : 2;  /**< One converter is shared between the queue and scan request
 743:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                          group. This field determines how scan request source would
 744:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                          conversion. Uses @ref XMC_VADC_STARTMODE_t */
 745:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t req_src_priority : 2;  /**< Request source priority for the arbiter. If the Conversion
 746:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                          selected as Cancel inject repeat/Never mode then this fiel
 747:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                          priority of scan request source. Uses @ref XMC_VADC_GROUP_
 748:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
 749:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 750:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
 751:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
 752:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_GROUP_SRCREG_AVAILABLE == (1U))
 753:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t src_specific_result_reg : 4;  /**< Use any one Group related result register as 
 754:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     for all conversions results. To use the  indivi
 755:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     from each channel configuration, configure this
 756:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #else
 757:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 4;
 758:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 759:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 4;
 760:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t trigger_signal          : 4;  /**< Select one of the 16 possibilities for trigge
 761:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_TRIGGER_INPUT_SELECT_t enumeration*/
 762:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 1;
 763:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t trigger_edge            : 2;  /**< Edge selection for trigger signal. Uses @ref
 764:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_TRIGGER_EDGE_t */
 765:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 1;
 766:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t gate_signal             : 4;  /**< Select one of the 16 possibilities for gating
 767:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_GATE_INPUT_SELECT_t */
 768:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 8;
 769:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t timer_mode              : 1;  /**< Decides whether timer mode for equi-distant s
 770:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       activated or not.*/
 771:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 3;
 772:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
 773:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t asctrl;
 774:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 775:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
 776:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 777:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
 778:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
 779:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                    : 2;
 780:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t external_trigger   : 1;  /**< Conversions be initiated by external hardware trig
 781:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t req_src_interrupt  : 1;  /**< Request source event can be generated after a conv
 782:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t enable_auto_scan   : 1;  /**< Enables the continuous conversion mode. Conversion
 783:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                  of the last channel in a scan sequence will cause 
 784:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t load_mode          : 1;  /**< Selects load event mode. Uses @ref XMC_VADC_SCAN_L
 785:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                    : 26;
 786:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
 787:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t asmr;
 788:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 789:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SCAN_CONFIG_t;
 790:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 791:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 792:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef XMC_VADC_SCAN_CONFIG_t XMC_VADC_BACKGROUND_CONFIG_t; /**< Type defined the scan configurati
 793:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                                  structure for background Request S
 794:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 795:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 796:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure initializing the VADC channel. Use type XMC_VADC_CHANNEL_CONFIG_t for this enumeratio
 797:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 798:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_CHANNEL_CONFIG
 799:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 800:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
 801:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 802:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
 803:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
 804:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t input_class                : 2;  /**< Input conversion class selection.
 805:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_CONV_t */
 806:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                            : 2;
 807:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t lower_boundary_select      : 2;  /**< Which boundary register serves as lower bo
 808:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Accepts enum @ref XMC_VADC_CHANNEL_BOUNDAR
 809:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t upper_boundary_select      : 2;  /**< Which boundary register serves as upper bo
 810:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Accepts enum @ref XMC_VADC_CHANNEL_BOUNDAR
 811:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t event_gen_criteria         : 2;  /**< When should an event be generated?
 812:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_EVGEN_t */
 813:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t sync_conversion            : 1;  /**< Enables synchronous conversion for the con
 814:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t alternate_reference        : 1;  /**< Input reference voltage selection either V
 815:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_REF_t*/
 816:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                            : 4;
 817:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t result_reg_number          : 4;  /**< Group result register number */
 818:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t use_global_result          : 1;  /**< Use global result register for background 
 819:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t result_alignment           : 1;  /**< Alignment of the results read in the resul
 820:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_RESULT_ALIGN_t */
 821:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                            : 6;
 822:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t broken_wire_detect_channel : 2;  /**< Source to be used to charge the capacitor 
 823:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_BWDCH_t. */
 824:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t broken_wire_detect         : 1;  /**< Configures extra phase before the capacito
 825:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
 826:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t chctr;
 827:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 828:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
 829:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 830:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
 831:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
 832:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                           : 8;
 833:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
 834:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t flag_output_condition_ch0 : 1; /**< Condition for which the boundary flag should
 835:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                        Uses @ref XMC_VADC_CHANNEL_BOUNDARY_CONDITIO
 836:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t flag_output_condition_ch1 : 1; /**< Condition for which the boundary flag should
 837:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_BOUNDARY_CONDIT
 838:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t flag_output_condition_ch2 : 1; /**< Condition for which the boundary flag should
 839:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_BOUNDARY_CONDIT
 840:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t flag_output_condition_ch3 : 1; /**< Condition for which the boundary flag should
 841:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_BOUNDARY_CONDIT
 842:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #else
 843:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                           : 4;
 844:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 845:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                           : 4;
 846:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
 847:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t invert_boundary_flag_ch0  : 1; /**< Inverts boundary flag output.*/
 848:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t invert_boundary_flag_ch1  : 1; /**< Inverts boundary flag output.*/
 849:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t invert_boundary_flag_ch2  : 1; /**< Inverts boundary flag output.*/
 850:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t invert_boundary_flag_ch3  : 1; /**< Inverts boundary flag output.*/
 851:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 852:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #else
 853:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t boundary_flag_output_ch0  : 1; /**< Enable the boundary flag output on the speci
 854:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t boundary_flag_output_ch1  : 1; /**< Enable the boundary flag output on the speci
 855:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t boundary_flag_output_ch2  : 1; /**< Enable the boundary flag output on the speci
 856:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t boundary_flag_output_ch3  : 1; /**< Enable the boundary flag output on the speci
 857:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 858:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                           : 12;
 859:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
 860:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t bfl;
 861:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 862:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
 863:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
 864:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 865:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
 866:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
 867:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****          uint32_t boundary_flag_mode_ch0    : 4; /**< Specify the basic operation of boundary flag 
 868:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref  XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_
 869:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****          uint32_t boundary_flag_mode_ch1    : 4; /**< Specify the basic operation of boundary flag 
 870:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref  XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_
 871:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****          uint32_t boundary_flag_mode_ch2    : 4; /**< Specify the basic operation of boundary flag 
 872:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref  XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_
 873:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****          uint32_t boundary_flag_mode_ch3    : 4; /**< Specify the basic operation of boundary flag 
 874:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref  XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_
 875:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****          uint32_t                           : 16;
 876:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
 877:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t bflc;
 878:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 879:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 880:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     bool    channel_priority;  /**< Only non priority channels can be converted by Background Reque
 881:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     int8_t  alias_channel;     /**< Specifies the channel which has to be aliased with CH0/CH1 (whi
 882:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                     Force the value to \b(int8_t)-1 to bypass alias feature.
 883:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                     Uses @ref XMC_VADC_CHANNEL_ALIAS_t  for configuration.*/
 884:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_CONFIG_t;
 885:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 886:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 887:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure to initialize a queue entry. Use type @ref XMC_VADC_QUEUE_ENTRY_t.
 888:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 889:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_QUEUE_ENTRY
 890:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 891:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
 892:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 893:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
 894:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
 895:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t channel_num        : 5;  /**< Channel number associated with this queue entry.<B
 896:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t refill_needed      : 1;  /**< Conversion completed channel gets inserted back in
 897:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t generate_interrupt : 1;  /**< Generates a queue request source event */
 898:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t external_trigger   : 1;  /**< Conversion requests are raised on an external trig
 899:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                    : 24;
 900:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 901:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
 902:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t qinr0;
 903:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 904:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_QUEUE_ENTRY_t;
 905:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 906:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 907:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure initializing a VADC queue request source. Use type @ref XMC_VADC_QUEUE_CONFIG_t.
 908:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 909:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_QUEUE_CONFIG
 910:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 911:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t conv_start_mode  : 2;  /**< One converter is shared between the queue and scan request
 912:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                          group. This field determines how queue request source woul
 913:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                          conversion. Uses @ref XMC_VADC_STARTMODE_t */
 914:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t req_src_priority : 2;  /**< Request source priority for the arbiter.Uses @ref XMC_VADC
 915:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
 916:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 917:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
 918:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
 919:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_GROUP_SRCREG_AVAILABLE == (1U))
 920:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t src_specific_result_reg : 4;  /**< Uses any one Group related result register as
 921:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     for all conversions results. To use the  indivi
 922:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     from each channel configuration, configure this
 923:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #else
 924:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 4;
 925:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 926:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 4;
 927:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t trigger_signal          : 4;  /**< Select one of the 16 possibilities for trigge
 928:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_TRIGGER_INPUT_SELECT_t */
 929:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 1;
 930:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t trigger_edge            : 2;  /**< Edge selection for trigger signal.
 931:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_TRIGGER_EDGE_t */
 932:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 1;
 933:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t gate_signal             : 4;  /**< Select one of the 16 possibilities for gating
 934:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GATE_INPUT_SELECT_t */
 935:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 8;
 936:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t timer_mode              : 1;  /**< Timer mode for equi-distant sampling shall be
 937:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 3;
 938:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
 939:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t qctrl0;
 940:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 941:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
 942:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 943:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
 944:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
 945:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                   : 2;
 946:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t external_trigger  : 1;  /**< Are external triggers supported? */
 947:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                   : 29;
 948:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
 949:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t qmr0;
 950:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 951:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_QUEUE_CONFIG_t;
 952:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 953:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 954:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 955:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure to initialize the global input class configuration. Configured parameters are sample 
 956:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  conversion Mode.
 957:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 958:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_CLASS
 959:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 960:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
 961:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 962:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
 963:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
 964:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t sample_time_std_conv            : 5;  /**< Sample time for channels directly con
 965:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               <BR>Range: [0x0 to 0x1F] */
 966:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                                 : 3;
 967:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t conversion_mode_standard        : 3;  /**< Conversion mode for channels directly
 968:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               Uses @ref XMC_VADC_CONVMODE_t */
 969:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                                 : 5;
 970:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_EMUX_AVAILABLE == 1U)
 971:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t sampling_phase_emux_channel     : 5;  /**< Sample time for channels connected vi
 972:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               <BR>Range: [0x0 to 0x1F] */
 973:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                                 : 3;
 974:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t conversion_mode_emux            : 3;  /**< Conversion mode for channels connecte
 975:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               Uses @ref XMC_VADC_CONVMODE_t */
 976:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                                 : 5;
 977:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #else
 978:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                                 : 16;
 979:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 980:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
 981:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t globiclass;
 982:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 983:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_CLASS_t;
 984:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 985:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE != 0U)
 986:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 987:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Structure to initialize converter and arbiter clock configuration
 988:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 989:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_CLOCK
 990:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 991:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
 992:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 993:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
 994:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
 995:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
 996:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t analog_clock_divider     : 5;  /**< Clock for the converter. <BR>Range: [0x0 to 
 997:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                          : 2;
 998:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t msb_conversion_clock     : 1;  /**< Additional clock cycle for analog converter 
 999:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t arbiter_clock_divider    : 2;  /**< Request source arbiter clock divider. <BR>Ra
1000:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                          : 5;
1001:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                          : 17;
1002:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
1003:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t globcfg;
1004:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1005:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_CLOCK_t;
1006:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1007:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1008:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1009:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1010:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Structure to initialize the VADC Global functions
1011:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1012:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_CONFIG
1013:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1014:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
1015:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1016:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
1017:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
1018:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t boundary0  : 12;  /**< Boundary value for results comparison*/
1019:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t            : 4;
1020:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t boundary1  : 12;  /**< Boundary value for results comparison*/
1021:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t            : 4;
1022:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
1023:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t globbound;
1024:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1025:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE != 0U)
1026:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GLOBAL_CLOCK_t clock_config; /**< ADC clock configurations*/
1027:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1028:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GLOBAL_CLASS_t  class0;      /**< ADC input conversion configurations for GLOBICLASS[0
1029:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GLOBAL_CLASS_t  class1;      /**< ADC input conversion configurations for GLOBICLASS[1
1030:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
1031:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1032:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
1033:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
1034:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 16;
1035:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t data_reduction_control  : 4;  /**< Data reduction stages */
1036:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 4;
1037:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t wait_for_read_mode      : 1;  /**< Results of the next conversion will not be ov
1038:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       result register until the previous value is r
1039:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 6;
1040:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t event_gen_enable        : 1;  /**< Generates an event on availability of new res
1041:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
1042:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t globrcr;
1043:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1044:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
1045:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1046:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
1047:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
1048:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t module_disable              : 1;  /**< Disables the module clock.*/
1049:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                             : 2;
1050:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t disable_sleep_mode_control  : 1;  /**< Set it to true in order to disable the Sl
1051:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                             : 28;
1052:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
1053:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t clc;
1054:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1055:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_CONFIG_t;
1056:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1057:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1058:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1059:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure to initialize the group input class configuration. Configured parameters are sample t
1060:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  conversion Mode.
1061:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1062:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GROUP_CLASS
1063:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1064:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
1065:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1066:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
1067:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
1068:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t sample_time_std_conv            : 5;  /**< Sample time for channels directly con
1069:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               <BR>Range: [0x0 to 0x1F] */
1070:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                                 : 3;
1071:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t conversion_mode_standard        : 3;  /**< Conversion mode for channels directly
1072:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               Uses @ref XMC_VADC_CONVMODE_t */
1073:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                                 : 5;
1074:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t sampling_phase_emux_channel     : 5;  /**< Sample time for channels connected vi
1075:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               <BR>Range: [0x0 to 0x1F] */
1076:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                                 : 3;
1077:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t conversion_mode_emux            : 3;  /**< Conversion mode for channels connecte
1078:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               Uses @ref XMC_VADC_CONVMODE_t */
1079:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                                 : 5;
1080:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
1081:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t g_iclass0;
1082:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1083:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_CLASS_t;
1084:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1085:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1086:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1087:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  EMUX related configuration structure.
1088:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1089:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GROUP_EMUXCFG
1090:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1091:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
1092:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1093:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
1094:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
1095:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t starting_external_channel : 3;  /**< External channel number to which the VADC w
1096:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                         generate a control signal (needed to select
1097:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                         the analog multiplexer)*/
1098:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                           : 13;
1099:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_EMUX_CH_SEL_STYLE == 1U)
1100:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t connected_channel         : 10; /**< The Channel to which the EMUX is connected.
1101:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1102:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t connected_channel         : 5;  /**< The Channel to which the EMUX is connected.
1103:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                           : 5;
1104:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1105:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t emux_mode                 : 2;  /**< Selects the external multiplexer modes: Ste
1106:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                         Uses @ref XMC_VADC_GROUP_EMUXMODE_t*/
1107:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t emux_coding               : 1;  /**< Select Binary or Gray coding. Uses @ref XMC
1108:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t stce_usage                : 1;  /**< Use STCE for each conversion of an external
1109:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_EMUX_CH_SEL_STYLE == 1U)
1110:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t emux_channel_select_style : 1;  /**< Selects the style of configuring the \b con
1111:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                         (Each bit represents the channel or entire 
1112:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                           : 1;
1113:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1114:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                           : 2;
1115:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1116:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
1117:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t g_emuxctr;
1118:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1119:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_EMUXCFG_t;
1120:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1121:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1122:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1123:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Group Configuration Data Structures
1124:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1125:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1126:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GROUP_CONFIG
1127:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1128:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GROUP_EMUXCFG_t emux_config;    /**< External multiplexer related configurations */
1129:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GROUP_CLASS_t class0;           /**< ADC input conversion configurations for GxICLASS[
1130:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     XMC_VADC_GROUP_CLASS_t class1;           /**< ADC input conversion configurations for GxICLASS[
1131:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
1132:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1133:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
1134:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
1135:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t boundary0  : 12;  /**< Boundary value for results comparison*/
1136:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t            : 4;
1137:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t boundary1  : 12;  /**< Boundary value for results comparison*/
1138:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t            : 4;
1139:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
1140:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t g_bound;
1141:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1142:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
1143:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1144:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
1145:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
1146:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                          : 4;
1147:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t arbitration_round_length : 2;  /**< Number of arbiter slots to be considered */
1148:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                          : 1;
1149:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t arbiter_mode             : 1;  /**< Arbiter mode - Select either Continuous mode
1150:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_ARBMODE_t */
1151:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                          : 24;
1152:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
1153:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t g_arbcfg;
1154:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1155:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_CONFIG_t;
1156:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1157:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1158:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Structure to initialize VADC Group result register.
1159:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1160:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1161:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_RESULT_CONFIG
1162:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1163:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     union
1164:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1165:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        struct
1166:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        {
1167:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 16;
1168:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t data_reduction_control  : 4;  /**< Configures the data reduction stages */
1169:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t post_processing_mode    : 2;  /**< Result data processing mode. Uses @ref  XMC_V
1170:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       For normal operation select
1171:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_DMM_t::XMC_VADC_DMM_REDUCTION_MODE
1172:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       and data_reduction_control as 0*/
1173:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 2;
1174:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t wait_for_read_mode      : 1;  /**< Allow the conversion only after previous resu
1175:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t part_of_fifo            : 2;  /**< Make the result register a part of Result FIF
1176:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t                         : 4;
1177:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****           uint32_t event_gen_enable        : 1;  /**< Generates an event on availability of new res
1178:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        };
1179:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****        uint32_t g_rcr;
1180:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1181:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_RESULT_CONFIG_t;
1182:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1183:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_AVAILABLE == 1U)
1184:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1185:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Structure to initialize the Stepper configurations
1186:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1187:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_SHS_STEP_CONFIG
1188:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1189:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1190:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1191:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1192:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1193:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step0            :3;  /**< Select a Sample and hold unit for the stepper's s
1194:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1195:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step0             :1;  /**< Should the step be added to the sequence */
1196:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step1            :3;  /**< Select a Sample and hold unit for the stepper's s
1197:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1198:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step1             :1;  /**< Should the step be added to the sequence */
1199:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step2            :3;  /**< Select a Sample and hold unit for the stepper's s
1200:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1201:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step2             :1;  /**< Should the step be added to the sequence */
1202:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step3            :3;  /**< Select a Sample and hold unit for the stepper's s
1203:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1204:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step3             :1;  /**< Should the step be added to the sequence */
1205:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step4            :3;  /**< Select a Sample and hold unit for the stepper's s
1206:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1207:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step4             :1;  /**< Should the step be added to the sequence */
1208:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step5            :3;  /**< Select a Sample and hold unit for the stepper's s
1209:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1210:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step5             :1;  /**< Should the step be added to the sequence */
1211:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step6            :3;  /**< Select a Sample and hold unit for the stepper's s
1212:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1213:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step6             :1;  /**< Should the step be added to the sequence */
1214:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step7            :3;  /**< Select a Sample and hold unit for the stepper's s
1215:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1216:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step7             :1;  /**< Should the step be added to the sequence */
1217:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1218:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1219:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t stepcfg;
1220:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1221:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }XMC_VADC_GLOBAL_SHS_STEP_CONFIG_t;
1222:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1223:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1224:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Sample and hold Initialization structure
1225:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1226:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_SHS_CONFIG
1227:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1228:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1229:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1230:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1231:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1232:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t shs_clock_divider        :4; /**< The divider value for the SHS clock. Range: [0x0 t
1233:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          :6;
1234:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t analog_reference_select  :2; /**< It is possible to different reference voltage for 
1235:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                  */
1236:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          :20;
1237:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1238:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t shscfg;
1239:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1240:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1241:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER_t calibration_order; /**< order in which the calibration sh
1242:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1243:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }XMC_VADC_GLOBAL_SHS_CONFIG_t;
1244:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1245:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1246:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1247:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Detailed result structure
1248:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1249:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  typedef struct XMC_VADC_DETAILED_RESULT
1250:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1251:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1252:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1253:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1254:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1255:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t result                   :16;  /**< Result of the Analog to digital conversion*/
1256:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t data_reduction_counter   :4;   /**< Results reduction counter value*/
1257:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t channel_number           :5;   /**< Converted channel number*/
1258:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t emux_channel_number      :3;   /**< Converted external multiplexer channel number.
1259:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                  Only applicable for GxRES[0] result register*/
1260:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t converted_request_source :2;   /**< Converted request source*/
1261:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t fast_compare_result      :1;   /**< Fast compare result if conversion mode is fast c
1262:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t vaild_result             :1;   /**< Valid flag is set when a new result is available
1263:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1264:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t res;
1265:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1266:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }XMC_VADC_DETAILED_RESULT_t;
1267:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  
1268:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1269:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /*Anonymous structure/union guard end*/
1270:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if defined(__CC_ARM)
1271:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   #pragma pop
1272:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #elif defined(__TASKING__)
1273:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   #pragma warning restore
1274:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1275:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
1276:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * static inline functions
1277:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
1278:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1279:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U) 
1280:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE bool XMC_VADC_CHECK_GROUP_PTR(XMC_VADC_GROUP_t *const group_ptr)
1281:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1282:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_MAXIMUM_NUM_GROUPS == 4U)
1283:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   return((group_ptr == VADC_G0) || (group_ptr == VADC_G1) || (group_ptr == VADC_G2) || (group_ptr =
1284:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1285:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   return((group_ptr == VADC_G0) || (group_ptr == VADC_G1));
1286:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1287:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
1288:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1289:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
1290:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * API Prototypes
1291:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
1292:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1293:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #ifdef __cplusplus
1294:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** extern "C" {
1295:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1296:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1297:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1298:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param None
1299:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1300:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1301:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1302:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1303:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the VADC module.<BR>\n
1304:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would ungate the clock to the VADC module (if applicable). Also this API would bring
1305:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the VADC module out of reset state(if applicable), by asserting the appropriate registers.
1306:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would invoke XMC_SCU_CLOCK_UngatePeripheralClock() and XMC_SCU_RESET_DeassertPeripheral
1307:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * if needed. Directly accessed register is  COMPARATOR.ORCCTRL (Refer to the errata for XMC1100).
1308:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1309:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1310:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisableModule().
1311:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1312:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_EnableModule(void);
1313:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1314:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1315:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param None
1316:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1317:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1318:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1319:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1320:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the VADC module.<BR>\n
1321:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would gate the clock to the VADC module (if applicable). Also this API would put
1322:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the VADC module into the reset state(if applicable) by asserting the appropriate registers.
1323:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would invoke XMC_SCU_CLOCK_GatePeripheralClock() and XMC_SCU_RESET_AssertPeripheralRese
1324:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1325:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1326:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_EnableModule().
1327:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1328:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_DisableModule(void);
1329:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1330:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1331:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1332:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr   Constant pointer to the VADC module.
1333:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config Pointer to initialization data structure
1334:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1335:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1336:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1337:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1338:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes the VADC global module with the associated configuration structure pointed by \a con
1339:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * enables the global access to registers by configuring reset and clock un-gating for selected dev
1340:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * initializes global class, boundary , result resources by setting GLOBICLASS,GLOBBOUND,GLOBRCR re
1341:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * configures the global analog and digital clock dividers by setting GLOBCFG register. Refer relat
1342:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the configurations later in the program.
1343:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1344:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1345:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_ClockInit()<BR>
1346:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1347:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_Init(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CONFIG_t *conf
1348:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1349:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1350:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1351:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1352:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1353:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1354:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1355:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1356:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the VADC module clock.\n\n Call this API before any further configuration of VADC. It se
1357:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * register to enable.
1358:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1359:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1360:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_Init()
1361:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1362:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1363:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_EnableModuleClock(XMC_VADC_GLOBAL_t *const global_ptr)
1364:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1365:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_Enable:Wrong Module Pointer", (global_ptr == VADC))
1366:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->CLC &= ~((uint32_t)VADC_CLC_DISR_Msk);
1367:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
1368:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1369:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1370:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1371:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1372:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1373:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1374:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1375:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1376:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the VADC module clock.\n\n After this API call, no conversion will occur. Call
1377:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_EnableModuleClock() to enable the VADC module later in the program.
1378:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1379:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1380:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_Init()
1381:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1382:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1383:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_DisableModuleClock(XMC_VADC_GLOBAL_t *const global_ptr)
1384:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1385:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_Disable:Wrong Module Pointer", (global_ptr == VADC))
1386:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->CLC |= (uint32_t) ((uint32_t)1 <<  VADC_CLC_DISR_Pos);
1387:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
1388:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1389:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1390:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1391:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr    Constant pointer to the VADC module.
1392:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1393:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1394:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1395:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1396:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables VADC module to sleep if a sleep request comes.\n\n
1397:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * It resets the EDIS bit of CLC register for enabling the sleep mode.
1398:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1399:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1400:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisableSleepMode().
1401:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1402:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_EnableSleepMode(XMC_VADC_GLOBAL_t *const global_ptr)
1403:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1404:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_EnableSleepMode:Wrong Module Pointer", (global_ptr == VADC))
1405:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->CLC &= ~((uint32_t)VADC_CLC_EDIS_Msk);
1406:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
1407:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1408:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1409:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1410:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr    Constant pointer to the VADC module.
1411:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1412:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1413:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1414:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1415:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Ignores the sleep mode request for the VADC.\n\n
1416:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * With the sleep feature enabled, the module will respond to sleep
1417:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * requests by going into a low power mode. It resets the EDIS bit of CLC register for enabling the
1418:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1419:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1420:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_EnableSleepMode().
1421:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1422:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_DisableSleepMode(XMC_VADC_GLOBAL_t *const global_ptr)
1423:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1424:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_DisableSleepMode:Wrong Module Pointer", (global_ptr == VADC))
1425:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->CLC |= (uint32_t) ((uint32_t)1 <<  VADC_CLC_EDIS_Pos);
1426:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
1427:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1428:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
1429:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1430:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1431:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1432:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config  Pointer to the data structure containing clock configuration data
1433:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1434:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1435:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1436:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1437:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures the VADC clock.<BR>\n
1438:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Sets up the clock configuration of the VADC module using the config structure pointed by \a conf
1439:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The clock to the analog converter and to the request source arbiter is configured by setting the
1440:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1441:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1442:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1443:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1444:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1445:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_ClockInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_
1446:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1447:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_ClockInit:Wrong Module Pointer", (global_ptr == VADC))
1448:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1449:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   /* Write the Clock configuration into the GLOBCFG register */
1450:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBCFG = (uint32_t)(config->globcfg | (VADC_GLOBCFG_DIVWC_Msk));
1451:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
1452:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1453:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1454:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1455:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1456:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1457:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config  Conversion class parameter structure
1458:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param conv_type configure the input call for either standard conversion or EMUX related convers
1459:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param set_num Conversion class set<BR>
1460:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                Range: [0x0, 0x1]
1461:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1462:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1463:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures the ADC conversion settings like sample time and resolution.<BR>\n
1464:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Sets up the conversion settings for vadc global resource associated with \a config structure. It
1465:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * conversion class properties like sampling time and resolution for selected \a conv_type channels
1466:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the GLOBALICLASS register specified by \a set_num with the required settings.
1467:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1468:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1469:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1470:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1471:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1472:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1473:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1474:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_InputClassInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CLAS
1475:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                           const XMC_VADC_GROUP_CONV_t conv_type, const uint32_t set
1476:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1477:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1478:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1479:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC global module
1480:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config  Pointer to result configuration data structure
1481:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1482:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1483:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1484:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1485:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes global result register.<BR>\n
1486:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes Global Result Register with specified settings configured in the \a config structure
1487:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * results in configuration of GLOBRCR register. This helps in configuring the Data reduction mode,
1488:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * , wait for read mode on the GLOBRES register.
1489:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1490:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1491:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1492:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1493:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1494:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1495:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1496:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  __STATIC_INLINE void XMC_VADC_GLOBAL_ResultInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VAD
1497:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  {
1498:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_ResultInit:Wrong Module Pointer", (global_ptr == VADC))
1499:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1500:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   /* Configure GLOBRCR*/
1501:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBRCR = config->g_rcr;
1502:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  }
1503:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  
1504:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1505:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1506:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1507:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1508:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1509:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1510:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1511:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the startup calibration feature of the VADC module.\n\n It configures the SUCAL bit of G
1512:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * enable the startup calibration feature. After turning it on, it loops until all active groups fi
1513:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Call XMC_VADC_GLOBAL_Enable() and XMC_VADC_GLOBAL_ClockInit() before calling this API in sequenc
1514:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisableStartupCalibration() can disable the calibration feature at runtime.
1515:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1516:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1517:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_Enable()<BR>
1518:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_ClockInit()<BR>
1519:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1520:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1521:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_StartupCalibration(XMC_VADC_GLOBAL_t *const global_ptr);
1522:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1523:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1524:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1525:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1526:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr  Constant pointer to the VADC module.
1527:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1528:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1529:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1530:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1531:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the startup calibration feature of the VADC module.\n\n It configures the SUCAL bit of 
1532:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * disable the startup calibration feature. Calling the API XMC_VADC_GLOBAL_EnsableStartupCalibrati
1533:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * calibration feature at runtime.
1534:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1535:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1536:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1537:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1538:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1539:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_DisableStartupCalibration(XMC_VADC_GLOBAL_t *const global_ptr)
1540:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1541:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_DisableStartupCalibration:Wrong Module Pointer", (global_ptr == VADC)
1542:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBCFG &= ~((uint32_t)VADC_GLOBCFG_SUCAL_Msk);
1543:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
1544:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1545:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
1546:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1547:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1548:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module
1549:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_number  group number whose post calibration feature is to be disabled. <BR>
1550:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                      Range[0x0 to 0x3] Accepts the enum ::XMC_VADC_GROUP_INDEX_t
1551:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1552:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1553:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1554:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1555:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the post calibration for a particular group specified as \a group_number.\n\n It config
1556:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * of GLOBCFG register to disable the post calibration feature. Call XMC_VADC_GLOBAL_Enable() and
1557:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_ClockInit() before calling this API in sequence. Calling the API
1558:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_EnablePostCalibration() can enable back the calibration feature at runtime.
1559:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1560:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1561:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_Enable()<BR>
1562:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_ClockInit()<BR>
1563:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisablePostCalibration()<BR>
1564:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1565:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1566:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1567:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_DisablePostCalibration(XMC_VADC_GLOBAL_t *const global_ptr, ui
1568:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1569:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_DisablePostCalibration:Wrong Module Pointer", (global_ptr == VADC))
1570:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1571:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBCFG |= (uint32_t)((uint32_t)1 << ((uint32_t)VADC_GLOBCFG_DPCAL0_Pos + group_numbe
1572:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
1573:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1574:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1575:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1576:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module
1577:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_number  group number whose post calibration feature is to be enabled. <BR>
1578:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                      Range[0x0 to 0x3] Accepts the enum ::XMC_VADC_GROUP_INDEX_t
1579:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1580:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1581:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1582:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1583:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the post calibration for a particular group specified as \a group_number.\n\n It configu
1584:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * of GLOBCFG register to enable the post calibration feature. Calling the API XMC_VADC_GLOBAL_Disa
1585:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * can disable the calibration feature at runtime.
1586:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1587:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1588:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisablePostCalibration()<BR>
1589:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1590:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1591:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_EnablePostCalibration(XMC_VADC_GLOBAL_t *const global_ptr, uin
1592:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1593:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_EnablePostCalibration:Wrong Module Pointer", (global_ptr == VADC))
1594:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1595:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBCFG &= (~ (uint32_t)((uint32_t)1 << ((uint32_t)VADC_GLOBCFG_DPCAL0_Pos + group_nu
1596:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
1597:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1598:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1599:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_AVAILABLE == 1U)
1600:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1601:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1602:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1603:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param boundary0  Boundary-0 Value<BR>Range[0 - 4095]
1604:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param boundary1  Boundary-1 Value<BR>Range[0 - 4095]
1605:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1606:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1607:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1608:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1609:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Programs the boundaries with \a boundary0 and boundary1 for result comparison.\n\n These two bou
1610:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * absolute boundaries. They define a range against which the result of a conversion can be compare
1611:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * fast compare mode, the two boundaries provide hysteresis capability to a compare value. In any c
1612:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * values entered here form a boundary pallete. There are dedicated upper and lower boundary regist
1613:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * GLOBBOUND1 who will derive their values from this palette.
1614:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1615:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1616:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1617:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1618:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1619:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SetBoundaries(XMC_VADC_GLOBAL_t *const global_ptr, const uint32_t boundary0, c
1620:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1621:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1622:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1623:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1624:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param selection The boundary value selected for \b boundary_value.
1625:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param boundary_value  Boundary Value<BR>Range[0 - 4095]
1626:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1627:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1628:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1629:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1630:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Programs either the boundary 0 or boundary 1 for result comparison.\n\n This defines a range aga
1631:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the result of a conversion can be compared. In the fast compare mode, the two boundaries provide
1632:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * capability to a compare value.
1633:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1634:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1635:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1636:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1637:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1638:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SetIndividualBoundary(XMC_VADC_GLOBAL_t *const global_ptr,
1639:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                            const XMC_VADC_CHANNEL_BOUNDARY_t selection,
1640:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                            const uint16_t boundary_value); 
1641:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1642:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1643:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_EMUX_AVAILABLE== 1U)
1644:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1645:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1646:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr   Constant pointer to the VADC module
1647:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param emuxif       The EMUX interface<BR>Range[0x0 - 0x1]
1648:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group        The VADC group which must be bound to the desired emux
1649:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1650:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1651:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1652:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1653:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Binds a VADC \a group to an EMUX interface specified in \a emuxif.<BR>\n
1654:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Selects which group's scan request source will control the EMUX interface (set of control select
1655:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * By passing \b group it would configure that group's scan request source to control the EMUX sele
1656:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \b emuxif.
1657:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1658:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1659:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1660:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1661:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_BindGroupToEMux(XMC_VADC_GLOBAL_t *const global_ptr, const uint32_t emuxif, co
1662:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1663:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1664:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1665:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1666:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1667:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1668:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return uint32_t Complete global result register value GLOBRES
1669:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1670:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1671:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Retrieves the complete result from the global result register associated with the \a global_ptr.
1672:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the result register GLOBRES for the validity of the data. If the validity is assured, data is fi
1673:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the global result register, cached locally next and subsequently returned to the caller.
1674:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1675:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1676:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_GetResult()
1677:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1678:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE uint32_t XMC_VADC_GLOBAL_GetDetailedResult(XMC_VADC_GLOBAL_t *const global_ptr)
1679:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1680:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_GetDetailedResult:Wrong Module Pointer", (global_ptr == VADC))
1681:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1682:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  return(global_ptr->GLOBRES);
1683:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
1684:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1685:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1686:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1687:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1688:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1689:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return XMC_VADC_RESULT_SIZE_t 16 bit result register value.<BR>
1690:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *         Range[0x0 - 0X0FFF]
1691:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1692:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1693:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Retrieves the conversion result from the global result register associated with the \a global_pt
1694:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * lightweight version of XMC_VADC_GLOBAL_GetDetailedResult(). The behavior is exactly the same, ju
1695:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * only the 16 bit numeric result returned back to the application instead of the complete GLOBRES 
1696:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1697:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1698:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_GetDetailedResult()
1699:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1700:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE XMC_VADC_RESULT_SIZE_t XMC_VADC_GLOBAL_GetResult(XMC_VADC_GLOBAL_t *const global_pt
1701:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1702:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_GetResult:Wrong Module Pointer", (global_ptr == VADC))
1703:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1704:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   return ((XMC_VADC_RESULT_SIZE_t)global_ptr->GLOBRES);
1705:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
1706:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1707:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1708:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1709:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module
1710:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param compare_val Compare value which the result of a conversion will be compared against.
1711:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *         <BR>Range[0x0 - 0X0FFF]
1712:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1713:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1714:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1715:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1716:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Set compare value in the global result register for fast compare mode.\n\n The result of a conve
1717:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * be compared to the compare value entered as part of \a compare_val. The prerequisite is that the
1718:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * with this global register must select an ICLASS which has the conversion mode configured as fast
1719:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @ref XMC_VADC_GLOBAL_GetCompareResult() after this API to
1720:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1721:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1722:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1723:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1724:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SetCompareValue(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_RESULT_SIZ
1725:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1726:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1727:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1728:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module
1729:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return compare high or low. Refer @ref XMC_VADC_FAST_COMPARE_t enum
1730:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1731:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1732:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1733:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1734:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Determines the result of fast compare operation.\n\n This API returns the result of fast compare
1735:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the valid flag in the global result register GLOBRES is set.
1736:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1737:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1738:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1739:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1740:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** XMC_VADC_FAST_COMPARE_t XMC_VADC_GLOBAL_GetCompareResult(XMC_VADC_GLOBAL_t *const global_ptr);
1741:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1742:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1743:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1744:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr         Constant pointer to the VADC module
1745:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param event_type   Desired event that must be manually asserted
1746:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                    Use the enum ::XMC_VADC_GLOBAL_EVENT_t to create a mask to be used with this 
1747:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1748:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1749:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1750:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Manually asserts an event that can lead to an interrupt.\n\n This API manually asserts the reque
1751:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * (Background request source event or a global result event) by setting the GLOBEVFLAG register wi
1752:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \a event_type.
1753:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1754:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1755:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1756:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1757:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1758:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_TriggerEvent(XMC_VADC_GLOBAL_t *const global_ptr, const uint32
1759:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1760:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_TriggerEvent:Wrong Module Pointer", (global_ptr == VADC))
1761:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_TriggerEvent:Wrong Global Event", 
1762:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****             ((XMC_VADC_GLOBAL_EVENT_BKGNDSOURCE == event_type) || (XMC_VADC_GLOBAL_EVENT_RESULT == 
1763:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1764:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBEFLAG = event_type;
1765:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
1766:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1767:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1768:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1769:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module
1770:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param event_type Event that must be acknowledged
1771:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                    Use the enum ::XMC_VADC_GLOBAL_EVENT_t to create a mask to be used with this 
1772:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1773:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1774:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1775:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1776:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Acknowledges an event that has been asserted manually or automatically.\n\n This API acknowledge
1777:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * by clearing GLOBEFLAG sticky flag.
1778:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1779:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1780:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1781:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1782:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_ClearEvent(XMC_VADC_GLOBAL_t *const global_ptr, const uint32_t
1783:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1784:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_ClearEvent:Wrong Module Pointer", (global_ptr == VADC))
1785:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_ClearEvent:Wrong Global Event", 
1786:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****             ((XMC_VADC_GLOBAL_EVENT_BKGNDSOURCE == event_type) || (XMC_VADC_GLOBAL_EVENT_RESULT == 
1787:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1788:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBEFLAG = ((uint32_t)(event_type << (uint32_t)16));
1789:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
1790:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1791:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1792:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1793:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module
1794:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param sr The service request to which the global result event is connected. Refer @ref XMC_VADC
1795:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1796:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1797:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1798:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1799:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Binds the global result event to one of the 4 shared service requests.\n\n This API binds the g
1800:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  to one of the 4 module wide shared service requests .Sets GLOBEVNP register with the correspond
1801:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1802:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1803:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode()
1804:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1805:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SetResultEventInterruptNode(XMC_VADC_GLOBAL_t *const global_ptr, XMC_VADC_SR_t
1806:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1807:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1808:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1809:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module
1810:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param sr The service request to which the global request source event is connected. Refer @ref 
1811:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1812:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1813:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1814:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1815:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Binds the background request source event to one of the 4 shared service requests.\n\n This API 
1816:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * request source event to one of the 4 module wide shared service requests. Sets GLOBEVNP register
1817:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * corresponding \a sr line.
1818:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1819:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1820:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_SetResultEventInterruptNode()
1821:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1822:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode(XMC_VADC_GLOBAL_t *const global_ptr, XMC
1823:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1824:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_AVAILABLE == 1U)
1825:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1826:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param shs_ptr Constant pointer to the VADC Sample and hold module
1827:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  config Struct consisting of various SHS related configurations.
1828:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1829:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1830:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1831:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1832:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configure the basic SHS parameters.<BR>\n
1833:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * API would initialize the clock divider configuration, the analog reference selection and
1834:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the calibration order for the Sample and Hold unit.
1835:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1836:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1837:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None.
1838:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1839:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  void XMC_VADC_GLOBAL_SHS_Init(XMC_VADC_GLOBAL_SHS_t *const shs_ptr, const XMC_VADC_GLOBAL_SHS_CONF
1840:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1841:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  /**
1842:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * @param shs_ptr Constant pointer to the VADC Sample and hold module
1843:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * @param  config Struct consisting of various step configurations.
1844:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   *
1845:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * @return None
1846:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   *
1847:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * \par<b>Description:</b><br>
1848:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * Configures the stepper sequence for the converter.<BR>\n
1849:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * Stepper of the SHS can be configured to take up a specific sequence of groups for conversion.
1850:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * The stepper sequence is configured using this API.
1851:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   *
1852:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * \par<b>Related APIs:</b><BR>
1853:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * None.
1854:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   */
1855:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  __STATIC_INLINE void XMC_VADC_GLOBAL_SHS_SetStepperSequence(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
1856:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                              const XMC_VADC_GLOBAL_SHS_STEP_CONFIG_
1857:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  {
1858:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_StepperInit:Wrong SHS Pointer",
1859:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****              (shs_ptr == (XMC_VADC_GLOBAL_SHS_t*)(void*)SHS0))
1860:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_StepperInit:Wrong config pointer",
1861:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****              (config == (XMC_VADC_GLOBAL_SHS_STEP_CONFIG_t*)NULL))
1862:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1863:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   shs_ptr->STEPCFG = (uint32_t) config->stepcfg;
1864:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  }
1865:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1866:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1867:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  /**
1868:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * @param shs_ptr Constant pointer to the VADC Sample and hold module
1869:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   *
1870:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * @return bool returns true if the analog converter is operable
1871:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   *              returns false if the analog converter is powered down
1872:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   *
1873:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * \par<b>Description:</b><br>
1874:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * Returns the converter status.<BR>\n
1875:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * Returns the ANRDY bit field of the SHSCFG register.
1876:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   *
1877:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * \par<b>Related APIs:</b><BR>
1878:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * None.
1879:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   */
1880:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  __STATIC_INLINE bool XMC_VADC_GLOBAL_SHS_IsConverterReady(XMC_VADC_GLOBAL_SHS_t *const shs_ptr)
1881:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  {
1882:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_IsConverterReady:Wrong SHS Pointer",(shs_ptr == (XMC_VADC_GLOBAL_
1883:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1884:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   return((bool)((shs_ptr->SHSCFG >> (uint32_t)SHS_SHSCFG_ANRDY_Pos) & (uint32_t)0x1));
1885:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  }
1886:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1887:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1888:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1889:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param shs_ptr Constant pointer to the VADC Sample and hold module
1890:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_num group number for which the accelerated mode needs to be enabled.<BR>Range: [0x0
1891:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1892:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1893:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1894:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1895:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the Accelerated timing mode.<BR>\n
1896:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API is needed when a switch from compatible mode to accelerated mode of conversion is neede
1897:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * this mode the ADC module will convert the input depending on the value stored in the SST bit of 
1898:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would configure the accelerated mode in the SHS0_TIMCFG0 and SHS0_TIMCFG1 registers.
1899:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1900:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1901:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None.
1902:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1903:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SHS_EnableAcceleratedMode(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,XMC_VADC_GROUP_
1904:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1905:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1906:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param shs_ptr Constant pointer to the VADC Sample and hold module
1907:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_num group number for which the accelerated mode needs to be disabled.<BR>Range: [0x
1908:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1909:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1910:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1911:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1912:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the Accelerated timing mode.<BR>\n
1913:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API is needed when a switch from accelerated mode to compatible mode of conversion is neede
1914:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would clear the accelerated mode in the SHS0_TIMCFG0 and SHS0_TIMCFG1 registers.
1915:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1916:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1917:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None.
1918:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1919:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SHS_DisableAcceleratedMode(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,XMC_VADC_GROUP
1920:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1921:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1922:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param shs_ptr Constant pointer to the VADC Sample and hold module
1923:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_num group number for which the accelerated mode needs to be enabled.<BR>Range: [0x0
1924:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param sst_value Value of short sample time that needs to be configured.<BR>
1925:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                  Range: [0x0 to 0x3F]
1926:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1927:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1928:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1929:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1930:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures the Accelerated timing mode sample time.<BR>\n
1931:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API is needed when a switch from compatible mode to accelerated mode of conversion is neede
1932:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Accelerated mode the ADC module will convert the input depending on the value stored in the SST 
1933:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  SHS0_TIMCFGx. This API would configure the shot sample time either in SHS0_TIMCFG0.SST or SHS0_
1934:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1935:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1936:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None.
1937:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1938:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SHS_SetShortSampleTime(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
1939:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                             XMC_VADC_GROUP_INDEX_t group_num,
1940:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                             uint8_t sst_value);
1941:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1942:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1943:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1944:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param shs_ptr Constant pointer to the VADC Sample and hold module
1945:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  divs_value The clock divider value that is possible
1946:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                    <BR>Range:[0x0 to 0xF]
1947:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1948:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1949:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1950:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configure Sample and hold clock divider value.<BR>\n
1951:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * API would initialize the clock divider configuration. This determines the frequency of conversio
1952:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * of the Sample and hold converter.
1953:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1954:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1955:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None.
1956:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1957:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_SHS_SetClockDivider(XMC_VADC_GLOBAL_SHS_t *const shs_ptr, uint
1958:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
1959:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_SetClockDivider:Wrong SHS Pointer",
1960:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****              (shs_ptr == (XMC_VADC_GLOBAL_SHS_t*)(void*)SHS0))
1961:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_SetClockDivider:Wrong divide factor selected",
1962:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****              (divs_value < (uint32_t)0x10))
1963:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1964:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   shs_ptr->SHSCFG =  (shs_ptr->SHSCFG & (~(uint32_t)SHS_SHSCFG_DIVS_Msk)) | (uint32_t)SHS_SHSCFG_SC
1965:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   shs_ptr->SHSCFG |=  ((uint32_t)divs_value << SHS_SHSCFG_DIVS_Pos) | (uint32_t)SHS_SHSCFG_SCWC_Msk
1966:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
1967:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1968:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1969:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param shs_ptr Constant pointer to the VADC Sample and hold module
1970:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  gain_value gain value possible
1971:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                    Range:[0x0 to 0x3]
1972:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  group_num The Group number for which the configurations applies
1973:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  ch_num The channel number for which the gain has to be configured
1974:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1975:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1976:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1977:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configure the gain value for SHS.<BR>\n
1978:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * API would set the gain factor for a selected channel.
1979:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1980:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1981:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None.
1982:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1983:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SHS_SetGainFactor(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
1984:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                        uint8_t gain_value,
1985:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                        XMC_VADC_GROUP_INDEX_t group_num,
1986:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                        uint8_t ch_num);
1987:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1988:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
1989:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1990:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param shs_ptr Constant pointer to the VADC Sample and hold module
1991:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  max_calibration_time calibration time
1992:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                              Range:[0x0 to 0x3F]
1993:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1994:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1995:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1996:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configure the Maximum calibration timing.<BR>\n
1997:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * API would initialize the Maximum time after which the calibration should occur. If no adc conver
1998:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * occur during this duration then the calibration would run irrespective of conversions. The max t
1999:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * converter can go without a calibration is set in this API.
2000:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2001:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2002:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None.
2003:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2004:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_SHS_SetMaxCalTime(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
2005:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                        uint32_t max_calibration_time)
2006:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2007:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_SetMaxCalTime:Wrong SHS Pointer",
2008:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****              (shs_ptr == (XMC_VADC_GLOBAL_SHS_t*)(void*)SHS0))
2009:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2010:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   shs_ptr->CALCTR &= ~((uint32_t)SHS_CALCTR_CALMAX_Msk);
2011:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   shs_ptr->CALCTR |=  ((uint32_t)max_calibration_time << SHS_CALCTR_CALMAX_Pos);
2012:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2013:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2014:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2015:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2016:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param shs_ptr Constant pointer to the VADC Sample and hold module
2017:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  group_num The Group number for which the configurations applies
2018:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2019:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2020:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2021:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enable the Gain and offset calibration.<BR>\n
2022:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enable the gain and offset calibration for all the Sample and hold units.
2023:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2024:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2025:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_SHS_DisableGainAndOffsetCalibrations()<BR>.
2026:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2027:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SHS_EnableGainAndOffsetCalibrations(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
2028:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          XMC_VADC_GROUP_INDEX_t group_num);
2029:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2030:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2031:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param shs_ptr Constant pointer to the VADC Sample and hold module
2032:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  group_num The Group number for which the configurations applies
2033:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2034:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2035:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2036:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disable the Gain and offset calibration.<BR>\n
2037:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disable the gain and offset calibration for all the Sample and hold units.
2038:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2039:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2040:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_SHS_EnableGainAndOffsetCalibrations()<BR>.
2041:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2042:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SHS_DisableGainAndOffsetCalibrations(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
2043:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                           XMC_VADC_GROUP_INDEX_t group_num);
2044:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2045:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2046:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param shs_ptr Constant pointer to the VADC Sample and hold module
2047:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  group_num The Group number for which the configurations applies
2048:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  gain_level The gain level whose calibration value has to read.
2049:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2050:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2051:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2052:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Read the calibration value for the selected gain level.<BR>\n
2053:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Each gain value has a offset calibration value, this API would return the offset calibration val
2054:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * selected gain level. This is applicable for all the channels in the group that use the particula
2055:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2056:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2057:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_SHS_SetOffsetCalibrationValue()<BR>.
2058:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2059:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** uint8_t XMC_VADC_GLOBAL_SHS_GetOffsetCalibrationValue(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
2060:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_GROUP_INDEX_t group_num,
2061:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_SHS_GAIN_LEVEL_t gain_level);
2062:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2063:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2064:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param shs_ptr Constant pointer to the VADC Sample and hold module
2065:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  group_num The Group number for which the configurations applies
2066:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  gain_level The gain level whose calibration value has to read.
2067:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  offset_calibration_value The offset calibration value to be set.
2068:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2069:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2070:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2071:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Set the calibration value for the selected gain level.<BR>\n
2072:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Each gain value has a offset calibration value, this API would set the offset value of the selec
2073:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2074:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2075:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_SHS_GetOffsetCalibrationValue()<BR>.
2076:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2077:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SHS_SetOffsetCalibrationValue(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
2078:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                    XMC_VADC_GROUP_INDEX_t group_num,
2079:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                    XMC_VADC_SHS_GAIN_LEVEL_t gain_level,
2080:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                    uint8_t offset_calibration_value);
2081:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2082:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2083:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param shs_ptr Constant pointer to the VADC Sample and hold module
2084:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  group_num The Group number for which the configurations applies
2085:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  loop_select The delta sigma loop number for which the configurations applies
2086:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  ch_num Channel number for which the configurations applies
2087:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2088:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2089:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2090:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures the delta sigma loop of the SHS.<BR>\n
2091:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * There are 2 Delta-Sigma loops that can be configured. This API would configure the loop (loop_se
2092:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * with the appropriate group_num and channel_num.
2093:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures the SHS_LOOP bit fields.
2094:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2095:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2096:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_SHS_EnableSigmaDeltaLoop()<BR>.
2097:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2098:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SHS_SetSigmaDeltaLoop(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
2099:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                            XMC_VADC_GROUP_INDEX_t group_num,
2100:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                            XMC_VADC_SHS_LOOP_CH_t loop_select,
2101:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                            uint8_t ch_num);
2102:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2103:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2104:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param shs_ptr Constant pointer to the VADC Sample and hold module
2105:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  loop_select The delta sigma loop number for which the configurations applies
2106:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2107:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2108:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2109:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enable the selected Delta-Sigma loop.<BR>\n
2110:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures the SHS_LOOP.LPENx bit field.
2111:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2112:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2113:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_SHS_SetSigmaDeltaLoop()<BR>.
2114:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_SHS_EnableGainAndOffsetCalibrations()<BR>.
2115:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2116:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_SHS_EnableSigmaDeltaLoop(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
2117:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               XMC_VADC_SHS_LOOP_CH_t loop_select)
2118:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2119:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_EnableSigmaDeltaLoop:Wrong SHS Pointer",
2120:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****              (shs_ptr == (XMC_VADC_GLOBAL_SHS_t*)(void*)SHS0))
2121:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_EnableSigmaDeltaLoop:Wrong Delta sigma loop selected",
2122:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****              (loop_select == XMC_VADC_SHS_LOOP_CH_0)||(loop_select == XMC_VADC_SHS_LOOP_CH_1))
2123:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2124:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   shs_ptr->LOOP |= (uint32_t)SHS_LOOP_LPEN0_Msk << (uint32_t)loop_select;
2125:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2126:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2127:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2128:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param shs_ptr Constant pointer to the VADC Sample and hold module
2129:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  loop_select The delta sigma loop number for which the configurations applies
2130:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2131:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2132:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2133:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disable the selected delta sigma loop.<BR>\n
2134:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures the SHS_LOOP.LPENx bit field.
2135:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2136:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2137:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_SHS_SetSigmaDeltaLoop()<BR>.
2138:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_SHS_EnableGainAndOffsetCalibrations()<BR>.
2139:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2140:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_SHS_DisableSigmaDeltaLoop(XMC_VADC_GLOBAL_SHS_t *const shs_ptr
2141:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                                XMC_VADC_SHS_LOOP_CH_t loop_select)
2142:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2143:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_DisableSigmaDeltaLoop:Wrong SHS Pointer",
2144:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****              (shs_ptr == (XMC_VADC_GLOBAL_SHS_t*)(void*)SHS0))
2145:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_DisableSigmaDeltaLoop:Wrong Delta sigma loop selected",
2146:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****              (loop_select == XMC_VADC_SHS_LOOP_CH_0)||(loop_select == XMC_VADC_SHS_LOOP_CH_1))
2147:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2148:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   shs_ptr->LOOP &= ~((uint32_t)SHS_LOOP_LPEN0_Msk << (uint32_t)loop_select);
2149:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2150:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2151:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2152:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
2153:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
2154:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2155:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2156:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr   Constant pointer to the VADC group.
2157:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config Pointer to the initialization data structure
2158:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2159:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2160:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2161:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2162:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes the VADC group module with the associated configuration structure pointed by \a conf
2163:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * initializes the group specified as part of the \a group_ptr. It initializes group conversion cla
2164:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * configuration , boundary configuration by setting GxICLASS,GxARBCFG,GxBOUND, registers. It also
2165:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * configures the EMUX control register if applicable. Refer related API's to change the configurat
2166:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  program.
2167:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2168:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2169:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_InputClassInit()<BR>
2170:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_SetPowerMode()<BR>
2171:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_SetBoundaries()<BR>
2172:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ExternalMuxControlInit()<BR>
2173:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2174:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_Init(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CONFIG_t *config);
2175:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2176:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2177:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2178:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr Constant pointer to the VADC group.
2179:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config  group related conversion class parameter structure
2180:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param conv_type Use direct channels or EMUX channels. Refer @ref XMC_VADC_GROUP_CONV_t enum
2181:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param set_num Conversion class set<BR>
2182:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                Range[0x0, 0x1]
2183:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2184:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2185:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2186:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2187:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Sets up the conversion settings for vadc group resource associated with \a config structure. It 
2188:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * conversion class properties like sampling time and resolution for selected \a conv_type channels
2189:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the G_ICLASS register specified by \a set_num with the required settings.
2190:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2191:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2192:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2193:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_Init()
2194:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2195:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2196:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_InputClassInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CLASS_t 
2197:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                    const XMC_VADC_GROUP_CONV_t conv_type, const uint32_t set_num);
2198:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2199:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2200:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2201:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr Constant pointer to the VADC Group which must be set as a slave
2202:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param master_grp The master group number<BR>
2203:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   Range: [0x0 - 0x3]
2204:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param slave_group The slave group number<BR>
2205:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   Range: [0x0 - 0x3]
2206:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2207:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2208:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2209:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2210:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures a VADC Group as a slave group.\n\n Conversion of identically numbered channels across
2211:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * synchronized. For example, when the trigger to convert CH-1 of Group-2 is received, it is possib
2212:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * simultaneously request conversion of CH-1 of Group-0 and Group-3. Group-2 in this example is the
2213:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * master group while Groups-0 and 3 are the slave groups. It uses the SYNCCTR register for the con
2214:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2215:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2216:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_SetSyncMaster()<BR>
2217:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_CheckSlaveReadiness()<BR>
2218:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_EnableChannelSyncRequest()<BR>
2219:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2220:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2221:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_SetSyncSlave(XMC_VADC_GROUP_t *const group_ptr, uint32_t master_grp, uint32_t s
2222:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2223:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2224:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2225:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr  Constant pointer to the VADC Group.
2226:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param power_mode  Desired power mode
2227:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2228:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2229:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2230:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2231:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures the power mode of a VADC group.\n\n For a VADC group to actually convert an analog si
2232:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * converter must be turned on.
2233:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2234:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2235:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
2236:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2237:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_SetPowerMode(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_POWERMODE_
2238:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2239:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2240:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2241:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group.
2242:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2243:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2244:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2245:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2246:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures a VADC Group as a master group.<BR>\n
2247:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Conversion of identically numbered channels across groups can be
2248:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * synchronized. For example, when the trigger to convert CH-1 of Group-2 is received, it is possib
2249:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * request conversion of CH-1 of Group-0 and Group-3. Group-2 in this example is therefore the mast
2250:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Groups-0 and 3 are the slave groups.
2251:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2252:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2253:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
2254:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2255:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_SetSyncMaster(XMC_VADC_GROUP_t *const group_ptr);
2256:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2257:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2258:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2259:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr       Pointer to the master VADC Group
2260:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param slave_group  The slave VADC Group number
2261:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                     <BR>Range: [0x0 to 0x3]
2262:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2263:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2264:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2265:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures the ready signal for master group.<BR>\n
2266:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would read the \b slave_group number and determine which EVAL configuration to apply fo
2267:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * slave set. Checks the readiness of slaves in synchronized conversions. Conversion of identically
2268:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * across groups can be synchronized. For example, when the trigger to convert CH-1 of Group-2 is r
2269:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * possible to simultaneously request conversion of CH-1 of Group-0 and Group-3. Group-2 in this ex
2270:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * therefore the master group while Groups-0 and 3 are the slave groups. Before the master can requ
2271:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * for synchronized conversion, it has the option of checking the readiness of the slaves.
2272:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2273:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2274:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_IgnoreSlaveReadiness()<BR> XMC_VADC_GROUP_SetSyncMaster()
2275:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2276:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_CheckSlaveReadiness(XMC_VADC_GROUP_t *const group_ptr, uint32_t slave_group);
2277:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2278:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2279:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2280:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr  Constant Pointer to the master VADC Group
2281:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param slave_group  The slave VADC Group number
2282:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2283:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2284:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2285:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Clears the ready signal for master group.<BR>\n
2286:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Ignores the readiness of slaves in synchronized conversions.This API would read the \b slave_gro
2287:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * determine which EVAL configuration to apply for the given master slave set. Then clears the conf
2288:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API is called when the master should issue the conversion request without waiting for the s
2289:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * assert a ready signal. The ready signal is asserted by the slave group(s) when the conversion is
2290:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * in these channels.
2291:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2292:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2293:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_CheckSlaveReadiness()<BR> XMC_VADC_GROUP_SetSyncMaster()<BR>
2294:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2295:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_IgnoreSlaveReadiness(XMC_VADC_GROUP_t *const group_ptr, uint32_t slave_group);
2296:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2297:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2298:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2299:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr   Constant pointer to the master VADC Group
2300:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num  Channel whose conversion triggers conversion in slave groups
2301:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2302:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2303:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2304:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Sets up a channel for synchronized conversion.\n\n Conversion of identically numbered channels a
2305:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * can be synchronized. For example, when the trigger to
2306:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * convert CH-1 of Group-2 is received, it is possible to simultaneously request conversion of CH-1
2307:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Group-3. Group-2 in this example is therefore the master group while Groups-0 and 3 are the slav
2308:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Before the master can request its slaves for synchronized conversion, it has the option of check
2309:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * of the slaves.
2310:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2311:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2312:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
2313:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2314:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_EnableChannelSyncRequest(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_n
2315:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2316:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2317:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2318:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr       Pointer to the master VADC Group
2319:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num     Channel whose conversion triggers conversion in slave groups
2320:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2321:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2322:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2323:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disable the synchronization request for the particular channel specified as ch_num. To enable th
2324:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * call the API @ref XMC_VADC_GROUP_EnableChannelSyncRequest().
2325:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2326:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2327:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
2328:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2329:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_DisableChannelSyncRequest(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_
2330:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2331:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2332:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2333:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group.
2334:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2335:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return retuns IDLE if converter is free else returns busy. Refer @ref XMC_VADC_GROUP_STATE_t en
2336:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2337:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2338:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Checks the live status of the analog to digital converter. The converter can either idle doing n
2339:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * sampling + converting.
2340:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2341:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2342:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
2343:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2344:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** XMC_VADC_GROUP_STATE_t XMC_VADC_GROUP_IsConverterBusy(XMC_VADC_GROUP_t *const group_ptr);
2345:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2346:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2347:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2348:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr Constant pointer to the VADC group whose global boundary registers are to be pr
2349:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param boundary0  Boundary-0 Value<BR>
2350:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   Range: [0x0 - 0x0FFF]
2351:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param boundary1  Boundary-1 Value<BR>
2352:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   Range: [0x0 - 0x0FFF]
2353:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2354:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2355:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2356:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2357:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Programs the boundaries with \a boundary0 and boundary1 for result comparison.\n\n These two bou
2358:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * absolute boundaries. They defines a range against which the result of a conversion can be compar
2359:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * fast compare mode, the two boundaries provide hysteresis capability to a compare value. In any c
2360:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * values entered here form a boundary pallete. There are dedicated upper and lower boundary regist
2361:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * G_BOUND1 who will derive their values from this palette.
2362:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2363:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2364:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
2365:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2366:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2367:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_SetBoundaries(XMC_VADC_GROUP_t *const group_ptr, 
2368:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                   const uint32_t boundary0, 
2369:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                   const uint32_t boundary1);
2370:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2371:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2372:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2373:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param selection The boundary value selected for \b boundary_value.
2374:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param boundary_value Select the boundary value.
2375:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2376:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2377:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2378:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2379:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Programs the boundary with \a boundary_value for result comparison.\n\n This defines a range aga
2380:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the result of a conversion can be compared. In the fast compare mode, the two boundaries provide
2381:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * capability to a compare value.
2382:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2383:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2384:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None.
2385:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2386:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_SetIndividualBoundary(XMC_VADC_GROUP_t *const group_ptr,
2387:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                           const XMC_VADC_CHANNEL_BOUNDARY_t selection,
2388:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                           const uint16_t boundary_value); 
2389:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2390:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2391:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2392:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param sr_num   The service request number (0 through 3)
2393:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param type     IRQ type (Kernel specific interrupt vs Module wide shared interrupt )
2394:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2395:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2396:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2397:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Activates a Service Request line(manually trigger).<BR>\n
2398:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * VADC provides few SR lines for each group and a few more which is shared across all the groups.
2399:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * These SR lines can be connected to an NVIC node which in-turn would generate an interrupt.
2400:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would manually trigger the given SR line. Could be used for evaluation and testing purp
2401:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2402:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2403:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
2404:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2405:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_TriggerServiceRequest(XMC_VADC_GROUP_t *const group_ptr, 
2406:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                           const uint32_t sr_num, 
2407:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                           const XMC_VADC_GROUP_IRQ_t type);
2408:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2409:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2410:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2411:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr  Constant pointer to the VADC group
2412:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param emux_cfg   EMUX configuration structure
2413:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2414:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2415:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2416:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures group EMUX parameters associated with the \a emux_cfg configuration structure.\n\n An
2417:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * interface allows additional channels to be connected to a VADC group. The conversion properties
2418:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * of such channels can be different from the standard channels which are directly connected to the
2419:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API configures conversion properties of channels connected via EMUX interface.
2420:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2421:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2422:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
2423:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2424:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_ExternalMuxControlInit(XMC_VADC_GROUP_t *const group_ptr,
2425:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                            const XMC_VADC_GROUP_EMUXCFG_t emux_cfg)
2426:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2427:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   uint32_t   emux_config;
2428:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2429:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ExternalMuxControlInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(
2430:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2431:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_P
2432:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****               ((uint32_t)emux_cfg.connected_channel << (uint32_t)VADC_G_EMUXCTR_EMUXCH_Pos);
2433:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2434:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->EMUXCTR  = emux_config;
2435:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   emux_config = ((uint32_t)emux_cfg.emux_coding << (uint32_t)VADC_G_EMUXCTR_EMXCOD_Pos)  |
2436:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                 ((uint32_t)emux_cfg.emux_mode  << (uint32_t)VADC_G_EMUXCTR_EMUXMODE_Pos)|
2437:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                 ((uint32_t)emux_cfg.stce_usage << (uint32_t)VADC_G_EMUXCTR_EMXST_Pos);
2438:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2439:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_EMUX_CH_SEL_STYLE == 1U)
2440:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   emux_config |= ((uint32_t)emux_cfg.emux_channel_select_style << (uint32_t)VADC_G_EMUXCTR_EMXCSS_P
2441:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
2442:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->EMUXCTR  |= (emux_config | ((uint32_t)VADC_G_EMUXCTR_EMXWC_Msk)) ;
2443:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2444:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2445:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if XMC_VADC_BOUNDARY_FLAG_SELECT == 1U
2446:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2447:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2448:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr Constant pointer to the VADC group
2449:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param boundary_flag_num The Boundary flag for which the interrupt node needs to be configured.
2450:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                          Range: [0x0 to 0x3]
2451:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param node    Service Request node Id
2452:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2453:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2454:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2455:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2456:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Connects the boundary event to the SR line of VADC or to a common boundary flag.<BR>\n
2457:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will connect a Service Request line(SR) to a boundary event. Hence to get a interrupt o
2458:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Service request line one has to enable the required NVIC node.  A call to this API would configu
2459:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * field GxBFLNP.BFLxNP.
2460:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2461:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2462:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  None.
2463:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2464:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_SetBoundaryEventInterruptNode(XMC_VADC_GROUP_t *const group_ptr,
2465:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                   const uint8_t boundary_flag_num,
2466:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                   const XMC_VADC_BOUNDARY_NODE_t node);
2467:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif /* XMC_VADC_BOUNDARY_FLAG_SELECT */
2468:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2469:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2470:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr Constant pointer to the VADC group
2471:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2472:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    uint32_t The complete GxALIAS register
2473:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2474:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2475:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Returns the ALIAS values.\n The ALIAS value that is configured for Channel-0 and channel-1 are r
2476:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2477:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2478:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  None.
2479:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2480:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE uint32_t XMC_VADC_GROUP_GetAlias(XMC_VADC_GROUP_t *const group_ptr)
2481:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2482:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_GetAliasWrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
2483:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   return (group_ptr->ALIAS);
2484:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2485:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2486:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2487:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr Constant pointer to the VADC group
2488:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param conv_class  conversion property to be extracted
2489:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2490:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    XMC_VADC_GROUP_CLASS_t The complete GxICLASSy register
2491:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2492:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2493:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Returns the input class configuration values.\n
2494:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This returns the sampling time configuration and resolution configured in the appropriate group 
2495:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \b conv_class. A call to this API would return the register GxICLASSy.
2496:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2497:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2498:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  None.
2499:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2500:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE XMC_VADC_GROUP_CLASS_t XMC_VADC_GROUP_GetInputClass(XMC_VADC_GROUP_t *const group_p
2501:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                                     const XMC_VADC_CHANNEL_CONV_t c
2502:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2503:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_CLASS_t input_value;
2504:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr
2505:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong conv_class selected", 
2506:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****              (XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLA
2507:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2508:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   input_value.g_iclass0 = (uint32_t) 0xFFFFFFFF;
2509:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   if ((XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLASS1 == 
2510:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   {
2511:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     input_value.g_iclass0 = group_ptr->ICLASS[(uint32_t)conv_class];
2512:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   }
2513:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2514:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   return (input_value);
2515:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2516:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif /* XMC_VADC_GROUP_AVAILABLE */
2517:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2518:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GSCAN_AVAILABLE == 1U)
2519:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2520:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr Pointer to the VADC group
2521:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config     Pointer to Scan configuration
2522:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
2523:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2524:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2525:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes the VADC SCAN functional block.<BR>\n
2526:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The GROUP SCAN request source functional block converts channels sequentially starting with the 
2527:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * channel to the lowest. Channels must register themselves as being part of the the scan sequence.
2528:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API will first disable the arbitration slot for queue (XMC_VADC_GROUP_ScanEnableA
2529:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * and then it would configure all the related registers with the required configuration values.
2530:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The arbitration slot is re-enabled at the end of init by invoking XMC_VADC_GROUP_ScanDisableArbi
2531:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the registers GxARBPR, GxASCTRL, GxASMR needed scan request s
2532:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2533:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2534:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ScanEnableArbitrationSlot()<BR> XMC_VADC_GROUP_ScanDisableArbitrationSlot()<BR>
2535:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ScanSelectTrigger()<BR> XMC_VADC_GROUP_ScanSelectGating()<BR>
2536:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2537:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_ScanInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_SCAN_CONFIG_t *confi
2538:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2539:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2540:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2541:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2542:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2543:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2544:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2545:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables arbitration slot of the scan request source.<BR>\n
2546:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * If the scan request source must have its conversion request considered by the arbiter, it must p
2547:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the arbitration rounds. Even if a load event occurs the scan channel can only be converted when 
2548:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * to the scan slot. Thus this must be enabled if any conversion need to take place.
2549:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxARBPR.ASEN1.
2550:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2551:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2552:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ScanDisableArbitrationSlot()<BR>
2553:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2554:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_ScanEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
2555:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2556:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ScanEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_P
2557:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->ARBPR |= (uint32_t)VADC_G_ARBPR_ASEN1_Msk;
2558:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2559:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2560:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2561:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2562:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2563:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2564:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2565:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2566:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables arbitration slot of the scan request source.<BR>\n
2567:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * If the scan request source must have its conversion request considered by the arbiter, it must p
2568:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the arbitration rounds. Even if a load event occurs the scan channel can only be converted when 
2569:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * to the scan slot.A call to this API will lead to all conversions request by scan to be blocked.
2570:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxARBPR.ASEN1.
2571:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2572:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2573:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ScanEnableArbitrationSlot()<BR>
2574:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2575:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_ScanDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
2576:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2577:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ScanDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_
2578:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN1_Msk);
2579:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2580:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2581:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2582:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2583:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2584:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    bool  returns true if the arbitration is enabled else returns false.
2585:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2586:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2587:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Returns the arbitration status of the scan request source.<BR>\n
2588:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * If the scan request source must have its conversion request considered by the arbiter, it must p
2589:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the arbitration rounds. Even if a load event occurs the scan channel can only be converted when 
2590:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * to the scan slot. A call to this API would return the status of the arbitration slot of scan.
2591:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would read the register bit field GxARBPR.ASEN1.
2592:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2593:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2594:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ScanEnableArbitrationSlot(),<BR>  XMC_VADC_GROUP_ScanDisableArbitrationSlot()<BR
2595:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2596:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE bool XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled(XMC_VADC_GROUP_t *const group_ptr)
2597:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2598:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled:Wrong Group Pointer", XMC_VADC_CHECK_GROU
2599:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2600:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   return ((group_ptr->ARBPR & (uint32_t)VADC_G_ARBPR_ASEN1_Msk) >> VADC_G_ARBPR_ASEN1_Pos);
2601:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2602:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2603:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2604:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2605:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param trigger_input  Choice of the input earmarked as a trigger line
2606:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2607:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2608:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2609:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2610:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Select Trigger signal for scan request source.<BR>\n
2611:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A scan request source will raise conversion request only if there were either a request from app
2612:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * occurrence of a hardware trigger. This API selects one of the 16 input lines as a trigger line. 
2613:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * needed when a hardware trigger is needed for the conversion of the scan request source.
2614:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Refer to the reference manual to determine the signal that needs to be connected.
2615:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxASCTRL.XTSEL.
2616:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2617:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2618:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ScanSelectGating()<BR> XMC_VADC_GROUP_ScanEnableExternalTrigger()<BR>
2619:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2620:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_ScanSelectTrigger(XMC_VADC_GROUP_t *const group_ptr, XMC_VADC_TRIGGER_INPUT_SEL
2621:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2622:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2623:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2624:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2625:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param trigger_edge  Trigger edge selection
2626:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2627:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2628:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2629:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2630:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Selects the trigger edge for scan request source.<BR>\n
2631:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A scan request source will raise conversion request only if there were either a request from app
2632:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * occurrence of a hardware trigger. This API selects one of the 4 possible trigger edges. This is
2633:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * needed when a hardware trigger is needed for the conversion of the scan request source.
2634:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxASCTRL.XTMODE.
2635:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2636:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2637:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ScanSelectTrigger()<BR>
2638:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2639:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_ScanSelectTriggerEdge(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_TRIGGER
2640:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2641:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2642:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2643:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param gating_input  Module input signal meant to be selected as gating input
2644:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2645:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2646:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2647:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2648:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Select Gating signal for scan request source.<BR>\n
2649:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Passage of the trigger input to the request source can be controlled via a gating signal. Any on
2650:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * lines can be chosen as a gating signal. Trigger signal can be given to the scan request source o
2651:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * when the gating signal's active level is detected. Additionally the GxASMR.ENGT has to be config
2652:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the gating signal's active level. A call to this API would configure the register bit field GxAS
2653:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2654:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2655:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ScanSelectTrigger()<BR>
2656:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2657:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_ScanSelectGating(XMC_VADC_GROUP_t *const group_ptr, XMC_VADC_GATE_INPUT_SELECT_
2658:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2659:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2660:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2661:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param mode_sel  Select how the gating is applied to the scan request source
2662:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2663:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2664:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2665:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2666:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Selects the gating mode of scan request source.<BR>\n
2667:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Passage of the trigger input to the request source can be controlled via a gating signal.
2668:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API determines how the gating signal behaves, either active low or active high.
2669:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * If gating signal needs to ignored XMC_VADC_GATEMODE_IGNORE should be used as the \a mode_sel.
2670:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2671:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
2672:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_ScanSelectGating();
2673:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2674:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_ScanSetGatingMode(XMC_VADC_GROUP_t *const group_ptr, XMC_VADC_G
2675:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2676:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ScanSetGatingMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group
2677:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ScanSetGatingMode:Wrong mode selected", (mode_sel <= XMC_VADC_GATEMODE
2678:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2679:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   /* Clear the existing gate configuration */
2680:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->ASMR &= (uint32_t) (~((uint32_t)VADC_G_ASMR_ENGT_Msk));
2681:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   /* Set the new gating mode */
2682:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->ASMR |= (uint32_t)((uint32_t)mode_sel << VADC_G_ASMR_ENGT_Pos);
2683:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2684:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2685:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2686:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2687:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2688:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2689:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2690:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2691:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables continuous conversion mode.<BR>\n
2692:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Typically for a scan request source to generate conversion request, either a hardware trigger or
2693:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * request is a pre-requisite. Using autoscan feature it is possible to start the conversion once a
2694:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * sequence to repeat without any further triggers. Once all channels belonging to a scan request s
2695:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * been converted, a request source completion event is generated. Generation of this event can res
2696:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * sequence. Every request source event will cause a load event to occur. A call to this API would 
2697:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the register bit field GxASMR.SCAN.
2698:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2699:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2700:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ScanDisableContinuousMode()<BR>
2701:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2702:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_ScanEnableContinuousMode(XMC_VADC_GROUP_t *const group_ptr)
2703:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2704:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ScanEnableContinuousMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PT
2705:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->ASMR |= (uint32_t)VADC_G_ASMR_SCAN_Msk;
2706:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2707:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2708:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2709:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2710:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2711:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2712:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2713:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2714:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables continuous conversion mode.<BR>\n
2715:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Typically for a scan request source to generate conversion request, either a hardware trigger or
2716:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * request is a pre-requisite. Using autoscan feature it is possible to start the conversion once a
2717:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * sequence to repeat without any further triggers. Once all channels belonging to a scan request s
2718:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * been converted, a request source completion event is generated. Generation of this event can res
2719:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * sequence. By invoking this feature the Autoscan mode of operations is disabled. A call to this A
2720:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the register bit field GxASMR.SCAN.
2721:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2722:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2723:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ScanEnableContinuousMode()<BR>
2724:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2725:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_ScanDisableContinuousMode(XMC_VADC_GROUP_t *const group_ptr)
2726:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2727:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ScanDisableContinuousMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_P
2728:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->ASMR &= ~((uint32_t)VADC_G_ASMR_SCAN_Msk);
2729:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2730:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2731:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2732:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2733:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2734:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2735:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2736:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2737:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Generates conversion request (Software initiated conversion).<BR>\n
2738:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A conversion request can be raised either upon detection of a hardware trigger, or by software. 
2739:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the scan unit to generate a conversion request to the analog converter. It is assumed that the s
2740:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * been filled up with entries. A call to this API would configure the register bit field GxASMR.LD
2741:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2742:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2743:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  None.
2744:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2745:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_ScanTriggerConversion(XMC_VADC_GROUP_t *const group_ptr)
2746:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2747:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ScanTriggerConversion:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(g
2748:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->ASMR |= (uint32_t)VADC_G_ASMR_LDEV_Msk;
2749:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2750:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2751:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2752:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2753:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2754:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2755:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2756:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2757:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Aborts an ongoing scan sequence conversion.<BR>\n
2758:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * An ongoing sequence can be aborted at any time. The scan unit picks the pending channels one by 
2759:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * pending register and requests for their conversion. This API essentially clears the channel pend
2760:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * creating an illusion that there are no more channels left in the sequence.
2761:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the registers GxASMR, GxASCTRL, GxARBPR to achieve the sequen
2762:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2763:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2764:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  None.
2765:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2766:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_ScanSequenceAbort(XMC_VADC_GROUP_t *const group_ptr);
2767:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2768:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2769:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2770:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num     The channel meant to be added to scan sequence
2771:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   <BR>Range: [0x0 to 0x7]
2772:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2773:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2774:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2775:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2776:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Adds a channel to the scan sequence.<BR>\n
2777:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Call this API to insert a new single channel into the scan request source. This will be added to
2778:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * sequence. The added channel will be part of the conversion sequence when the next load event occ
2779:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit fields of GxASSEL.
2780:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2781:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2782:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ScanAddMultipleChannels()<BR>
2783:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2784:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_ScanAddChannelToSequence(XMC_VADC_GROUP_t *const group_ptr, con
2785:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2786:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("VADC_GSCAN_AddSingleChannel:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr)
2787:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ScanAddChannelToSequence:Wrong Channel Number", 
2788:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****              ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
2789:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->ASSEL |= (uint32_t)((uint32_t)1 << ch_num);
2790:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2791:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2792:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2793:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2794:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_mask    Mask word indicating channels which form part of scan conversion sequence
2795:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   Bit location 0/1/2/3/4/5/6/7 represents channels-0/1/2/3/4/5/6/7 respectively.
2796:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   To Add the channel to the scan sequence enable the respective bit.
2797:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   Passing a 0x0 will clear all the selected channels
2798:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   <BR>Range: [0x0 to 0xFF]
2799:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2800:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2801:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2802:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2803:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Adds multiple channels to the scan sequence.<BR>\n
2804:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Call this API to insert a multiple channels into the scan request source. This will be added to 
2805:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * sequence. The added channels will be a part of the conversion sequence when the next load event 
2806:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit fields of GxASSEL.
2807:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2808:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2809:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ScanAddChannelToSequence()<BR>
2810:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2811:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_ScanAddMultipleChannels(XMC_VADC_GROUP_t *const group_ptr, cons
2812:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2813:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ScanAddMultipleChannels:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR
2814:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->ASSEL = ch_mask;
2815:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2816:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2817:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2818:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2819:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num     The channel being audited for completion of conversion
2820:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   <BR>Range: [0x0 to 0x7]
2821:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2822:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     bool   returns true if the channel is pending conversion else returns false
2823:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2824:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2825:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Determine if the channel is pending for conversion.<BR>\n
2826:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will check if the Channel in question is awaiting conversion in the current arbitration
2827:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * When a load event occurs the scan sequence is pushed to a pending conversion register.
2828:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * From the pending register the channels are taken up by the converter. This API would return true
2829:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * if the channel is found in the pending register (GxASPND).
2830:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2831:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2832:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ScanGetNumChannelsPending()<BR>
2833:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2834:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE bool XMC_VADC_GROUP_ScanIsChannelPending(XMC_VADC_GROUP_t *const group_ptr, const u
2835:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2836:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2837:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ScanIsChannelPending:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(gr
2838:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ScanIsChannelPending:Wrong Channel Number", ((ch_num) < XMC_VADC_NUM_C
2839:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2840:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   return( (bool)((uint32_t)(group_ptr->ASPND >> ch_num) & 1U));
2841:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2842:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2843:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2844:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param  group_ptr     Constant pointer to the VADC group
2845:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return  <BR>
2846:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *   uint32_t   Returns the total channels pending for conversion.
2847:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *              <BR>Range: [0x0 to 0x8]
2848:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2849:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2850:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Returns the total number of pending channels.<BR>\n
2851:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will read the pending channels register and will return the number of channels that are
2852:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * When a load event occurs the scan sequence is pushed to a pending conversion register.
2853:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * From the pending register the channels are taken up by the converter. When the API is called it 
2854:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * return the total number of channels pending (GxASPND).
2855:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2856:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2857:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ScanIsChannelPending()<BR>
2858:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2859:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** uint32_t XMC_VADC_GROUP_ScanGetNumChannelsPending(XMC_VADC_GROUP_t *const group_ptr);
2860:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2861:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2862:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2863:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2864:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2865:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2866:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2867:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Manually asserts the conversion complete request source event.<BR>\n
2868:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will set the request source event for scan. This will trigger a interrupt if the
2869:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * service node pointer for the scan has been configured.
2870:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxSEFLAG.SEV1.
2871:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2872:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2873:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None.
2874:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2875:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_ScanTriggerReqSrcEvent(XMC_VADC_GROUP_t *const group_ptr)
2876:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2877:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ScanTriggerReqSrcEvent:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(
2878:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->SEFLAG    |= (uint32_t)VADC_G_SEFLAG_SEV1_Msk;
2879:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2880:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2881:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2882:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2883:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2884:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2885:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2886:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2887:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Acknowledges the scan conversion complete request source event.<BR>\n
2888:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will clear the request source event that occurred. This will clear a interrupt if it wa
2889:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxSEFLAG.SEV1.
2890:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2891:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2892:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ScanTriggerReqSrcEvent()<BR>
2893:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2894:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_ScanClearReqSrcEvent(XMC_VADC_GROUP_t *const group_ptr)
2895:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2896:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ScanClearReqSrcEvent:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(gr
2897:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->SEFCLR |= (uint32_t)VADC_G_SEFCLR_SEV1_Msk;
2898:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2899:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2900:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2901:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2902:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2903:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *   bool   returns true if the service request event is raised.
2904:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *          returns false if the service request event was not raised.
2905:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2906:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2907:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Determines if the request source event is asserted.<BR>
2908:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will get the status of the scan request source event. Will return a true
2909:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * if the event has occurred for scan. A call to this API would access the register bit field GxSEF
2910:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2911:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2912:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  None.
2913:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2914:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE bool XMC_VADC_GROUP_ScanGetReqSrcEventStatus(XMC_VADC_GROUP_t *const group_ptr)
2915:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2916:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GSCAN_GetRSEvent:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
2917:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   return( (bool)(group_ptr->SEFLAG & (uint32_t)VADC_G_SEFLAG_SEV1_Msk));
2918:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2919:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2920:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2921:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr Constant pointer to the VADC group
2922:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param sr    Service Request Id
2923:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2924:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2925:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2926:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2927:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Connects the scan request source event to the SR line of VADC.<BR>\n
2928:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will connect a Service Request line(SR) to a scan request source event. Hence to get a 
2929:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Service request line one has to enable the required NVIC node.  A call to this API would configu
2930:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * field GxSEVNP.SEV1NP .
2931:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2932:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2933:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  None.
2934:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2935:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode(XMC_VADC_GROUP_t *const group_ptr, const XMC_VA
2936:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2937:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2938:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2939:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2940:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2941:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2942:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2943:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the trigger for scan request source.<BR>\n
2944:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * By using this API, the trigger signal will be activated for the scan request source. The trigger
2945:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * edge will be selected from the ASCTRL register. The Selection of a input will be done by
2946:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_ScanSelectTrigger(). A call to this API would configure the register bit field Gx
2947:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2948:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2949:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ScanSelectTrigger()<BR> XMC_VADC_GROUP_ScanDisableExternalTrigger()<BR>
2950:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2951:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_ScanEnableExternalTrigger(XMC_VADC_GROUP_t *const group_ptr)
2952:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2953:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ScanEnableExternalTrigger:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_P
2954:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2955:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->ASMR |= (uint32_t)VADC_G_ASMR_ENTR_Msk;
2956:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2957:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2958:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2959:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2960:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2961:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2962:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2963:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2964:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the trigger for scan request source.<BR>
2965:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * By using this API the trigger will be deactivated for the scan request source.
2966:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This will just deactivate the H/W trigger for the scan request source. If any configuration were
2967:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * to select the trigger input in GxASCTRL, it will be not be effected by this API.
2968:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxASMR.ENTR.
2969:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2970:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2971:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_ScanEnableExternalTrigger()<BR>
2972:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2973:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_ScanDisableExternalTrigger(XMC_VADC_GROUP_t *const group_ptr)
2974:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
2975:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ScanDisableExternalTrigger:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_
2976:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2977:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->ASMR &= ~((uint32_t)VADC_G_ASMR_ENTR_Msk);
2978:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
2979:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2980:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2981:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
2982:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param channel_num   channel number to be removed from the scan sequence.
2983:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
2984:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
2985:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2986:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
2987:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Removes a channel from the scan sequence.<BR>
2988:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * By using this API the it is possible to remove a single channel from the conversion sequence.
2989:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The remaining channels will continue however they are.
2990:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register GxASSEL.
2991:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
2992:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
2993:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  None.
2994:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
2995:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_ScanRemoveChannel(XMC_VADC_GROUP_t *const group_ptr, const uint32_t channel_num
2996:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
2997:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
2998:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
2999:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Pointer to the VADC module
3000:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config     Pointer to initialization data structure
3001:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3002:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3003:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes the Background scan functional block.<BR>\n
3004:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The BACKGROUND SCAN request source functional block converts channels of all VADC groups that ha
3005:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * been assigned as a priority channel (priority channels can be converted only by queue and scan).
3006:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * request source converts the unprioritized channels. Unprioritized channels however can also be u
3007:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * and scan. But a channel which is prioritized can not be used with background request source.
3008:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3009:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3010:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_BackgroundEnableArbitrationSlot()<BR> XMC_VADC_GROUP_BackgroundDisableArbitratio
3011:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_BackgroundSelectTrigger()<BR> XMC_VADC_GLOBAL_BackgroundSelectGating()<BR>
3012:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3013:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_BackgroundInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_BACKGROUND_
3014:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3015:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
3016:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3017:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr Constant pointer to the VADC group which may receive a
3018:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                  conversion request from background request source
3019:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3020:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3021:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3022:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3023:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3024:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables arbitration slot of the Background request source.<BR>\n
3025:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * If the Background request source must have its conversion request considered by the arbiter, it 
3026:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the arbitration rounds. Even if a load event occurs the Background channel can only be converted
3027:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * comes to the Background slot. Thus this must be enabled if any conversion need to take place.
3028:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxARBPR.ASEN2.
3029:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3030:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3031:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_BackgroundDisableArbitrationSlot()<BR>
3032:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3033:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_BackgroundEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_p
3034:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3035:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_BackgroundEnableArbitrationSlot:Wrong Group Pointer",  XMC_VADC_CHECK_
3036:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->ARBPR |= (uint32_t)VADC_G_ARBPR_ASEN2_Msk;
3037:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3038:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3039:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3040:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr  Constant pointer to the VADC group which may receive a conversion request
3041:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                     from background request source
3042:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3043:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3044:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3045:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3046:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables arbitration slot of the Background request source.<BR>\n
3047:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * If the Background request source must have its conversion request considered by the arbiter, it 
3048:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the arbitration rounds. Even if a load event occurs the Background channel can only be converted
3049:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * comes to the Background slot.A call to this API will lead to all conversions request by Backgrou
3050:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxARBPR.ASEN2
3051:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3052:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3053:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_BackgroundEnableArbitrationSlot()<BR>
3054:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3055:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_BackgroundDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_
3056:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3057:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_BackgroundDisableArbitrationSlot:Wrong Group Pointer",  XMC_VADC_CHECK
3058:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN2_Msk);
3059:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3060:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
3061:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3062:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3063:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr       Pointer to the VADC module
3064:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param input_num  Choice of the input earmarked as a trigger line
3065:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   Accepts enum ::XMC_VADC_TRIGGER_INPUT_SELECT_t
3066:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3067:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3068:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3069:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3070:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Select Trigger signal for Background request source.<BR>\n
3071:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A Background request source will raise conversion request only if there were either a request fr
3072:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * occurrence of a hardware trigger. This API selects one of the 16 input lines as a trigger line. 
3073:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * needed when a hardware trigger is needed for the conversion of the Background request source.
3074:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Refer to the reference manual to determine the signal that needs to be connected.
3075:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field BRSCTRL.XTSEL.
3076:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3077:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3078:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_BackgroundSelectGating()<BR> XMC_VADC_GLOBAL_BackgroundEnableExternalTrigger()<
3079:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3080:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_BackgroundSelectTrigger(XMC_VADC_GLOBAL_t *const global_ptr, const uint32_t in
3081:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3082:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3083:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3084:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr       Pointer to the VADC module
3085:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param trigger_edge  Select the trigger edge
3086:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3087:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3088:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3089:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3090:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Select Trigger edge for Background request source.<BR>\n
3091:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A Background request source will raise conversion request only if there were either a request fr
3092:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * occurrence of a hardware trigger. This API selects one of the 4 possible values for the trigger 
3093:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * needed when a hardware trigger is needed for the conversion of the Background request source.
3094:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field BRSCTRL.XTMODE.
3095:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3096:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3097:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_BackgroundSelectGating()<BR> XMC_VADC_GLOBAL_BackgroundEnableExternalTrigger()<
3098:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3099:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_BackgroundSelectTriggerEdge(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VAD
3100:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3101:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3102:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr       Pointer to the VADC module
3103:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param input_num  Module input signal meant to be selected as gating input
3104:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   Accepts enum ::XMC_VADC_GATE_INPUT_SELECT_t
3105:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3106:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3107:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3108:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3109:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Select Gating signal for Background request source.<BR>\n
3110:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Passage of the trigger input to the request source can be controlled via a gating signal. Any on
3111:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * lines can be chosen as a gating signal. Trigger signal can be given to the Background request so
3112:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * when the gating signal's active level is detected. Additionally the GxBRSMR.ENGT has to be confi
3113:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the gating signal's active level. A call to this API would configure the register bit field BRSC
3114:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3115:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3116:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_BackgroundSelectTrigger()<BR>
3117:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3118:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_BackgroundSelectGating(XMC_VADC_GLOBAL_t *const global_ptr, const uint32_t inp
3119:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3120:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3121:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr       Pointer to the VADC module
3122:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param mode_sel  Select how the gating is applied to the background scan request source
3123:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3124:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3125:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3126:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <b>Details of function</b><br>
3127:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Selects the gating mode of background request source.<BR>\n
3128:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Passage of the trigger input to the request source can be controlled via a gating signal.
3129:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API determines how the gating signal behaves, either active low or active high.
3130:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * If gating signal needs to ignored XMC_VADC_GATEMODE_IGNORE should be used as the \a mode_sel.
3131:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field BRSMR.ENGT.
3132:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3133:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
3134:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_BackgroundSelectGating();
3135:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3136:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_BackgroundSetGatingMode(XMC_VADC_GLOBAL_t *const global_ptr,
3137:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                             XMC_VADC_GATEMODE_t mode_sel)
3138:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3139:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundSetGatingMode:Wrong Module Pointer", (global_ptr == VADC))
3140:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundSetGatingMode:Wrong mode selected", (mode_sel <= XMC_VADC_G
3141:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3142:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   /* Clear the existing gate configuration */
3143:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->BRSMR &= (uint32_t)(~((uint32_t)VADC_BRSMR_ENGT_Msk));
3144:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   /* Configure the new gating mode*/
3145:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->BRSMR |= (uint32_t)((uint32_t)mode_sel << VADC_BRSMR_ENGT_Pos);
3146:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3147:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3148:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3149:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3150:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr       Pointer to the VADC module
3151:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3152:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3153:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3154:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3155:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables continuous conversion mode.<BR>\n
3156:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Typically for a Background request source to generate conversion request, either a hardware trig
3157:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * request is needed. Using autoscan (continuous conversion)feature it is possible to start the con
3158:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * once and allow the sequence to repeat without any further triggers. Once all channels belonging 
3159:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * request source have been converted, a request source completion event is generated. Generation o
3160:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * can restart the Background configure sequence. Every request source event will cause a load even
3161:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would access the register bit field BRSMR.SCAN.
3162:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3163:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3164:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_BackgroundDisableContinuousMode()<BR>
3165:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3166:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_BackgroundEnableContinuousMode(XMC_VADC_GLOBAL_t *const global
3167:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3168:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundEnableContinuousMode:Wrong Module Pointer", (global_ptr == 
3169:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->BRSMR |= (uint32_t)VADC_BRSMR_SCAN_Msk;
3170:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3171:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3172:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3173:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr       Pointer to the VADC module
3174:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3175:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3176:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3177:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3178:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables continuous conversion mode.<BR>\n
3179:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Typically for a Background request source to generate conversion request, either a hardware trig
3180:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * request is a pre-requisite. Using autoscan feature it is possible to start the conversion once a
3181:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * sequence to repeat without any further triggers. Once all channels belonging to a Background req
3182:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * been converted, a request source completion event is generated. Generation of this event can res
3183:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * sequence. By invoking this API the Autoscan mode of operations is disabled. A call to this API w
3184:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * register bit field BRSMR.SCAN.
3185:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3186:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3187:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_BackgroundEnableContinuousMode()<BR>
3188:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3189:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_BackgroundDisableContinuousMode(XMC_VADC_GLOBAL_t *const globa
3190:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3191:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundDisableContinuousMode:Wrong Module Pointer", (global_ptr ==
3192:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->BRSMR &= ~((uint32_t)VADC_BRSMR_SCAN_Msk);
3193:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3194:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3195:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3196:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr       Pointer to the VADC module
3197:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3198:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3199:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3200:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3201:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Generates conversion request (Software initiated conversion).<BR>\n
3202:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A conversion request can be raised either upon detection of a hardware trigger, or by software. 
3203:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the scan unit to generate a conversion request to the analog converter. It is assumed that the b
3204:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * has already been filled up with entries. A call to this API would set the register bit field BRS
3205:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3206:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3207:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  None.
3208:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3209:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_BackgroundTriggerConversion(XMC_VADC_GLOBAL_t *const global_pt
3210:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3211:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundTriggerConversion:Wrong Module Pointer", (global_ptr == VAD
3212:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->BRSMR |= (uint32_t)VADC_BRSMR_LDEV_Msk;
3213:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3214:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3215:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3216:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr       Pointer to the VADC module
3217:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3218:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3219:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3220:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3221:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Aborts an ongoing background scan conversion(sequence).<BR>\n
3222:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * An ongoing sequence can be aborted at any time. The scan unit picks the pending channels one by 
3223:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * pending register and requests for their conversion. This API essentially clears the channel pend
3224:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * creating an illusion that there are no more channels left in the sequence.
3225:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the registers BRSMR, BRSCTRL, GxARBPR(if group is available) 
3226:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * current scan sequence.
3227:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3228:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3229:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  None.
3230:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3231:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_BackgroundAbortSequence(XMC_VADC_GLOBAL_t *const global_ptr);
3232:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3233:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3234:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr       Pointer to the VADC module
3235:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param grp_num    ID of the VADC group whose unprioritized channels have been assigned to backgr
3236:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   Request source
3237:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num     The unprioritized channel meant to be added to the scan sequence
3238:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   <BR>Range: [0x0 to 0x7]
3239:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3240:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3241:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3242:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3243:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Adds a channel to the background scan sequence.<BR>\n
3244:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Call this API to insert a new single channel into the background scan request source. This will 
3245:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * sequence. The added channel will be part of the conversion sequence when the next load event occ
3246:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit fields of BRSSEL.
3247:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3248:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3249:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_BackgroundAddMultipleChannels()<BR>
3250:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3251:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_BackgroundAddChannelToSequence(XMC_VADC_GLOBAL_t *const global
3252:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                                     const uint32_t grp_num,
3253:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                                     const uint32_t ch_num)
3254:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3255:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundAddChannelToSequence:Wrong Module Pointer", (global_ptr == 
3256:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundAddChannelToSequence:Wrong Group Number",((grp_num) < XMC_V
3257:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundAddChannelToSequence:Wrong Channel Number",
3258:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****              ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
3259:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3260:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->BRSSEL[grp_num] |= (uint32_t)((uint32_t)1 << ch_num);
3261:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3262:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3263:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3264:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr       Pointer to the VADC module
3265:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param grp_num    ID of the VADC group whose unprioritized channels have been assigned to backgr
3266:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_mask    Mask word indicating channels which form part of scan conversion sequence
3267:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   Bit location 0/1/2/3/4/5/6/7 represents channels-0/1/2/3/4/5/6/7 respectively.
3268:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   To Add the channel to the scan sequence enable the respective bit.
3269:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   Passing a 0x0 will clear all the previously selected channels
3270:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   <BR>Range: [0x0 to 0xFF]
3271:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3272:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3273:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3274:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3275:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Adds multiple channels to the scan sequence.<BR>\n
3276:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Call this API to insert a multiple channels into the scan request source. This will be added to 
3277:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * sequence. The added channels will be a part of the conversion sequence when the next load event 
3278:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit fields of BRSSEL.
3279:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3280:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3281:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_BackgroundAddChannelToSequence()<BR>
3282:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3283:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_BackgndAddMultipleChannels(XMC_VADC_GLOBAL_t *const global_ptr
3284:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                                 const uint32_t grp_num,
3285:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                                 const uint32_t ch_mask)
3286:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3287:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgndAddMultipleChannels:Wrong Module Pointer", (global_ptr == VADC
3288:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgndAddMultipleChannels:Wrong Group Number",   ((grp_num) < XMC_VA
3289:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->BRSSEL[grp_num] |= ch_mask;
3290:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3291:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3292:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3293:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr       Pointer to the VADC module
3294:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param grp_num    ID of the VADC group whose unprioritized channels have been assigned to backgr
3295:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num     The channel being audited for completion of conversion
3296:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                   <BR>Range: [0x0 to 0x7]
3297:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3298:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     bool   returns true if the channel is pending conversion else returns false
3299:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3300:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3301:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Determine if the channel is pending.<BR>\n
3302:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will check if the Channel in question is awaiting conversion in the current arbitration
3303:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * When a load event occurs the scan sequence is pushed to a pending conversion register.
3304:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * From the pending register the channels are taken up by the converter. This API would return true
3305:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * if the channel is found in the pending register (BRSPND[\b grp_num]).
3306:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3307:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3308:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_BackgroundGetNumChannelsPending()<BR>
3309:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3310:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE bool XMC_VADC_GLOBAL_BackgroundIsChannelPending(XMC_VADC_GLOBAL_t *const global_ptr
3311:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                                 const uint32_t grp_num,
3312:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                                 const uint32_t ch_num)
3313:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3314:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundIsChannelPending:Wrong Module Pointer", (global_ptr == VADC
3315:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundIsChannelPending:Wrong Group Number",   ((grp_num) < XMC_VA
3316:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundIsChannelPending:Wrong Channel Number",
3317:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****              ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
3318:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3319:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   return( (bool)(global_ptr->BRSPND[grp_num] & (uint32_t)((uint32_t)1 << ch_num)));
3320:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3321:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3322:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3323:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr       Pointer to the VADC module
3324:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * @return  <BR>
3325:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *   uint32_t   Returns the total channels pending for conversion.
3326:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *              <BR>Range: [0x0 to (0x8*number of groups)]
3327:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3328:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3329:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Returns the number of pending channels.<BR>\n
3330:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will read the pending channels register and will return the number of channels that are
3331:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * When a load event occurs the scan sequence is pushed to a pending conversion register.
3332:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * From the pending register the channels are taken up by the converter. When the API is called it 
3333:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * return the total number of channels pending (BRSPND[\b grp_num]).
3334:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3335:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3336:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_BackgroundIsChannelPending()<BR>
3337:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3338:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** uint32_t XMC_VADC_GLOBAL_BackgroundGetNumChannelsPending(XMC_VADC_GLOBAL_t *const global_ptr);
3339:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3340:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3341:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr       Pointer to the VADC module
3342:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3343:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3344:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3345:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3346:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Manually asserts the conversion complete request source event.<BR>\n
3347:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will set the request source event for background scan. This will trigger a interrupt if
3348:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * service node pointer for the scan has been configured.
3349:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GLOBEFLAG.SEVGLB.
3350:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3351:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3352:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None.
3353:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3354:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_BackgroundTriggerReqSrcEvent(XMC_VADC_GLOBAL_t *const global_p
3355:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3356:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundTriggerReqSrcEvent:Wrong Module Pointer", (global_ptr == VA
3357:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBEFLAG |= (uint32_t)VADC_GLOBEFLAG_SEVGLB_Msk;
3358:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3359:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3360:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3361:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr       Pointer to the VADC module
3362:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3363:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3364:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3365:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3366:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Acknowledges the background scan conversion complete request source event.<BR>\n
3367:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will clear the request source event that occurred. This will clear a interrupt if it wa
3368:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GLOBEFLAG.SEVGLB
3369:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3370:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3371:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_BackgroundTriggerReqSrcEvent()<BR>
3372:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3373:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_BackgroundClearReqSrcEvent(XMC_VADC_GLOBAL_t *const global_ptr
3374:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3375:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundClearReqSrcEvent:Wrong Module Pointer", (global_ptr == VADC
3376:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBEFLAG |= (uint32_t)VADC_GLOBEFLAG_SEVGLBCLR_Msk;
3377:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3378:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3379:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3380:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr       Pointer to the VADC module
3381:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3382:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *   bool   returns true if the service request event is raised.
3383:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *          returns false if the service request event was not raised.
3384:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3385:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3386:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Determines if the request source event is asserted.<BR>
3387:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will get the status of the background scan request source event. Will return a true
3388:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * if the event has occurred for background scan. A call to this API would configure the register
3389:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * bit field GLOBEFLAG.SEVGLB.
3390:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3391:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3392:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  None.
3393:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3394:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE bool XMC_VADC_GLOBAL_BackgroundGetReqSrcEventStatus(XMC_VADC_GLOBAL_t *const global
3395:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3396:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundGetReqSrcEventStatus:Wrong Module Pointer", (global_ptr == 
3397:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   return((bool)(global_ptr->GLOBEFLAG & (uint32_t)VADC_GLOBEFLAG_SEVGLB_Msk));
3398:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3399:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3400:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3401:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr       Pointer to the VADC module
3402:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3403:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3404:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3405:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3406:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the trigger for background scan request source.<BR>\n
3407:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * By using this API the trigger will be activated for the scan request source. The trigger signal 
3408:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * edge will be selected from the BRSCTRL register. The Selection of a input will be done by
3409:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_BackgroundSelectTrigger(). A call to this API would configure the register bit f
3410:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3411:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3412:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_BackgroundSelectTrigger()<BR> XMC_VADC_GLOBAL_BackgroundDisableExternalTrigger(
3413:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3414:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_BackgroundEnableExternalTrigger(XMC_VADC_GLOBAL_t *const globa
3415:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3416:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundEnableExternalTrigger:Wrong Group Pointer", (global_ptr == 
3417:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3418:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->BRSMR |= (uint32_t)VADC_BRSMR_ENTR_Msk;
3419:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3420:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3421:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3422:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr       Pointer to the VADC module
3423:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3424:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3425:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3426:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3427:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the trigger for background scan request source.<BR>
3428:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * By using this API the trigger will be deactivated for the background scan request source.
3429:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This will just deactivate the H/W trigger for the background scan request source. If any configu
3430:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * to select the trigger input in BRSCTRL will be not be effected. A call to this API would configu
3431:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * bit field BRSMR.ENTR.
3432:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3433:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   * \par<b>Related APIs:</b><br>
3434:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_BackgroundEnableExternalTrigger()<BR>
3435:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3436:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_BackgroundDisableExternalTrigger(XMC_VADC_GLOBAL_t *const glob
3437:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3438:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundDisableExternalTrigger:Wrong Group Pointer", (global_ptr ==
3439:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3440:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->BRSMR &= ~((uint32_t)VADC_BRSMR_ENTR_Msk);
3441:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3442:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3443:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_QUEUE_AVAILABLE == 1U)
3444:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3445:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr Pointer to the VADC group
3446:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config     Pointer to initialization data structure
3447:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3448:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3449:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3450:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3451:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes VADC QUEUE functional block.<BR>\n
3452:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The QUEUE request source functional block converts channels stored in a queue. The first channel
3453:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * queue is converted first. A channel once converted, can be placed back into the queue if desired
3454:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API will first disable the arbitration slot for queue (XMC_VADC_GROUP_QueueEnable
3455:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * and then it would configure all the related registers with the required configuration values.
3456:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The arbitration slot is re-enabled at the end of init by invoking XMC_VADC_GROUP_QueueDisableArb
3457:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the registers GxARBPR, GxQCTRL0, GxQMR0 to configure the queu
3458:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * source.
3459:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3460:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3461:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueEnableArbitrationSlot()<BR> XMC_VADC_GROUP_QueueDisableArbitrationSlot()<BR
3462:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueSelectTrigger()<BR> XMC_VADC_GROUP_QueueSelectGating()<BR>
3463:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3464:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_QueueInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_QUEUE_CONFIG_t *con
3465:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3466:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3467:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
3468:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3469:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3470:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3471:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3472:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables arbitration slot of the queue request source.<BR>\n
3473:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * If the QUEUE request source must have its conversion request considered by the arbiter, it must 
3474:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the arbitration rounds. Even if a load event occurs the queue channel can only be converted when
3475:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * to the queue slot. Thus this must be enabled if any conversion need to take place.
3476:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxARBPR.ASEN0.
3477:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3478:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3479:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueDisableArbitrationSlot()<BR>
3480:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3481:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_QueueEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
3482:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3483:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_QueueEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_
3484:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->ARBPR |= (uint32_t)((uint32_t)1 << VADC_G_ARBPR_ASEN0_Pos);
3485:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3486:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3487:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3488:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
3489:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3490:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3491:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3492:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3493:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables arbitration slot of the queue request source.<BR>\n
3494:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * If the QUEUE request source must have its conversion request considered by the arbiter, it must 
3495:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the arbitration rounds. Even if a load event occurs the queue channel can only be converted when
3496:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * to the queue slot.A call to this API will lead to all conversions request by queue to be blocked
3497:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxARBPR.ASEN0.
3498:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3499:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3500:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueEnableArbitrationSlot()<BR>
3501:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3502:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_QueueDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
3503:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3504:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_QueueDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP
3505:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN0_Msk);
3506:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3507:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3508:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3509:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3510:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
3511:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3512:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    bool  returns true if the arbitration is enabled else returns false.
3513:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3514:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3515:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Returns the arbitration status of the queue request source.<BR>\n
3516:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * If the queue request source must have its conversion request considered by the arbiter, it must 
3517:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the arbitration rounds. Even if a load event occurs the queue channel can only be converted when
3518:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * to the queue slot. A call to this API would return the status of the arbitration slot of queue.
3519:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would read the register bit field GxARBPR.ASEN1.
3520:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3521:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3522:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueEnableArbitrationSlot(),<BR>  XMC_VADC_GROUP_QueueDisableArbitrationSlot()<
3523:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3524:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE bool XMC_VADC_GROUP_QueueIsArbitrationSlotEnabled(XMC_VADC_GROUP_t *const group_ptr
3525:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3526:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_QueueIsArbitrationSlotEnabled:Wrong Group Pointer", XMC_VADC_CHECK_GRO
3527:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3528:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   return ((group_ptr->ARBPR & (uint32_t)VADC_G_ARBPR_ASEN0_Msk) >> VADC_G_ARBPR_ASEN0_Pos);
3529:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3530:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3531:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3532:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
3533:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param input_num  Choice of the input earmarked as a trigger line
3534:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3535:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3536:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3537:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3538:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Select Trigger signal for queue request source.<BR>\n
3539:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A queue request source will raise conversion request only if there were either a request from ap
3540:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * occurrence of a hardware trigger. This API selects one of the 16 input lines as a trigger line. 
3541:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * needed when a hardware trigger is needed for the conversion of the queue request source.
3542:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Refer to the reference manual to determine the signal that needs to be connected.
3543:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxQCTRL0.XTSEL.
3544:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3545:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3546:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueSelectGating()<BR> XMC_VADC_GROUP_QueueEnableExternalTrigger()<BR>
3547:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3548:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_QueueSelectTrigger(XMC_VADC_GROUP_t *const group_ptr, 
3549:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                        const XMC_VADC_TRIGGER_INPUT_SELECT_t input_num);
3550:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3551:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3552:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
3553:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param trigger_edge  Choice of the trigger edge
3554:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3555:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3556:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3557:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3558:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Select Trigger signal edge for queue request source.<BR>\n
3559:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A queue request source will raise conversion request only if there were either a request from ap
3560:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * occurrence of a hardware trigger. This API selects one of the 4 trigger edges. This is
3561:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * needed when a hardware trigger is needed for the conversion of the queue request source.
3562:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Refer to the reference manual to determine the signal that needs to be connected.
3563:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxQCTRL0.XTMODE.
3564:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3565:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3566:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueSelectGating()<BR> XMC_VADC_GROUP_QueueEnableExternalTrigger()<BR>
3567:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3568:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_QueueSelectTriggerEdge(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_TRIGGE
3569:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3570:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3571:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
3572:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param input_num  Choice of the input earmarked as the gating line
3573:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3574:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3575:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3576:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3577:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Select Gating signal for queue request source.<BR>\n
3578:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Passage of the trigger input to the request source can be controlled via a gating signal. Any on
3579:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * lines can be chosen as a gating signal. Trigger signal can be given to the queue request source 
3580:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * when the gating signal's active level is detected. Additionally the GxQMR0.ENGT has to be config
3581:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the gating signal's active level. A call to this API would configure the register bit field GxQC
3582:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3583:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3584:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueSelectTrigger()<BR>
3585:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3586:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_QueueSelectGating(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GATE_INPUT_
3587:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3588:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3589:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
3590:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param mode_sel  Select how the gating is applied to the queue request source
3591:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3592:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3593:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3594:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <b>Details of function</b><br>
3595:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Selects the gating mode of queue request source.<BR>\n
3596:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Passage of the trigger input to the request source can be controlled via a gating signal.
3597:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API determines how the gating signal behaves, either active low or active high.
3598:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * If gating signal needs to ignored XMC_VADC_GATEMODE_IGNORE should be used as the \a mode_sel.
3599:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxQMR0.ENGT.
3600:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3601:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
3602:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_QueueSelectGating();
3603:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3604:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_QueueSetGatingMode(XMC_VADC_GROUP_t *const group_ptr, XMC_VADC_
3605:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3606:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_QueueSetGatingMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(grou
3607:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_QueueSetGatingMode:Wrong mode selected", (mode_sel <= XMC_VADC_GATEMOD
3608:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3609:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   /* Clear the existing gate configuration */
3610:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->QMR0 &= (uint32_t)(~((uint32_t) VADC_G_QMR0_ENGT_Msk));
3611:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   /* Set the new gating mode */
3612:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->QMR0 |= (uint32_t)((uint32_t)mode_sel << VADC_G_QMR0_ENGT_Pos);
3613:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3614:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3615:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3616:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3617:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
3618:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3619:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3620:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3621:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3622:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Generates conversion request (Software initiated conversion).<BR>
3623:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A conversion request can be raised either upon detection of a hardware trigger, or by software. 
3624:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the queue unit to generate a conversion request to the analog converter. It is assumed that the 
3625:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * been filled up with entries. A call to this API would configure the register bit field GxQMR0.TR
3626:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3627:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Note:</b><br>
3628:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The conversion of queue entry will start immediately after the entry has been loaded into GxQINR
3629:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This happens only if the queue entry has been loaded into the register without the need for the 
3630:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * If a H/W Trigger is selected while loading the entry, the conversion will occur in one of the 2 
3631:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <ul>
3632:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <li> The H/W generates a trigger needed for the queue request source.
3633:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * <li> The Conversion is triggered manually by calling this API.
3634:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * </ul>
3635:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3636:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3637:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueInsertChannel()<BR>
3638:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3639:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_QueueTriggerConversion(XMC_VADC_GROUP_t *const group_ptr)
3640:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3641:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_QueueTriggerConversion:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(
3642:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->QMR0 |= (uint32_t)((uint32_t)1 << VADC_G_QMR0_TREV_Pos);
3643:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3644:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3645:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3646:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
3647:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3648:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    uint32_t returns the total number of channels.
3649:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *             <BR>Range: [0x0 to 0x8]
3650:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3651:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3652:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Returns the number of channels present in the queue.<BR>\n
3653:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will return the queue buffer size. This buffer will be consisting of valid queue entrie
3654:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * will be converted when a trigger event occurs. All the entries that are loaded onto the GxQINR0 
3655:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * be added to the queue buffer. Hence if an application needs to get the number of valid queue ent
3656:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * this API would provide the interface. A call to this API would access the registers GxQBUR0, GxQ
3657:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * to determine the queue length.
3658:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3659:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3660:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueInsertChannel()<BR>
3661:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3662:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** uint32_t XMC_VADC_GROUP_QueueGetLength(XMC_VADC_GROUP_t *const group_ptr);
3663:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3664:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3665:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
3666:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3667:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3668:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3669:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3670:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Aborts an ongoing conversion by flushing the queue.<BR>\n
3671:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will flush the queue buffer. Ongoing conversion of the Queue request source will
3672:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * not be effected by this API. This would clear all the contents that are present in the queue buf
3673:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the registers GxQCTRL0, GxQMR0, GxARBPR in order to abort
3674:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the queue sequence.
3675:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3676:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3677:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueRemoveChannel()<BR> XMC_VADC_GROUP_QueueFlushEntries() <BR>
3678:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3679:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_QueueAbortSequence(XMC_VADC_GROUP_t *const group_ptr);
3680:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3681:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3682:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
3683:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3684:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3685:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3686:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3687:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Flushing the queue Entry.<BR>\n
3688:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will flush one entry in the queue buffer. Ongoing conversion of the Queue request sourc
3689:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * not be effected by this API. This would clear all the contents that are present in the queue buf
3690:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the registers  GxQMR0. This is a Blocking API, i.e will only 
3691:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * all the entries are removed from the queue.
3692:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3693:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3694:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueRemoveChannel()<BR> XMC_VADC_GROUP_QueueAbortSequence(0<BR>
3695:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3696:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_QueueFlushEntries(XMC_VADC_GROUP_t *const group_ptr)
3697:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3698:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   /* Initiate flushing of the queue */
3699:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->QMR0 |= (uint32_t)VADC_G_QMR0_FLUSH_Msk;
3700:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3701:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   while( !((group_ptr->QSR0)& (uint32_t)VADC_G_QSR0_EMPTY_Msk))
3702:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   {
3703:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****     /* Wait until the queue is indeed flushed */
3704:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   }
3705:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3706:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3707:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3708:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3709:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
3710:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3711:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3712:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3713:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3714:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Clears the next valid channel in the queue buffer.<BR>\n
3715:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A queue entry lined up for conversion can be removed and replaced by its successor. The call to 
3716:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * first check if a valid queue entry is present in the queue backup register if present would clea
3717:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * If no valid queue entries are present in the backup then the first channel
3718:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * present in the queue buffer would be cleared.
3719:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the registers GxQCTRL0, GxQMR0, GxARBPR in order to clear a
3720:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * channel from the queue.
3721:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3722:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3723:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueInsertChannel()<BR>
3724:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3725:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_QueueRemoveChannel(XMC_VADC_GROUP_t *const group_ptr);
3726:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3727:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3728:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3729:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
3730:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param entry      Details of the node being added
3731:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3732:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3733:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3734:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3735:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Inserts a queue entry to the tail of the queue buffer.<BR>\n
3736:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will insert a new channel into the queue buffer. The Queue will start conversion of
3737:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the channels from the head of the buffer. This Insert will place the entry after the last valid 
3738:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * If no valid entries are present then this API will place the Queue entry at the head of the buff
3739:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Then the successive call to the insert will place the new entry after the last entry.
3740:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register GxQINR0 for a single queue entry.
3741:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3742:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3743:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueRemoveChannel()<BR>
3744:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3745:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_QueueInsertChannel(XMC_VADC_GROUP_t *const group_ptr,
3746:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                        const XMC_VADC_QUEUE_ENTRY_t entry)
3747:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3748:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_QueueInsertChannel:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(grou
3749:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   /* Insert the channel physically and get the length of the queue*/
3750:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->QINR0 = entry.qinr0;
3751:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3752:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3753:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3754:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr Constant pointer to the VADC group
3755:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3756:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     int32_t Returns -1 if there are no channels for conversion
3757:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *             Else would return the next valid channel for conversion.
3758:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *             <BR>Range: [0x0 to 0x8]
3759:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3760:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3761:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Returns the next entry in the queue request source for conversion.<BR>\n
3762:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Identifies the channel in the queue lined up for conversion next.
3763:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * API will return a valid queue entry from the queue buffer. First checks for the valid channel en
3764:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * in the backup register and returns if present. If the valid entry has not been found in the back
3765:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * then the queue buffer is searched for a valid entry. A call to this API would access the registe
3766:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * GxQBUR0 to determine the next channel.
3767:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3768:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3769:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueRemoveChannel()<BR> XMC_VADC_GROUP_QueueInsertChannel()<BR>
3770:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3771:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** int32_t XMC_VADC_GROUP_QueueGetNextChannel(XMC_VADC_GROUP_t *const group_ptr);
3772:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3773:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3774:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr Constant pointer to the VADC group
3775:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3776:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *     int32_t Returns -1 if there is no channel that have been interrupted.
3777:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *             Else would return the channel that is interrupted.
3778:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *             <BR>Range: [0x0 to 0x8]
3779:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3780:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3781:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Identifies the channel whose conversion was suspended.<BR>\n
3782:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * When using cancel inject repeat mode the canceled conversion will be placed in the backup regist
3783:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will return the valid queue channel number from the backup register. This happens when 
3784:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * there is a high priority conversion interrupts the conversion of queue request source. This forc
3785:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * to goto the backup register. A call to this API would access the register GxQBUR0 to determine t
3786:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * interrupted channel.
3787:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3788:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3789:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  None.
3790:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3791:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** int32_t XMC_VADC_GROUP_QueueGetInterruptedChannel(XMC_VADC_GROUP_t *const group_ptr);
3792:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3793:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3794:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr Constant pointer to the VADC group
3795:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3796:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3797:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3798:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3799:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Manually asserts the conversion complete request source event.<BR>\n
3800:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will set the request source event for queue. This will trigger a interrupt if the
3801:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * service node pointer for the scan has been configured.
3802:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxSEFLAG.SEV0.
3803:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3804:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3805:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueClearReqSrcEvent()<BR>
3806:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3807:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_QueueTriggerReqSrcEvent(XMC_VADC_GROUP_t *const group_ptr)
3808:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3809:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_QueueTriggerReqSrcEvent:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR
3810:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->SEFLAG |= 1U;
3811:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3812:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3813:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3814:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr Constant pointer to the VADC group
3815:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3816:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3817:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3818:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3819:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Acknowledges the conversion complete request source event.<BR>\n
3820:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will clear the request source event that occurred. This will clear a interrupt if it wa
3821:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxSEFCLR.SEV0.
3822:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3823:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3824:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueTriggerReqSrcEvent()<BR>
3825:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3826:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_QueueClearReqSrcEvent(XMC_VADC_GROUP_t *const group_ptr)
3827:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3828:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_QueueClearReqSrcEvent:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(g
3829:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->SEFCLR = (uint32_t)VADC_G_SEFCLR_SEV0_Msk;
3830:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3831:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3832:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3833:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr Constant pointer to the VADC group
3834:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3835:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *   bool   returns true if the service request event is raised.
3836:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *          returns false if the service request event was not raised.
3837:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3838:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3839:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Determines if the request source event is asserted.<BR>
3840:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will get the status of the queue request source event. Will return a true
3841:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * if the event has occurred for queue. A call to this API would acces the register bit field  GxSE
3842:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3843:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3844:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  None.
3845:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3846:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE bool XMC_VADC_GROUP_QueueGetReqSrcEventStatus(XMC_VADC_GROUP_t *const group_ptr)
3847:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3848:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3849:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_QueueGetReqSrcEventStatus:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_P
3850:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   return(group_ptr->SEFLAG & (uint32_t)VADC_G_SEFLAG_SEV0_Msk);
3851:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3852:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3853:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3854:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr Constant pointer to the VADC group
3855:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param sr     The service request line (Common SR lines, Group specific SR lines)
3856:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3857:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3858:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3859:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3860:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Connects the event to the SR line of VADC.<BR>\n
3861:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will connect a Service Request line(SR) to a queue request source event. Hence to get a
3862:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Service request line one has to enable the required NVIC node. A call to this API would configur
3863:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * bit field GxSEVNP.SEVNP0.
3864:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3865:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3866:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  None.
3867:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3868:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode(XMC_VADC_GROUP_t *const group_ptr, const XMC_V
3869:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3870:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3871:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
3872:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3873:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3874:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3875:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3876:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the trigger for queue request source.<BR>\n
3877:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * By using this API the trigger will be activated for the queue request source. The trigger signal
3878:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * edge will be selected from the QCTRL register. The Selection of a input will be done by
3879:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_QueueSelectTrigger(). A call to this API would configure the register bit field G
3880:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3881:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3882:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueSelectTrigger()<BR> XMC_VADC_GROUP_QueueDisableExternalTrigger()<BR>
3883:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3884:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_QueueEnableExternalTrigger(XMC_VADC_GROUP_t *const group_ptr)
3885:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3886:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_QueueEnableExternalTrigger:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_
3887:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3888:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->QMR0 |= (uint32_t)VADC_G_QMR0_ENTR_Msk;
3889:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3890:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3891:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3892:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
3893:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3894:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3895:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3896:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3897:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the trigger for queue request source.<BR>
3898:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * By using this API the trigger will be deactivated for the queue request source.
3899:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This will just deactivate the H/W trigger for the queue request source. If any configuration was
3900:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * to select the trigger input in GxQCTRL0 will be not be effected.  A call to this API would confi
3901:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * register bit field GxQMR0.ENTR
3902:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3903:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3904:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GROUP_QueueEnableExternalTrigger()<BR>
3905:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3906:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_QueueDisableExternalTrigger(XMC_VADC_GROUP_t *const group_ptr)
3907:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
3908:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_QueueDisableExternalTrigger:Wrong Group Pointer", XMC_VADC_CHECK_GROUP
3909:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3910:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->QMR0 &= ~((uint32_t)VADC_G_QMR0_ENTR_Msk);
3911:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
3912:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
3913:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3914:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
3915:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3916:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr  Constant pointer to the VADC group
3917:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num  The channel being initialized
3918:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                <BR>Range: [0x0 to 0x7]
3919:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config  Pointer to initialization data
3920:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3921:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3922:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3923:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3924:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes the ADC channel for conversion.<BR>\n
3925:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will do the channel related initializations. This includes configuration of the CHCTR s
3926:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * and boundary flag settings. This must be called in the application in order to enable the conver
3927:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * a channel. After a request source has been initialized this API has to be called for each channe
3928:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * has to be converted.  A call to this API would configure the registers GxCHCTR GxBFL GxALIAS GxC
3929:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * GxBFLC(depending on device) in order to configure the channel.
3930:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3931:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3932:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  None.
3933:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3934:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_ChannelInit(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_num,
3935:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                         const XMC_VADC_CHANNEL_CONFIG_t *config);
3936:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3937:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3938:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr    Constant pointer to the VADC group
3939:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param src_ch_num   Channel which will be converted by \b alias_ch_num, when called by the reque
3940:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                     <BR>Range:[0x0 to 0x7]
3941:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param alias_ch_num This is the alias channel (Ch-0 or Ch-1)
3942:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                     <BR>Range:[0x0, 0x1]
3943:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3944:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3945:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3946:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3947:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Sets the Alias channel(\b alias_ch_num) to convert from the source channel(\b src_ch_num).<BR>\n
3948:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * When a alias configuration takes place the request source(queue/scan/background) will not call c
3949:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The Request sources will call the channel \b alias_ch_num , this would invoke the conversion of
3950:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the pin associated with \b src_ch_num. The configuration of the alias channel (\b alias_ch_num) 
3951:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * for the conversion.\n
3952:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * When an alias channel (Ch-0 or Ch-1) receives a trigger, it converts the aliased channel (\b src
3953:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The properties of Ch-0 or Ch-1 (as indicated in \b alias_ch_num ) apply when \b src_ch_num is co
3954:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  A call to this API would configure the register GxALIAS.
3955:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3956:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Note:</b><br>
3957:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Alias Channel (\b alias_ch_num) and the source channel (\b src_ch_num) cannot be the same.
3958:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * If they are, that alias feature is not used for the conversion. In order to Reset the alias
3959:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * feature that was previously selected this method can be used.
3960:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3961:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3962:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  None.
3963:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3964:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_SetChannelAlias(XMC_VADC_GROUP_t *const group_ptr,
3965:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                     const uint32_t src_ch_num,
3966:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                     const uint32_t alias_ch_num);
3967:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3968:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3969:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr    Constant pointer to the VADC group
3970:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num  Channel whose input was converted
3971:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                <BR>Range: [0x0 to 0x7]
3972:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3973:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *   bool  Returns true if there was violation w.r.t the specified boundaries.
3974:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3975:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3976:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Determines if the result of the channel confines with the specified boundaries.<BR>\n
3977:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * An application may not necessarily always need to know the exact value of the converted result, 
3978:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * an indication if the generated result is within stipulated boundaries. Generation of Channel eve
3979:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * to channel event generation criteria (Generate always, Never generate, Generate if result is out
3980:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Generate if result is within bounds). When interrupts are not enabled, this API can be used to d
3981:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * nature of the result.  A call to this API would access the registers GxCHCTR and GxCEFLAG in ord
3982:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * if a violation has occured.
3983:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3984:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
3985:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
3986:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
3987:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** bool XMC_VADC_GROUP_ChannelIsResultOutOfBounds(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch
3988:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
3989:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
3990:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr    Constant pointer to the VADC group
3991:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num  Channel whose input is to be converted
3992:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                <BR>Range: [0x0 to 0x7]
3993:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ref     Reference voltage
3994:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
3995:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
3996:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
3997:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
3998:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Selects the reference voltage for conversion.<BR>\n
3999:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * An internal voltage reference (VARef) or an external voltage reference fed to Ch-0 can serve as 
4000:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * for conversions.  A call to this API would configure the register bit field GxCHCTR.REFSEL.
4001:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4002:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
4003:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None.
4004:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
4005:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_ChannelSetInputReference(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_n
4006:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                            const XMC_VADC_CHANNEL_REF_t ref);
4007:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4008:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
4009:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
4010:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num   Channel whose i/p is to be converted
4011:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                <BR>Range: [0x0 to 0x7]
4012:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param result_reg_num  Result Register associated with this channel
4013:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
4014:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
4015:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4016:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
4017:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Selects the target result register.<BR>\n
4018:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * There are upto 16 result registers which a channel can choose from to store the results of conve
4019:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This selects only the group related result registers. A call to this API would configure the reg
4020:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * bit field GxCHCTR.RESREG.
4021:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4022:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
4023:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None.
4024:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
4025:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_ChannelSetResultRegister(XMC_VADC_GROUP_t *const group_ptr,
4026:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                              const uint32_t ch_num,
4027:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                              const uint32_t result_reg_num);
4028:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4029:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
4030:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
4031:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num   Channel whose conversion class is to be configured
4032:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                <BR>Range: [0x0 to 0x7]
4033:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param conversion_class  conversion property to be associated with this channel
4034:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
4035:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
4036:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4037:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
4038:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Selects the conversion class registers.<BR>\n
4039:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * It configures the channel to have a particular conversion class properties like sampling
4040:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * time and resolution.  A call to this API would configure the register
4041:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * bit field GxCHCTR.ICLSEL.
4042:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4043:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
4044:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_ChannelGetInputClass().
4045:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
4046:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_ChannelSetIclass(XMC_VADC_GROUP_t *const group_ptr,
4047:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                      const uint32_t ch_num,
4048:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                      const XMC_VADC_CHANNEL_CONV_t conversion_class); 
4049:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4050:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
4051:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
4052:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num   Channel whose result alignment is to be returned
4053:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                <BR>Range: [0x0 to 0x7]
4054:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
4055:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    XMC_VADC_RESULT_ALIGN_LEFT if the result are aligned to the left
4056:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    XMC_VADC_RESULT_ALIGN_RIGHT if the result are aligned to the right
4057:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4058:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
4059:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Returns the channel result alignment.<BR>\n
4060:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The results are aligned either to the left or to the right. A left aligned 10bit resolution has 
4061:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * at bit2 where as a left aligned 8bit resolution starts at bit4. A call to this API would return 
4062:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * configured alignment value.
4063:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would read the register bit field GxCHCTR.RESPOS.
4064:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4065:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
4066:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None.
4067:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
4068:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE XMC_VADC_RESULT_ALIGN_t XMC_VADC_GROUP_ChannelGetResultAlignment(XMC_VADC_GROUP_t *
4069:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                      const uint32_t ch_num) 
4070:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
4071:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ChannelGetResultAlignment:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_P
4072:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ChannelGetResultAlignment:Wrong Channel Number",
4073:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****              ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
4074:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4075:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   return ((XMC_VADC_RESULT_ALIGN_t)((group_ptr->CHCTR[ch_num] & (uint32_t)VADC_G_CHCTR_RESPOS_Msk) 
4076:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 		  (uint32_t)VADC_G_CHCTR_RESPOS_Pos) );
4077:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
4078:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4079:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4080:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
4081:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
4082:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num   Channel whose result alignment is to be returned
4083:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                <BR>Range: [0x0 to 0x7]
4084:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
4085:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    XMC_VADC_CHANNEL_CONV_t Returns the configured input class for the \b ch_num
4086:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4087:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
4088:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Returns the channel's input class for conversion for the required channel.<BR>\n
4089:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The sampling time and resolution can be taken from any of the 4 possible Input class registers.
4090:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would return the input class register that is taken up by \b ch_num for conversion.
4091:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would read the register bit field GxCHCTR.RESPOS.
4092:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4093:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
4094:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_ChannelSetIclass().
4095:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
4096:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE XMC_VADC_CHANNEL_CONV_t XMC_VADC_GROUP_ChannelGetInputClass(XMC_VADC_GROUP_t *const
4097:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                      const uint32_t ch_num) 
4098:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
4099:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ChannelGetInputClass:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(gr
4100:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ChannelGetInputClass:Wrong Channel Number",
4101:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****              ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
4102:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4103:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   return ((XMC_VADC_CHANNEL_CONV_t)((group_ptr->CHCTR[ch_num] & (uint32_t)VADC_G_CHCTR_ICLSEL_Msk) 
4104:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 		  (uint32_t)VADC_G_CHCTR_ICLSEL_Pos) );
4105:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
4106:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4107:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
4108:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4109:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
4110:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num   Channel whose associated result register is to be found
4111:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                <BR>Range: [0x0 to 0x7]
4112:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
4113:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  uint8_t  returns the Group result register to which it is linked to.
4114:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *           <BR>Range: [0x0 to 0xF]
4115:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4116:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
4117:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Returns the result register associated with this channel.<br>\n
4118:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  There are upto 16 result registers which a channel can choose from to store the results of conv
4119:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  This returns only the group related result registers.  A call to this API would access the regi
4120:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * bit field GxCHCTR.RESREG.
4121:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4122:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
4123:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None.
4124:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
4125:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** uint8_t XMC_VADC_GROUP_ChannelGetResultRegister(XMC_VADC_GROUP_t *const group_ptr, const uint32_t c
4126:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4127:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
4128:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
4129:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num   Channel whose channel event is to be asserted
4130:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                <BR>Range: [0x0 to 0x7]
4131:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
4132:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
4133:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4134:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
4135:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Manually asserts a Channel event.<BR>\n
4136:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * It is merely the channel event which is asserted. For this asserted event to lead to an interrup
4137:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * have been bound to an SR and that SR must have been enabled. It can potentially lead to an inter
4138:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * SR line is connected to an NVIC node.  A call to this API would configure the register bit field
4139:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4140:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
4141:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_ChannelClearEvent().
4142:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
4143:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_ChannelTriggerEvent(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_num);
4144:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4145:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
4146:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
4147:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num   Channel whose channel event is to be acknowledged
4148:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                <BR>Range: [0x0 to 0x7]
4149:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
4150:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
4151:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4152:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
4153:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Acknowledges a Channel event.<BR>\n
4154:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * When a channel event is raised after the conversion of that channel, it has to be cleared. This 
4155:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the Channel event of a particular channel if it has occurred.  A call to this API would configur
4156:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * bit fields of GxCEFCLR.
4157:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4158:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
4159:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_ChannelTriggerEvent().
4160:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
4161:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_ChannelClearEvent(XMC_VADC_GROUP_t *const group_ptr, const uint
4162:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
4163:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4164:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ChannelClearEvent:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group
4165:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ChannelClearEvent:Wrong Channel Number", ((ch_num) < XMC_VADC_NUM_CHAN
4166:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->CEFCLR = (uint32_t)((uint32_t)1 << ch_num);
4167:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
4168:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4169:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
4170:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
4171:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num   Channel whose channel event is to be connected to a service request line
4172:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                <BR>Range: [0x0 to 0x7]
4173:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param sr       The service request line to which the channel event is to be connected
4174:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
4175:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
4176:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4177:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
4178:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Binds a channel event to a requested Service Request line.<BR>\n
4179:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The channel event is connected to a service request line. For an event to result in an interrupt
4180:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * request line must be enabled in VADC and the NVIC node which this service request line is connec
4181:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * interrupt generation enabled.  A call to this API would configure the register bit fields of GxC
4182:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4183:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
4184:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_ChannelTriggerEvent()<BR> XMC_VADC_GROUP_ChannelClearEvent()
4185:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
4186:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_ChannelSetEventInterruptNode(XMC_VADC_GROUP_t *const group_ptr,
4187:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                  const uint32_t ch_num,
4188:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                  const XMC_VADC_SR_t sr);
4189:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4190:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
4191:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
4192:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num   Channel whose channel event is being configured
4193:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                <BR>Range: [0x0 to 0x7]
4194:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param criteria The condition under which the channel may assert its channel event
4195:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
4196:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
4197:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4198:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
4199:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the conditions under which a channel may assert its channel event.<BR>\n
4200:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The channel event can be generated under the following conditions - Always, Never, Result Out of
4201:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * inside the boundaries.  A call to this API would configure the register bit field GxCHCTR.CHEVMO
4202:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4203:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
4204:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_ChannelTriggerEvent()<BR> XMC_VADC_GROUP_ChannelClearEvent()<BR>
4205:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_ChannelSetEventInterruptNode()<BR>
4206:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
4207:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_ChannelTriggerEventGenCriteria(XMC_VADC_GROUP_t *const group_ptr,
4208:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                    const uint32_t ch_num,
4209:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                    const XMC_VADC_CHANNEL_EVGEN_t criteria);
4210:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4211:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4212:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
4213:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
4214:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param ch_num   Channel whose channel event is being configured
4215:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                <BR>Range: [0x0 to 0x7]
4216:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param boundary_sel Select the upper/lower boundary configuration .
4217:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param selection The boundary value selected for \b boundary_sel.
4218:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
4219:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
4220:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4221:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
4222:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configure the boundary selection for the given channel<BR>\n
4223:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The channel event can be generated under the following conditions - Always, Never, Result Out of
4224:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * inside the boundaries. The boundary values to which results are compared can be selected from se
4225:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxCHCTR.BNDSELL or GxCHCTR.BNDSELU  .
4226:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4227:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
4228:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None.
4229:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
4230:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void  XMC_VADC_GROUP_ChannelSetBoundarySelection(XMC_VADC_GROUP_t *const group_ptr,
4231:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                  const uint32_t ch_num,
4232:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                  XMC_VADC_BOUNDARY_SELECT_t boundary_sel,
4233:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                  XMC_VADC_CHANNEL_BOUNDARY_t selection);
4234:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4235:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
4236:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr   Constant pointer to the VADC group
4237:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param res_reg_num  Result register which is intended to be initialized
4238:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                     <BR>Range: [0x0 to 0xF]
4239:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config       Pointer to initialization data
4240:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
4241:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
4242:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4243:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
4244:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes a Group Result Register.<BR>
4245:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Various options needed for the working of the result result will be configured with this API.
4246:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This would determine the result handling of the group registers. This API must be called after
4247:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the channel Init (XMC_VADC_GROUP_ChannelInit())to initialize the result register that is selecte
4248:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would also determine if the result register that is being configured has to a part of a
4249:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * In this API one can also configure the various result handling options line FIR/IIR filters and 
4250:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Also configures the Data reduction to accumulate 2/3/4 results need to be done. This API will al
4251:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * the result event generation.  A call to this API would configure the register GxRCR with the \b 
4252:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4253:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
4254:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_AddResultToFifo()<BR> XMC_VADC_GROUP_EnableResultEvent()<br> XMC_VADC_GROUP_Disab
4255:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
4256:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_ResultInit(XMC_VADC_GROUP_t *const group_ptr,
4257:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                const uint32_t res_reg_num,
4258:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                const XMC_VADC_RESULT_CONFIG_t *config)
4259:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
4260:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_ResultInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
4261:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->RCR[res_reg_num] = config->g_rcr;
4262:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4263:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
4264:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4265:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4266:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
4267:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
4268:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param res_reg  Register which is required to be a part of results FIFO
4269:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                 <BR>Range: [0x0 to 0xF]
4270:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
4271:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
4272:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4273:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
4274:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Adds result register to Result FIFO.<BR>\n
4275:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Sometimes, the rate of consumption of results by application software may not match the rate at 
4276:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * results are produced. A Result FIFO thus helps a slow consumer to read out results without loss 
4277:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * When a result register is added to fifo, it is in fact chained to its higher numbered neighbor. 
4278:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Result Register-5 is to be added to FIFO, it gets chained to Result Register-6. Results are writ
4279:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * while the same can be read out of Register-5 leisurely by software.
4280:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxRCR.FEN.
4281:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4282:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Note:</b><br>
4283:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The FIFO is always read by the software with the lowest numbered result register.
4284:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The hardware will write the results from the highest numbered result register.
4285:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4286:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
4287:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * None.
4288:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
4289:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GROUP_AddResultToFifo(XMC_VADC_GROUP_t *const group_ptr, const uint32_t res_reg);
4290:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4291:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
4292:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
4293:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param res_reg  Result Register for which event generation is to be enabled
4294:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                 <BR>Range: [0x0 to 0xF]
4295:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
4296:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
4297:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4298:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
4299:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables result event generation.<BR>\n
4300:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Once the results of conversion are available, the result event (which is being enabled in this f
4301:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * if connected to a service request line(Group or Shared service request) can lead to an interrupt
4302:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * not only necessary to enable the event, but also to connect it to a service request line. The
4303:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * service request generation capability must also be enabled and so should the corresponding NVIC 
4304:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxRCR.SRGEN.
4305:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4306:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
4307:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_SetResultInterruptNode().
4308:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
4309:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_EnableResultEvent(XMC_VADC_GROUP_t *const group_ptr, const uint
4310:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
4311:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4312:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_EnableResultEvent:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group
4313:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_EnableResultEvent:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RE
4314:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->RCR[res_reg] |= (uint32_t)VADC_G_RCR_SRGEN_Msk;
4315:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
4316:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4317:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
4318:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
4319:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param res_reg  Result Register for which event generation is to be disabled
4320:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                 <BR>Range: [0x0 to 0xF]
4321:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
4322:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    None
4323:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4324:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
4325:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disable result event generation.<BR>\n
4326:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This would just disable the event. It would not alter anything w.r.t the SR line if it was confi
4327:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * A call to this API would configure the register bit field GxRCR.SRGEN.
4328:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4329:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
4330:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_EnableResultEvent().
4331:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
4332:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GROUP_DisableResultEvent(XMC_VADC_GROUP_t *const group_ptr, const uin
4333:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
4334:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_DisableResultEvent:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(grou
4335:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_DisableResultEvent:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_R
4336:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   group_ptr->RCR[res_reg] &= ~((uint32_t)VADC_G_RCR_SRGEN_Msk);
4337:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
4338:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4339:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
4340:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
4341:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param res_reg  Result Register from which the result of conversion is to be read out
4342:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                 <BR>Range: [0x0 to 0xF]
4343:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
4344:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    uint32_t  returns the complete result register GxRESy.
4345:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4346:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
4347:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Returns the result register completely (result of conversion as well as other info).<BR>\n
4348:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * The Result register will have information regarding the channel that is requesting the conversio
4349:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * if the result is valid, if the fast compare bit, Data Reduction Counter, and the request source 
4350:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * All these information will be returned back. And if the user is polling for the result he can us
4351:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * result if the valid bit is set. A call to this API would return the complete register GxRES.
4352:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4353:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
4354:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_GetResult().
4355:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
4356:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE uint32_t XMC_VADC_GROUP_GetDetailedResult(XMC_VADC_GROUP_t *const group_ptr, const 
4357:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
4358:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_GetDetailedResult:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group
4359:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_GetDetailedResult:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RE
4360:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   return(group_ptr->RES[res_reg]);
4361:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
4362:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4363:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** /**
4364:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_ptr     Constant pointer to the VADC group
4365:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param res_reg  Result Register from which the result of conversion is to be read out
4366:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                 <BR>Range: [0x0 to 0xF]
4367:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return
4368:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *    XMC_VADC_RESULT_SIZE_t Result register values.
4369:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *                <BR>Range:[ 0x0 to 0xFFF] (Result of single conversion. Accumulated results not c
4370:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4371:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
4372:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * Returns the result of the conversion.<BR>\n
4373:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API will only return the result of the conversion and will strip out the other information 
4374:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * in the result register. A call to this API would access the register bit field GxRES.RESULT.
4375:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  *
4376:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><br>
4377:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GROUP_GetDetailedResult().
4378:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****  */
4379:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE XMC_VADC_RESULT_SIZE_t XMC_VADC_GROUP_GetResult(XMC_VADC_GROUP_t *const group_ptr, 
4380:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****                                                                 const uint32_t res_reg)
4381:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** {
 180              	 .loc 3 4381 0
 181              	 .cfi_startproc
 182 0000 80B5     	 push {r7,lr}
 183              	.LCFI12:
 184              	 .cfi_def_cfa_offset 8
 185              	 .cfi_offset 7,-8
 186              	 .cfi_offset 14,-4
 187 0002 82B0     	 sub sp,sp,#8
 188              	.LCFI13:
 189              	 .cfi_def_cfa_offset 16
 190 0004 00AF     	 add r7,sp,#0
 191              	.LCFI14:
 192              	 .cfi_def_cfa_register 7
 193 0006 7860     	 str r0,[r7,#4]
 194 0008 3960     	 str r1,[r7]
4382:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_GetResult:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
4383:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GROUP_GetResult:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REG
4384:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** 
4385:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h ****   return ((XMC_VADC_RESULT_SIZE_t)group_ptr->RES[res_reg]);
 195              	 .loc 3 4385 0
 196 000a 7B68     	 ldr r3,[r7,#4]
 197 000c 3A68     	 ldr r2,[r7]
 198 000e C032     	 add r2,r2,#192
 199 0010 9200     	 lsl r2,r2,#2
 200 0012 D358     	 ldr r3,[r2,r3]
 201 0014 9BB2     	 uxth r3,r3
4386:C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc\xmc_vadc.h **** }
 202              	 .loc 3 4386 0
 203 0016 181C     	 mov r0,r3
 204 0018 BD46     	 mov sp,r7
 205 001a 02B0     	 add sp,sp,#8
 206              	 
 207 001c 80BD     	 pop {r7,pc}
 208              	 .cfi_endproc
 209              	.LFE234:
 211 001e C046     	 .section .text.ADC_MEASUREMENT_ADV_GetResult,"ax",%progbits
 212              	 .align 2
 213              	 .code 16
 214              	 .thumb_func
 216              	ADC_MEASUREMENT_ADV_GetResult:
 217              	.LFB238:
 218              	 .file 4 "C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV/adc_measurement_adv.h"
   1:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
   2:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @file adc_measure_adv.h
   3:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @date 2016-04-26
   4:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
   5:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * NOTE:
   6:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * This file is generated by DAVE. Any manual modification done to this file will be lost when the 
   7:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
   8:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @cond
   9:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  **************************************************************************************************
  10:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * ADC_MEASUREMENT_ADV v4.0.10 - Incorporates advanced features of the Versatile Analog to Digital 
  11:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *                               to measure analog inputs.
  12:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
  13:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * Copyright (c) 2016, Infineon Technologies AG
  14:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * All rights reserved.
  15:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
  16:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  17:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * following conditions are met:
  18:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
  19:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  20:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   disclaimer.
  21:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
  22:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  23:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   following disclaimer in the documentation and/or other materials provided with the distributio
  24:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
  25:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  26:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   products derived from this software without specific prior written permission.
  27:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
  28:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  29:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  30:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  31:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  32:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  33:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  34:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  35:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
  36:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  37:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * with Infineon Technologies AG (dave@infineon.com).
  38:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  **************************************************************************************************
  39:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
  40:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * Change History
  41:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * --------------
  42:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
  43:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * 2015-10-09:
  44:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *     - Initial version for DAVEv4.<BR>
  45:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
  46:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * 2015-10-20:
  47:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *     - Documentation updated.<BR>
  48:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
  49:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * 2015-12-15:
  50:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *     - Added support for XMC4300 devices.<BR>
  51:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
  52:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * 2016-01-18:
  53:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *     - 1.Internal consumption of request source.<BR>
  54:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *     - 2.Support for synchronized conversion reduced from 8 master channels to 4 .<BR>
  55:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *     - 3.Converted the SetBoundary() API from public API to private API .<BR>
  56:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *     - 4.Updated all APIs for the Internal consumption of request source.<BR>
  57:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
  58:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * 2016-02-05:
  59:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *     - Documentation updated.<BR>
  60:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
  61:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * 2016-03-18:
  62:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *     - Added consumption of the GLOBAL ICLASS -1 for Sync. Conversions.<BR>
  63:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *     - Added consumption of the result register-0 for subtraction mode.<BR>
  64:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *     - Removed ADC_MEASUREMENT_ADV_SetUniformConversion().<BR>
  65:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *     - New API ADC_MEASUREMENT_ADV_SetIclass() added to configure the GLOBAL ICLASS for Slaves. <
  66:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
  67:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * 2016-04-26:
  68:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *     - The synchronized conversion in a master slave configuration is currently not supported.<BR
  69:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
  70:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @endcond
  71:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
  72:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
  73:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
  74:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /*CODE_BLOCK_BEGIN*/
  75:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #ifndef ADC_MEASUREMENT_ADV_H
  76:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #define ADC_MEASUREMENT_ADV_H
  77:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
  78:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
  79:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**************************************************************************************************
  80:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * HEADER FILES
  81:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  **************************************************************************************************
  82:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
  83:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #include "GLOBAL_ADC/global_adc.h"
  84:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #include "adc_measurement_adv_conf.h"
  85:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
  86:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  /*************************************************************************************************
  87:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * MACROS
  88:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  **************************************************************************************************
  89:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
  90:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****        (XMC_LIB_MINOR_VERSION >= 1U) && \
  91:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****        (XMC_LIB_PATCH_VERSION >= 4U)))
  92:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #error "ADC_MEASUREMENT_ADV requires XMC Peripheral Library v2.1.4 or higher"
  93:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
  94:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  /*************************************************************************************************
  95:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * ENUMS
  96:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  **************************************************************************************************
  97:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
  98:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @ingroup ADC_MEASUREMENT_ADV_enumerations
  99:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @{
 100:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 101:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**@brief Return value of an API  */
 102:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 103:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** typedef enum ADC_MEASUREMENT_ADV_STATUS
 104:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** {
 105:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_STATUS_SUCCESS = 0,  /**< The API call is successful*/
 106:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_STATUS_FAILURE,      /**< The API call is failed*/
 107:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_STATUS_UNINITIALIZED /**< APP has not been Initialized */
 108:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** } ADC_MEASUREMENT_ADV_STATUS_t;
 109:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 110:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 111:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 112:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @brief The selected Request source.
 113:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 114:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** typedef enum ADC_MEASUREMENT_ADV_REQUEST_SOURCE
 115:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** {
 116:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_REQUEST_SOURCE_SCAN = 0, /**< Uses the ADC_SCAN APP's, scan request source.*/
 117:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN, /**< Uses the internally consumed Scan request sou
 118:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_REQUEST_SOURCE_QUEUE,    /**< Uses the ADC_QUEUE APP's, queue request source.
 119:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_QUEUE,    /**< Uses the internally consumed Queue reques
 120:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** } ADC_MEASUREMENT_ADV_REQUEST_SOURCE_t;
 121:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 122:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 123:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @brief The gain applied on the input signal.
 124:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 125:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** typedef enum ADC_MEASUREMENT_ADV_GAIN
 126:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** {
 127:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_GAIN_1 = 0U,   /**< The gain value of 1:1 is selected*/
 128:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_GAIN_3 = 1U,   /**< The gain value of 1:3 is selected*/
 129:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_GAIN_6 = 2U,   /**< The gain value of 1:6 is selected*/
 130:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_GAIN_12 = 3U   /**< The gain value of 1:12 is selected*/
 131:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** } ADC_MEASUREMENT_ADV_GAIN_t;
 132:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 133:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 134:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @brief Alignment options for the subtraction value
 135:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 136:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** typedef enum ADC_MEASUREMENT_ADV_SUBTRATION
 137:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** {
 138:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_SUBTRATION_12BIT_LEFT_ALIGN  = 0U,     /**< Always align result to left */
 139:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_SUBTRATION_12BIT_RIGHT_ALIGN = 0U,     /**< Always align result to right */
 140:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_SUBTRATION_10BIT_LEFT_ALIGN  = 2U,     /**< Always align result to left */
 141:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_SUBTRATION_10BIT_RIGHT_ALIGN = 0U,     /**< Always align result to right */
 142:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_SUBTRATION_8BIT_LEFT_ALIGN   = 4U,     /**< Always align result to left */
 143:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_SUBTRATION_8BIT_RIGHT_ALIGN  = 0U      /**< Always align result to right */
 144:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** } ADC_MEASUREMENT_ADV_SUBTRATION_t;
 145:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 146:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 147:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @brief The result of the fast compare operation.
 148:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 149:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** typedef enum ADC_MEASUREMENT_ADV_FAST_COMPARE
 150:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** {
 151:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_FAST_COMPARE_LOW     = 0U, /**< The result of fast conversion is low.*/
 152:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_FAST_COMPARE_HIGH    = 1U, /**< The result of fast conversion is high.*/
 153:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_FAST_COMPARE_INVALID = 2U  /**< The result is invalid since no new results ar
 154:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** } ADC_MEASUREMENT_ADV_FAST_COMPARE_t;
 155:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 156:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 157:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @}
 158:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 159:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 160:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**************************************************************************************************
 161:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** * DATA STRUCTURES
 162:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** ***************************************************************************************************
 163:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 164:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @ingroup ADC_MEASUREMENT_ADV_datastructures
 165:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @{
 166:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 167:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /*Anonymous structure/union guard start*/
 168:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #if defined(__CC_ARM)
 169:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   #pragma push
 170:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   #pragma anon_unions
 171:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #elif defined(__TASKING__)
 172:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   #pragma warning 586
 173:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 174:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 175:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** typedef void (*ADC_MEASUREMENT_ADV_EVENT_CONFIG_t)(void); /**< Function pointer to the mux configur
 176:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 177:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 178:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @brief NVIC Configuration structure for request source interrupt.
 179:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 180:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** typedef struct ADC_MEASUREMENT_ADV_NVIC_CONFIG
 181:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** {
 182:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   uint32_t node_id;    /**< This indicates the NVIC Node number.*/
 183:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 184:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   uint32_t priority;   /**< This indicates the NVIC priority.*/
 185:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #if(UC_FAMILY == XMC4)
 186:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   uint32_t sub_priority; /**< This indicates the NVIC sub priority in XMC4x Devices.*/
 187:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 188:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   bool interrupt_enable; /**< This flag indicates if a Interrupt has been requested.*/
 189:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #ifdef ADC_MEASUREMENT_ADV_NON_DEFAULT_IRQ_SOURCE_SELECTED
 190:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   uint8_t irqctrl;       /**< This indicates the service request source selected for the consumed N
 191:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 192:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** } ADC_MEASUREMENT_ADV_NVIC_CONFIG_t;
 193:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 194:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
 195:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 196:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @brief Configuration Data structure of scan request source.
 197:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 198:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** typedef struct ADC_MEASUREMENT_ADV_SCAN
 199:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** {
 200:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const ADC_MEASUREMENT_ADV_NVIC_CONFIG_t rs_intr_handle;    /**< Holds the ISR Handle*/
 201:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 202:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const XMC_VADC_GROUP_CLASS_t iclass_config_handle;         /**< Holds the ICLASS Configurations*/
 203:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 204:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const XMC_VADC_SCAN_CONFIG_t *const scan_config_handle;    /**< Holds the LLD SCAN Structure*/
 205:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 206:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const XMC_VADC_GATEMODE_t gating_mode;         /**< Gating mode configuration needed for Scan req
 207:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 208:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const XMC_VADC_SR_t srv_req_node;              /**< Source event interrupt node pointer*/
 209:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 210:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const uint32_t  insert_mask;                  /**< Insert Mask for the scan request source*/
 211:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 212:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const uint8_t iclass_num;                      /**< Holds the ICLASS ID either ICLASS-0 or ICLASS
 213:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 214:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** } ADC_MEASUREMENT_ADV_SCAN_t;
 215:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 216:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 217:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
 218:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 219:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @brief Configuration Data structure of queue request source.
 220:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 221:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** typedef struct ADC_MEASUREMENT_ADV_QUEUE
 222:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** {
 223:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const ADC_MEASUREMENT_ADV_NVIC_CONFIG_t rs_intr_handle;    /**< Holds the ISR Handle*/
 224:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 225:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const XMC_VADC_GROUP_CLASS_t iclass_config_handle;         /**< Holds the ICLASS Configurations*/
 226:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 227:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const XMC_VADC_QUEUE_CONFIG_t *const queue_config_handle;    /**< Holds the LLD QUEUE Structure*/
 228:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 229:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const XMC_VADC_GATEMODE_t gating_mode;         /**< Gating mode configuration needed for Scan req
 230:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 231:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const XMC_VADC_SR_t srv_req_node;              /**< Source event interrupt node pointer*/
 232:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 233:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const uint8_t iclass_num;                      /**< Holds the ICLASS ID either ICLASS-0 or ICLASS
 234:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 235:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** } ADC_MEASUREMENT_ADV_QUEUE_t;
 236:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 237:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 238:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 239:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 240:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * Structure to configure the channels in the ADC_MEASUREMENT_ADV APP.
 241:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 242:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** typedef struct ADC_MEASUREMENT_ADV_CHANNEL
 243:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** {
 244:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   XMC_VADC_CHANNEL_CONFIG_t *ch_handle; /**< This holds the VADC Channel LLD structures*/
 245:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 246:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   XMC_VADC_RESULT_CONFIG_t *res_handle[ADC_MEASUREMENT_ADV_RESULT_REG]; /**< This hold the VADC LLD
 247:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****                                                                               configuration structu
 248:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 249:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #ifdef ADC_MEASUREMENT_ADV_ANALOG_IO_USED
 250:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ANALOG_IO_t   *analog_io_config;    /**< This hold the address of the ANALOG_IO configuration str
 251:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 252:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 253:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #ifdef ADC_MEASUREMENT_ADV_FIFO_USED
 254:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   uint8_t max_fifo_required;             /**< The required number of FIFO elements*/
 255:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 256:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   uint8_t result_fifo_tail_number;      /**< The tail result register number if FIFO is selected. *
 257:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 258:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   uint8_t group_index;          /**< This holds the group index*/
 259:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 260:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   uint8_t ch_num;             /**< This Holds the Channel Number*/
 261:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 262:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #if(UC_FAMILY == XMC1)
 263:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_GAIN_t shs_gain_factor; /**< The required gain factor for the channel.*/
 264:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 265:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 266:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** } ADC_MEASUREMENT_ADV_CHANNEL_t;
 267:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 268:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 269:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * Structure to configure ADC_MEASUREMENT_ADV APP.
 270:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 271:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** typedef struct ADC_MEASUREMENT_ADV
 272:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** {
 273:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const ADC_MEASUREMENT_ADV_CHANNEL_t **const channel_array;      /**< This holds an array of chann
 274:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****                                                               by the current instance of the ADC_ME
 275:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #if defined(ADC_MEASUREMENT_ADV_ADC_SCAN_USED) || defined(ADC_MEASUREMENT_ADV_ADC_QUEUE_USED) || \
 276:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 	defined(ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED)
 277:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   union
 278:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   {
 279:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
 280:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const ADC_SCAN_ENTRY_t **const scan_entries;   /**< Holds the pointer to the scan entries. */
 281:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 282:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #ifdef ADC_MEASUREMENT_ADV_ADC_QUEUE_USED
 283:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const ADC_QUEUE_ENTRY_t **const queue_entries;  /**< Holds the pointer to the queue entries.*/
 284:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 285:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
 286:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const XMC_VADC_QUEUE_ENTRY_t **const local_queue_entries;  /**< Holds the pointer to the queue en
 287:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 288:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   };
 289:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 290:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 291:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_EVENT_CONFIG_t event_config; /**< This hold the pointer to the function
 292:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****                                                       that does mux configuration. Which entails ch
 293:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****                                                       result node configuration*/
 294:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   union
 295:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   {
 296:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
 297:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     ADC_SCAN_t *const scan_handle;     /**< Pointer to the ADC_SCAN APP handle*/
 298:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 299:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #ifdef ADC_MEASUREMENT_ADV_ADC_QUEUE_USED
 300:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     ADC_QUEUE_t *const queue_handle;   /**< Pointer to the ADC_QUEUE APP handle*/
 301:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 302:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
 303:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     ADC_MEASUREMENT_ADV_SCAN_t *const local_scan_handle;   /**< Pointer to the scan handle*/
 304:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 305:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
 306:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     ADC_MEASUREMENT_ADV_QUEUE_t *const local_queue_handle;   /**< Pointer to the queue handle*/
 307:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 308:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   };
 309:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 310:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_STATUS_t *init_state;   /**< This enumeration gives information about the sta
 311:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 312:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_REQUEST_SOURCE_t req_src; /**< The request source used by this instance of
 313:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****                                                       the ADC_MEASUREMENT_ADV APP */
 314:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 315:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #ifdef ADC_MEASUREMENT_ADV_SYNC_USED
 316:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   union
 317:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   {
 318:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     struct
 319:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     {
 320:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****       uint8_t sync_slave_g0 :1; /**< If set the group-0 will be configured as the slave group.*/
 321:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****       uint8_t sync_slave_g1 :1; /**< If set the group-1 will be configured as the slave group*/
 322:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****       uint8_t sync_slave_g2 :1; /**< If set the group-2 will be configured as the slave group*/
 323:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****       uint8_t sync_slave_g3 :1; /**< If set the group-3 will be configured as the slave group*/
 324:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****       uint8_t               :4;
 325:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     };
 326:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     uint8_t sync_slaves;
 327:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   };
 328:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 329:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 330:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const uint8_t group_index; /**< The group index number for the APP*/
 331:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 332:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const uint8_t total_number_of_entries; /**< Indicates the total number of entries configured in
 333:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****                                               the current APP instance*/
 334:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 335:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const uint8_t total_number_of_channels; /**< Indicates the total number of channels configured in
 336:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****                                                the current APP instance*/
 337:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 338:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const bool start_at_initialization; /**< This determines if the insertion of the queue or
 339:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****                                             scan entries should happen after initialization of the 
 340:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #ifdef ADC_MEASUREMENT_ADV_SYNC_USED
 341:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   const bool configure_globiclass1;  /**< Copy the master channels conversion parameters to the glo
 342:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****                                           Hence the slave channels are using the same features as t
 343:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 344:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** } ADC_MEASUREMENT_ADV_t;
 345:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 346:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 347:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @}
 348:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 349:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 350:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /*Anonymous structure/union guard end*/
 351:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #if defined(__CC_ARM)
 352:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   #pragma pop
 353:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #elif defined(__TASKING__)
 354:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   #pragma warning restore
 355:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 356:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 357:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #ifdef __cplusplus
 358:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** extern "C" {
 359:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #endif
 360:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 361:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**************************************************************************************************
 362:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * API Prototypes
 363:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  **************************************************************************************************
 364:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 365:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @ingroup ADC_MEASUREMENT_ADV_apidoc
 366:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @{
 367:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 368:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 369:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 370:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @brief Get ADC_MEASUREMENT_ADV APP version
 371:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 372:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 373:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * \par<b>Description: </b><br>
 374:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * The function can be used to check application software compatibility with a
 375:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * specific version of the APP.
 376:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 377:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * Example Usage:
 378:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 379:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @code
 380:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * #include <DAVE.h>
 381:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 382:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * int main(void) {
 383:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   DAVE_STATUS_t init_status;
 384:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   DAVE_APP_VERSION_t version;
 385:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 386:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   // Initialize ADC_MEASUREMENT_ADV APP:
 387:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   // ADC_MEASUREMENT_ADV_Init() is called from within DAVE_Init().
 388:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   init_status = DAVE_Init();
 389:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 390:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   version = ADC_MEASUREMENT_ADV_GetAppVersion();
 391:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   if (version.major != 1U) {
 392:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *     // Probably, not the right version.
 393:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   }
 394:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 395:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   // More code here
 396:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   while(1) {
 397:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 398:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   }
 399:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *   return (0);
 400:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * }
 401:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @endcode
 402:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 403:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** DAVE_APP_VERSION_t ADC_MEASUREMENT_ADV_GetAppVersion(void);
 404:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 405:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 406:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @brief Starts the VADC request source.
 407:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @param handle_ptr constant pointer to the APP handle structure<BR>
 408:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @return None <BR>
 409:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 410:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * \par<b>Description: </b><br>
 411:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * This API would start the request source of the VADC. After this API is invoked the ADC is ready 
 412:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * conversion requests.
 413:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * If scan request source is selected then this API would write to GxARBPR.ASEN1 bit.
 414:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * If queue request source is selected then this API would write to GxARBPR.ASEN0 bit. At the time 
 415:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * for the queue, If there was queue entry waiting in the queue buffer without waiting for a hardwa
 416:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * start the conversion of such a queue.
 417:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 418:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * Example Usage:
 419:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 420:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @code
 421:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Initialize the ADC_MEASUREMENT_ADV APP. Set the number of required channels to 2.
 422:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Goto interrupts tab enable request source interrupt.
 423:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Goto the ADC_SCAN/ADC_QUEUE APP and enable the request source interrupt.
 424:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Generate the code and build.
 425:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Replace this in the main.c.
 426:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declaratio
 427:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 428:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** uint16_t result[2];
 429:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** void adc_measurement_adv_callback(void)
 430:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** {
 431:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   result[0] = ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_ADV_0_Channel_A);
 432:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   result[1] = ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_ADV_0_Channel_B);
 433:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** }
 434:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 435:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** int main(void)
 436:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** {
 437:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   DAVE_STATUS_t status;
 438:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 439:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   status = DAVE_Init();           // Initialization of DAVE APPs
 440:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 441:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   if(status == DAVE_STATUS_FAILURE)
 442:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   {
 443:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     // Placeholder for error handler code. The while loop below can be replaced with an user error 
 444:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     XMC_DEBUG("DAVE APPs initialization failed\n");
 445:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 446:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     while(1U)
 447:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     {
 448:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 449:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     }
 450:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   }
 451:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 452:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   // Start the selected request source
 453:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_StartADC(&ADC_MEASUREMENT_ADV_0);
 454:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 455:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   while(1U)
 456:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   {
 457:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     // Continuously re-trigger the scan conversion sequence
 458:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     ADC_MEASUREMENT_ADV_SoftwareTrigger(&ADC_MEASUREMENT_ADV_0);
 459:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   }
 460:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** }
 461:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @endcode
 462:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 463:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** void ADC_MEASUREMENT_ADV_StartADC(const ADC_MEASUREMENT_ADV_t *const handle_ptr);
 464:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 465:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 466:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @brief Starts the conversion of the required channels
 467:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @param handle_ptr constant pointer to the APP handle structure<BR>
 468:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @return None <BR>
 469:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 470:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * \par<b>Description: </b><br>
 471:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * Trigger a load event for the required channels thus starting the conversion of the ADC channels.
 472:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * If scan request source is selected then this API would write to GxASMR.LDEV bit, causing the con
 473:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * If queue request source is selected then this API would write to GxQMR0.TREV bit. At the time of
 474:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * for the queue. If there was queue entry waiting in the queue buffer for a hardware trigger, writ
 475:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * triggers the conversion for that entry.
 476:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 477:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * Example Usage:
 478:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 479:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @code
 480:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Initialize the ADC_MEASUREMENT_ADV APP. Set the number of required channels to 2.
 481:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Goto interrupts tab enable request source interrupt.
 482:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Goto the ADC_SCAN/ADC_QUEUE APP and enable the request source interrupt.
 483:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Generate the code and build.
 484:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Replace this in the main.c.
 485:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declaratio
 486:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 487:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** uint16_t result[2];
 488:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** void adc_measurement_adv_callback(void)
 489:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** {
 490:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   result[0] = ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_ADV_0_Channel_A);
 491:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   result[1] = ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_ADV_0_Channel_B);
 492:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** }
 493:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 494:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** int main(void)
 495:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** {
 496:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   DAVE_STATUS_t status;
 497:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 498:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   status = DAVE_Init();           // Initialization of DAVE APPs
 499:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 500:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   if(status == DAVE_STATUS_FAILURE)
 501:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   {
 502:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     // Placeholder for error handler code. The while loop below can be replaced with an user error 
 503:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     XMC_DEBUG("DAVE APPs initialization failed\n");
 504:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 505:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     while(1U)
 506:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     {
 507:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 508:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     }
 509:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   }
 510:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 511:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   // Start the selected request source
 512:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_StartADC(&ADC_MEASUREMENT_ADV_0);
 513:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 514:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   while(1U)
 515:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   {
 516:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     // Continuously re-trigger the scan conversion sequence
 517:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     ADC_MEASUREMENT_ADV_SoftwareTrigger(&ADC_MEASUREMENT_ADV_0);
 518:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   }
 519:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** }
 520:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @endcode
 521:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 522:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** void ADC_MEASUREMENT_ADV_SoftwareTrigger(const ADC_MEASUREMENT_ADV_t *const handle_ptr);
 523:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 524:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 525:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @brief Initializes the ADC_MEASUREMENT_ADV APP Instance
 526:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @param handle_ptr constant pointer to the APP handle structure<BR>
 527:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @return None <BR>
 528:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 529:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * \par<b>Description: </b><br>
 530:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * Initialize the ADC and all the required configurations. A call to this API would initialize the 
 531:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * or the scan request source depending on the GUI selection. The initialization is taken up by cal
 532:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * or ADC_SCAN_Init(). Following this the synchronous conversion related initializations are taken 
 533:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * initialization the slave groups and the master group are powered down and either GxSYNCTR.STSEL 
 534:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * GxSYNCTR.EVALRy (if master) are configured. After the sync related configurations are completed 
 535:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * alone is powered on. Following this the result event or channel event related service request no
 536:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * are done (if required). Then the GxCHCTR configurations are completed. After the channel initial
 537:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * result handling initializations are done. This entails configuring the GxRCR registers for resul
 538:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * accumulation, subtraction and FIFO. After all these initialization are completed the channels co
 539:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * in the GUI is inserted into the appropriate ADC_QUEUE or ADC_SCAN APP buffer. If the GUI check b
 540:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * "Insert channels at initialization" is enable then these entries is pushed to the Hardware.
 541:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 542:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * Example Usage:
 543:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 544:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @code
 545:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * #include <DAVE.h>
 546:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * int main(void)
 547:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * {
 548:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *    DAVE_Init(); //ADC_MEASUREMENT_ADV_Init is called within DAVE_Init
 549:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *    return 0;
 550:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * }
 551:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @endcode
 552:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 553:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** ADC_MEASUREMENT_ADV_STATUS_t ADC_MEASUREMENT_ADV_Init(const ADC_MEASUREMENT_ADV_t *const handle_ptr
 554:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 555:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** /**
 556:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @brief Returns the conversion result
 557:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @param handle_ptr constant pointer to the channel handle structure.
 558:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *                   (Use the channel handle related macros which are defined in adc_measure_adv_co
 559:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @return uint16_t conversion result.<BR>
 560:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *                                Range: [ 0x0 to 0xFFF] without any filters/ accumulation/ subtrac
 561:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 562:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * \par<b>Description: </b><br>
 563:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * Return the converted result stored in the result register [GxRESy.RESULT].
 564:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * In the APP each channel is configured to a particular group result register (excluding FIFO). Th
 565:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * is defined in the channel handle structure @ref ADC_MEASUREMENT_ADV_CHANNEL_t. Hence this API sh
 566:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * with a pointer to the channel handle of type  @ref ADC_MEASUREMENT_ADV_CHANNEL_t (Directly use t
 567:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * related macros which are defined in adc_measure_adv_conf.h).
 568:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 569:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * \par<b>Note: </b><br>
 570:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * This API is not Applicable for reading the result from the result FIFO registers
 571:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * Use @ref ADC_MEASUREMENT_ADV_GetFifoResult in order to read the FIFO result.
 572:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 573:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * Example Usage:
 574:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  *
 575:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @code
 576:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Initialize the ADC_MEASUREMENT_ADV APP. Set the number of required channels to 2.
 577:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Select the request source APP from ADC_SCAN to ADC_QUEUE.
 578:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Goto the sequence plan and select Channel_A at position-0 and Channel_B at position-1.
 579:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Enable Wait for trigger for the Channel_A.
 580:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Goto interrupts tab enable request source interrupt.
 581:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Goto the ADC_QUEUE APP and enable the request source interrupt.
 582:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Generate the code and build.
 583:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** // Replace this in the main.c.
 584:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declaratio
 585:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 586:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** uint16_t result[2];
 587:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** void adc_measurement_adv_callback(void)
 588:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** {
 589:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   // Use the channel handle parameter in this format "<APP Name>_<CHANNEL Name>"
 590:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   result[0] = ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_ADV_0_Channel_A);
 591:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   result[1] = ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_ADV_0_Channel_B);
 592:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** }
 593:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 594:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** int main(void)
 595:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** {
 596:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   DAVE_STATUS_t status;
 597:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 598:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   status = DAVE_Init();           // Initialization of DAVE APPs
 599:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 600:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   if(status == DAVE_STATUS_FAILURE)
 601:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   {
 602:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     // Placeholder for error handler code. The while loop below can be replaced with an user error 
 603:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     XMC_DEBUG("DAVE APPs initialization failed\n");
 604:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 605:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     while(1U)
 606:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     {
 607:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 608:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****     }
 609:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   }
 610:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 611:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   // Start the selected request source
 612:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_StartADC(&ADC_MEASUREMENT_ADV_0);
 613:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 614:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   // Start the queue conversion sequence
 615:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   ADC_MEASUREMENT_ADV_SoftwareTrigger(&ADC_MEASUREMENT_ADV_0);
 616:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 617:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   while(1U)
 618:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   {
 619:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   }
 620:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** }
 621:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  * @endcode
 622:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****  */
 623:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** __STATIC_INLINE uint16_t ADC_MEASUREMENT_ADV_GetResult(const ADC_MEASUREMENT_ADV_CHANNEL_t *const h
 624:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** {
 219              	 .loc 4 624 0
 220              	 .cfi_startproc
 221 0000 90B5     	 push {r4,r7,lr}
 222              	.LCFI15:
 223              	 .cfi_def_cfa_offset 12
 224              	 .cfi_offset 4,-12
 225              	 .cfi_offset 7,-8
 226              	 .cfi_offset 14,-4
 227 0002 85B0     	 sub sp,sp,#20
 228              	.LCFI16:
 229              	 .cfi_def_cfa_offset 32
 230 0004 00AF     	 add r7,sp,#0
 231              	.LCFI17:
 232              	 .cfi_def_cfa_register 7
 233 0006 7860     	 str r0,[r7,#4]
 625:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   uint16_t result;
 626:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   extern XMC_VADC_GROUP_t *const group_ptrs[XMC_VADC_MAXIMUM_NUM_GROUPS];
 627:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   XMC_ASSERT("ADC_MEASUREMENT_ADV_GetResult:Invalid handle_ptr", (handle_ptr != NULL))
 628:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** 
 629:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   result = XMC_VADC_GROUP_GetResult(group_ptrs[handle_ptr->group_index],
 234              	 .loc 4 629 0
 235 0008 7B68     	 ldr r3,[r7,#4]
 236 000a 1B7A     	 ldrb r3,[r3,#8]
 237 000c 1A1C     	 mov r2,r3
 238 000e 0C4B     	 ldr r3,.L9
 239 0010 9200     	 lsl r2,r2,#2
 240 0012 D258     	 ldr r2,[r2,r3]
 630:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****                                     (uint32_t) handle_ptr->ch_handle->result_reg_number);
 241              	 .loc 4 630 0
 242 0014 7B68     	 ldr r3,[r7,#4]
 243 0016 1B68     	 ldr r3,[r3]
 244 0018 9B78     	 ldrb r3,[r3,#2]
 245 001a 1B07     	 lsl r3,r3,#28
 246 001c 1B0F     	 lsr r3,r3,#28
 247 001e DBB2     	 uxtb r3,r3
 629:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****                                     (uint32_t) handle_ptr->ch_handle->result_reg_number);
 248              	 .loc 4 629 0
 249 0020 0E21     	 mov r1,#14
 250 0022 7C18     	 add r4,r7,r1
 251 0024 101C     	 mov r0,r2
 252 0026 191C     	 mov r1,r3
 253 0028 FFF7FEFF 	 bl XMC_VADC_GROUP_GetResult
 254 002c 031C     	 mov r3,r0
 255 002e 2380     	 strh r3,[r4]
 631:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h ****   return(result);
 256              	 .loc 4 631 0
 257 0030 0E23     	 mov r3,#14
 258 0032 FB18     	 add r3,r7,r3
 259 0034 1B88     	 ldrh r3,[r3]
 632:C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV\adc_measurement_adv.h **** }
 260              	 .loc 4 632 0
 261 0036 181C     	 mov r0,r3
 262 0038 BD46     	 mov sp,r7
 263 003a 05B0     	 add sp,sp,#20
 264              	 
 265 003c 90BD     	 pop {r4,r7,pc}
 266              	.L10:
 267 003e C046     	 .align 2
 268              	.L9:
 269 0040 00000000 	 .word group_ptrs
 270              	 .cfi_endproc
 271              	.LFE238:
 273              	 .comm adc_ready,2,2
 274              	 .comm adc_ready20m,2,2
 275              	 .comm resultA,2,2
 276              	 .comm resultB,2,2
 277              	 .comm resultC,2,2
 278              	 .comm resultD,2,2
 279              	 .comm resultA2,2,2
 280              	 .comm resultB2,2,2
 281              	 .comm resultC2,2,2
 282              	 .comm resultD2,2,2
 283              	 .comm resultAalt,2,2
 284              	 .comm resultBalt,2,2
 285              	 .comm resultCalt,2,2
 286              	 .comm resultDalt,2,2
 287              	 .comm resultAalt2,2,2
 288              	 .comm resultBalt2,2,2
 289              	 .comm resultCalt2,2,2
 290              	 .comm resultDCalt2,2,2
 291              	 .comm delay_count,4,4
 292              	 .comm zahler_offlight,2,2
 293              	 .comm zahler_lightprog01,2,2
 294              	 .comm Ser_NrH,2,2
 295              	 .comm Ser_NrL,2,2
 296              	 .comm Hard_Vers,2,2
 297              	 .comm Soft_Vers,2,2
 298              	 .comm GEH_Vers,2,2
 299              	 .comm Mon_Vers,2,2
 300              	 .comm LED_WW_Vers,2,2
 301              	 .comm LED_CW_Vers,2,2
 302              	 .comm neu_Ser_NrH,2,2
 303              	 .comm neu_Ser_NrL,2,2
 304              	 .comm node_id,1,1
 305              	 .comm node_id_alt,1,1
 306              	 .comm node_id_16bit,2,2
 307              	 .comm val_Pow_Nom,2,2
 308              	 .comm val_Pow_max,2,2
 309              	 .comm val_Spannung_min,2,2
 310              	 .comm val_Spannung_max,2,2
 311              	 .comm led_grupp,2,2
 312              	 .comm led_Strom,2,2
 313              	 .comm node_id_resi,1,1
 314              	 .comm node_id_neu,1,1
 315              	 .comm Dimm_Gamma,1,1
 316              	 .comm Dimm_Stufen,1,1
 317              	 .comm Dimm_StufenGR,1,1
 318              	 .comm Dimm_Valu,1,1
 319              	 .comm Smooth_Value,2,2
 320              	 .comm linearwalk_gen,2,2
 321              	 .comm Farbe_wwcw_Quot_gen,2,2
 322              	 .comm Reserve_1,2,2
 323              	 .comm Dimm_Max_WW,2,2
 324              	 .comm Dimm_Max_CW,2,2
 325              	 .comm dimAkt_Ww,2,2
 326              	 .comm dimAkt_Cw,2,2
 327              	 .comm linearwalk_ww1,2,2
 328              	 .comm linearwalk_ww2,2,2
 329              	 .comm linearwalk_cw1,2,2
 330              	 .comm linearwalk_cw2,2,2
 331              	 .comm Farbe_ww1_Quot,2,2
 332              	 .comm Farbe_cw1_Quot,2,2
 333              	 .comm Farbe_ww2_Quot,2,2
 334              	 .comm Farbe_cw2_Quot,2,2
 335              	 .comm Farbe_ww1,2,2
 336              	 .comm Farbe_ww2,2,2
 337              	 .comm Farbe_cw1,2,2
 338              	 .comm Farbe_cw2,2,2
 339              	 .comm RegOnOff,1,1
 340              	 .comm RegOnOff2,1,1
 341              	 .comm Reserve_2,2,2
 342              	 .comm dimOff_Ww,2,2
 343              	 .comm dimOff_Cw,2,2
 344              	 .comm dimNorm1_Ww,2,2
 345              	 .comm dimNorm1_Cw,2,2
 346              	 .comm dimNorm2_Ww,2,2
 347              	 .comm dimNorm2_Cw,2,2
 348              	 .comm Brightness_Gen,2,2
 349              	 .comm ColorQuot_Gen,2,2
 350              	 .comm rec_data,16,4
 351              	 .comm new_data,16,4
 352              	 .comm eeprom_data,32,4
 353              	 .comm transmit_buf_size,1,1
 354              	 .comm ReadData,8,4
 355              	 .comm execute,1,1
 356              	 .comm charcount,1,1
 357              	 .comm synclevel,1,1
 358              	 .comm command,1,1
 359              	 .comm framelength,1,1
 360              	 .comm Index,1,1
 361              	 .comm ReadBuffer1,16,4
 362              	 .comm ReadBuffer2,16,4
 363              	 .comm ReadBuffer3,32,4
 364              	 .comm data_buffer,100,4
 365              	 .comm ReadBuffer4,32,4
 366              	 .comm B_first_uart,1,1
 367              	 .comm B_nextLedOff,1,1
 368              	 .comm tester,4,4
 369              	 .comm tester1,2,2
 370              	 .comm tester2,2,2
 371              	 .comm tester3,2,2
 372              	 .comm tester4,2,2
 373              	 .comm tester5,2,2
 374              	 .comm command_nr,2,2
 375              	 .comm Dstatus,1,1
 376              	 .section .text.main,"ax",%progbits
 377              	 .align 2
 378              	 .global main
 379              	 .code 16
 380              	 .thumb_func
 382              	main:
 383              	.LFB290:
 384              	 .file 5 "../main.c"
   1:../main.c     **** /*
   2:../main.c     ****  * main.c
   3:../main.c     ****  *kopiert aus test_20160605a_soft04nils
   4:../main.c     ****  *--> neu 2016 10 11
   5:../main.c     ****  *--> einarbeiten einer automatischen dimmfunktion
   6:../main.c     ****  *--> 1. Warm weiss kalt weiss dimmen
   7:../main.c     ****  *--> 2. hell dunkel mit warm weiss kaltweiss dimmung
   8:../main.c     ****  *--> Umsetzen als auswhlfunktion mittels serieller eingabe
   9:../main.c     ****  *--> auswhlen funktion, helligkeit,
  10:../main.c     ****  *  Created on: 2016 May 06 10:13:00
  11:../main.c     ****  *  Author: samuel
  12:../main.c     ****  */
  13:../main.c     **** 
  14:../main.c     **** 
  15:../main.c     **** 
  16:../main.c     **** 
  17:../main.c     **** #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declaratio
  18:../main.c     **** #include <samuel/samuel_io.h>
  19:../main.c     **** 
  20:../main.c     ****      uint32_t tester;
  21:../main.c     ****      uint16_t tester1;
  22:../main.c     ****      uint16_t tester2;
  23:../main.c     ****      uint16_t tester3;
  24:../main.c     ****      uint16_t tester4;
  25:../main.c     ****      uint16_t tester5;
  26:../main.c     ****      uint16_t command_nr;
  27:../main.c     **** //	 uint8_t ww[2];
  28:../main.c     **** //	 uint8_t cw[2];
  29:../main.c     **** 
  30:../main.c     **** 	 DAVE_STATUS_t Dstatus;
  31:../main.c     **** 
  32:../main.c     **** 
  33:../main.c     **** int main(void)
  34:../main.c     **** {
 385              	 .loc 5 34 0
 386              	 .cfi_startproc
 387 0000 90B5     	 push {r4,r7,lr}
 388              	.LCFI18:
 389              	 .cfi_def_cfa_offset 12
 390              	 .cfi_offset 4,-12
 391              	 .cfi_offset 7,-8
 392              	 .cfi_offset 14,-4
 393 0002 87B0     	 sub sp,sp,#28
 394              	.LCFI19:
 395              	 .cfi_def_cfa_offset 40
 396 0004 00AF     	 add r7,sp,#0
 397              	.LCFI20:
 398              	 .cfi_def_cfa_register 7
  35:../main.c     **** 	uint32_t TimerId,status;
  36:../main.c     **** 	uint32_t Timer1M,status1M;
  37:../main.c     **** 	uint32_t Timer20M,status20M;
  38:../main.c     **** 
  39:../main.c     ****    Dstatus = DAVE_Init();  //(DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_In
 399              	 .loc 5 39 0
 400 0006 FFF7FEFF 	 bl DAVE_Init
 401 000a 031C     	 mov r3,r0
 402 000c 1A1C     	 mov r2,r3
 403 000e F34B     	 ldr r3,.L120
 404 0010 1A70     	 strb r2,[r3]
  40:../main.c     ****    if(Dstatus == DAVE_STATUS_SUCCESS)
 405              	 .loc 5 40 0
 406 0012 F24B     	 ldr r3,.L120
 407 0014 1B78     	 ldrb r3,[r3]
 408 0016 002B     	 cmp r3,#0
 409 0018 00D0     	 beq .L12
 410              	.L13:
  41:../main.c     ****    {
  42:../main.c     ****     XMC_DEBUG("DAVE Apps initialization success\n");
  43:../main.c     ****    }
  44:../main.c     ****    else
  45:../main.c     ****    {
  46:../main.c     ****     XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", Dstatus));
  47:../main.c     ****     while(1U)
  48:../main.c     ****     {
  49:../main.c     ****     }
 411              	 .loc 5 49 0 discriminator 1
 412 001a FEE7     	 b .L13
 413              	.L12:
  50:../main.c     ****    }
  51:../main.c     ****    // Initialisierung
  52:../main.c     ****    // bergabe werte
  53:../main.c     **** 	sysiniValueB1();
 414              	 .loc 5 53 0
 415 001c FFF7FEFF 	 bl sysiniValueB1
  54:../main.c     **** 	sysiniValueB2();
 416              	 .loc 5 54 0
 417 0020 FFF7FEFF 	 bl sysiniValueB2
  55:../main.c     **** 	sysiniValueB4();
 418              	 .loc 5 55 0
 419 0024 FFF7FEFF 	 bl sysiniValueB4
  56:../main.c     **** sysiniValueB5();
 420              	 .loc 5 56 0
 421 0028 FFF7FEFF 	 bl sysiniValueB5
  57:../main.c     **** 	//  tester4 = writeOff_light_B5_EEprom();
  58:../main.c     **** 	  tester = readSerNrEEprom();
 422              	 .loc 5 58 0
 423 002c FFF7FEFF 	 bl readSerNrEEprom
 424 0030 031C     	 mov r3,r0
 425 0032 1A1C     	 mov r2,r3
 426 0034 EA4B     	 ldr r3,.L120+4
 427 0036 1A60     	 str r2,[r3]
  59:../main.c     **** 	if (tester == 0x03)
 428              	 .loc 5 59 0
 429 0038 E94B     	 ldr r3,.L120+4
 430 003a 1B68     	 ldr r3,[r3]
 431 003c 032B     	 cmp r3,#3
 432 003e 66D1     	 bne .L14
  60:../main.c     **** 	{
  61:../main.c     **** 	Ser_NrH = ReadBuffer1[0] * 0x100 + ReadBuffer1[1];
 433              	 .loc 5 61 0
 434 0040 E84B     	 ldr r3,.L120+8
 435 0042 1B78     	 ldrb r3,[r3]
 436 0044 9BB2     	 uxth r3,r3
 437 0046 1B02     	 lsl r3,r3,#8
 438 0048 9AB2     	 uxth r2,r3
 439 004a E64B     	 ldr r3,.L120+8
 440 004c 5B78     	 ldrb r3,[r3,#1]
 441 004e 9BB2     	 uxth r3,r3
 442 0050 D318     	 add r3,r2,r3
 443 0052 9AB2     	 uxth r2,r3
 444 0054 E44B     	 ldr r3,.L120+12
 445 0056 1A80     	 strh r2,[r3]
  62:../main.c     **** 	Ser_NrL = ReadBuffer1[2] * 0x100 + ReadBuffer1[3];
 446              	 .loc 5 62 0
 447 0058 E24B     	 ldr r3,.L120+8
 448 005a 9B78     	 ldrb r3,[r3,#2]
 449 005c 9BB2     	 uxth r3,r3
 450 005e 1B02     	 lsl r3,r3,#8
 451 0060 9AB2     	 uxth r2,r3
 452 0062 E04B     	 ldr r3,.L120+8
 453 0064 DB78     	 ldrb r3,[r3,#3]
 454 0066 9BB2     	 uxth r3,r3
 455 0068 D318     	 add r3,r2,r3
 456 006a 9AB2     	 uxth r2,r3
 457 006c DF4B     	 ldr r3,.L120+16
 458 006e 1A80     	 strh r2,[r3]
  63:../main.c     ****   Hard_Vers = ReadBuffer1[4] * 0x100 + ReadBuffer1[5];
 459              	 .loc 5 63 0
 460 0070 DC4B     	 ldr r3,.L120+8
 461 0072 1B79     	 ldrb r3,[r3,#4]
 462 0074 9BB2     	 uxth r3,r3
 463 0076 1B02     	 lsl r3,r3,#8
 464 0078 9AB2     	 uxth r2,r3
 465 007a DA4B     	 ldr r3,.L120+8
 466 007c 5B79     	 ldrb r3,[r3,#5]
 467 007e 9BB2     	 uxth r3,r3
 468 0080 D318     	 add r3,r2,r3
 469 0082 9AB2     	 uxth r2,r3
 470 0084 DA4B     	 ldr r3,.L120+20
 471 0086 1A80     	 strh r2,[r3]
  64:../main.c     ****   Soft_Vers = ReadBuffer1[6] * 0x100 + ReadBuffer1[7];
 472              	 .loc 5 64 0
 473 0088 D64B     	 ldr r3,.L120+8
 474 008a 9B79     	 ldrb r3,[r3,#6]
 475 008c 9BB2     	 uxth r3,r3
 476 008e 1B02     	 lsl r3,r3,#8
 477 0090 9AB2     	 uxth r2,r3
 478 0092 D44B     	 ldr r3,.L120+8
 479 0094 DB79     	 ldrb r3,[r3,#7]
 480 0096 9BB2     	 uxth r3,r3
 481 0098 D318     	 add r3,r2,r3
 482 009a 9AB2     	 uxth r2,r3
 483 009c D54B     	 ldr r3,.L120+24
 484 009e 1A80     	 strh r2,[r3]
  65:../main.c     ****   GEH_Vers = ReadBuffer1[8] * 0x100 + ReadBuffer1[9];
 485              	 .loc 5 65 0
 486 00a0 D04B     	 ldr r3,.L120+8
 487 00a2 1B7A     	 ldrb r3,[r3,#8]
 488 00a4 9BB2     	 uxth r3,r3
 489 00a6 1B02     	 lsl r3,r3,#8
 490 00a8 9AB2     	 uxth r2,r3
 491 00aa CE4B     	 ldr r3,.L120+8
 492 00ac 5B7A     	 ldrb r3,[r3,#9]
 493 00ae 9BB2     	 uxth r3,r3
 494 00b0 D318     	 add r3,r2,r3
 495 00b2 9AB2     	 uxth r2,r3
 496 00b4 D04B     	 ldr r3,.L120+28
 497 00b6 1A80     	 strh r2,[r3]
  66:../main.c     ****   Mon_Vers = ReadBuffer1[10] * 0x100 + ReadBuffer1[11];
 498              	 .loc 5 66 0
 499 00b8 CA4B     	 ldr r3,.L120+8
 500 00ba 9B7A     	 ldrb r3,[r3,#10]
 501 00bc 9BB2     	 uxth r3,r3
 502 00be 1B02     	 lsl r3,r3,#8
 503 00c0 9AB2     	 uxth r2,r3
 504 00c2 C84B     	 ldr r3,.L120+8
 505 00c4 DB7A     	 ldrb r3,[r3,#11]
 506 00c6 9BB2     	 uxth r3,r3
 507 00c8 D318     	 add r3,r2,r3
 508 00ca 9AB2     	 uxth r2,r3
 509 00cc CB4B     	 ldr r3,.L120+32
 510 00ce 1A80     	 strh r2,[r3]
  67:../main.c     ****   LED_WW_Vers = ReadBuffer1[12] * 0x100 + ReadBuffer1[13];
 511              	 .loc 5 67 0
 512 00d0 C44B     	 ldr r3,.L120+8
 513 00d2 1B7B     	 ldrb r3,[r3,#12]
 514 00d4 9BB2     	 uxth r3,r3
 515 00d6 1B02     	 lsl r3,r3,#8
 516 00d8 9AB2     	 uxth r2,r3
 517 00da C24B     	 ldr r3,.L120+8
 518 00dc 5B7B     	 ldrb r3,[r3,#13]
 519 00de 9BB2     	 uxth r3,r3
 520 00e0 D318     	 add r3,r2,r3
 521 00e2 9AB2     	 uxth r2,r3
 522 00e4 C64B     	 ldr r3,.L120+36
 523 00e6 1A80     	 strh r2,[r3]
  68:../main.c     ****   LED_CW_Vers = ReadBuffer1[14] * 0x100 + ReadBuffer1[15];
 524              	 .loc 5 68 0
 525 00e8 BE4B     	 ldr r3,.L120+8
 526 00ea 9B7B     	 ldrb r3,[r3,#14]
 527 00ec 9BB2     	 uxth r3,r3
 528 00ee 1B02     	 lsl r3,r3,#8
 529 00f0 9AB2     	 uxth r2,r3
 530 00f2 BC4B     	 ldr r3,.L120+8
 531 00f4 DB7B     	 ldrb r3,[r3,#15]
 532 00f6 9BB2     	 uxth r3,r3
 533 00f8 D318     	 add r3,r2,r3
 534 00fa 9AB2     	 uxth r2,r3
 535 00fc C14B     	 ldr r3,.L120+40
 536 00fe 1A80     	 strh r2,[r3]
  69:../main.c     **** 
  70:../main.c     ****   neu_Ser_NrH = 0 ;
 537              	 .loc 5 70 0
 538 0100 C14B     	 ldr r3,.L120+44
 539 0102 0022     	 mov r2,#0
 540 0104 1A80     	 strh r2,[r3]
  71:../main.c     ****   neu_Ser_NrL = 0 ;
 541              	 .loc 5 71 0
 542 0106 C14B     	 ldr r3,.L120+48
 543 0108 0022     	 mov r2,#0
 544 010a 1A80     	 strh r2,[r3]
 545 010c 01E0     	 b .L15
 546              	.L14:
  72:../main.c     **** 
  73:../main.c     **** 	}
  74:../main.c     **** 	else
  75:../main.c     **** 	{
  76:../main.c     **** 	sysiniValueB1();
 547              	 .loc 5 76 0
 548 010e FFF7FEFF 	 bl sysiniValueB1
 549              	.L15:
  77:../main.c     **** 	}
  78:../main.c     **** 
  79:../main.c     **** tester = readNodeIdEEprom();
 550              	 .loc 5 79 0
 551 0112 FFF7FEFF 	 bl readNodeIdEEprom
 552 0116 031C     	 mov r3,r0
 553 0118 1A1C     	 mov r2,r3
 554 011a B14B     	 ldr r3,.L120+4
 555 011c 1A60     	 str r2,[r3]
  80:../main.c     **** 	if (tester == 0x03)
 556              	 .loc 5 80 0
 557 011e B04B     	 ldr r3,.L120+4
 558 0120 1B68     	 ldr r3,[r3]
 559 0122 032B     	 cmp r3,#3
 560 0124 5FD1     	 bne .L16
  81:../main.c     **** 	{
  82:../main.c     **** 		node_id_alt = ReadBuffer2[0] ;
 561              	 .loc 5 82 0
 562 0126 BA4B     	 ldr r3,.L120+52
 563 0128 1A78     	 ldrb r2,[r3]
 564 012a BA4B     	 ldr r3,.L120+56
 565 012c 1A70     	 strb r2,[r3]
  83:../main.c     **** 		node_id = ReadBuffer2[1];
 566              	 .loc 5 83 0
 567 012e B84B     	 ldr r3,.L120+52
 568 0130 5A78     	 ldrb r2,[r3,#1]
 569 0132 B94B     	 ldr r3,.L120+60
 570 0134 1A70     	 strb r2,[r3]
  84:../main.c     **** 		node_id_16bit = ReadBuffer2[2] * 0x100 + ReadBuffer2[3];
 571              	 .loc 5 84 0
 572 0136 B64B     	 ldr r3,.L120+52
 573 0138 9B78     	 ldrb r3,[r3,#2]
 574 013a 9BB2     	 uxth r3,r3
 575 013c 1B02     	 lsl r3,r3,#8
 576 013e 9AB2     	 uxth r2,r3
 577 0140 B34B     	 ldr r3,.L120+52
 578 0142 DB78     	 ldrb r3,[r3,#3]
 579 0144 9BB2     	 uxth r3,r3
 580 0146 D318     	 add r3,r2,r3
 581 0148 9AB2     	 uxth r2,r3
 582 014a B44B     	 ldr r3,.L120+64
 583 014c 1A80     	 strh r2,[r3]
  85:../main.c     **** 		val_Pow_Nom = ReadBuffer2[4] * 0x100 + ReadBuffer2[5];
 584              	 .loc 5 85 0
 585 014e B04B     	 ldr r3,.L120+52
 586 0150 1B79     	 ldrb r3,[r3,#4]
 587 0152 9BB2     	 uxth r3,r3
 588 0154 1B02     	 lsl r3,r3,#8
 589 0156 9AB2     	 uxth r2,r3
 590 0158 AD4B     	 ldr r3,.L120+52
 591 015a 5B79     	 ldrb r3,[r3,#5]
 592 015c 9BB2     	 uxth r3,r3
 593 015e D318     	 add r3,r2,r3
 594 0160 9AB2     	 uxth r2,r3
 595 0162 AF4B     	 ldr r3,.L120+68
 596 0164 1A80     	 strh r2,[r3]
  86:../main.c     **** 		val_Pow_max = ReadBuffer2[6] * 0x100 + ReadBuffer2[7];
 597              	 .loc 5 86 0
 598 0166 AA4B     	 ldr r3,.L120+52
 599 0168 9B79     	 ldrb r3,[r3,#6]
 600 016a 9BB2     	 uxth r3,r3
 601 016c 1B02     	 lsl r3,r3,#8
 602 016e 9AB2     	 uxth r2,r3
 603 0170 A74B     	 ldr r3,.L120+52
 604 0172 DB79     	 ldrb r3,[r3,#7]
 605 0174 9BB2     	 uxth r3,r3
 606 0176 D318     	 add r3,r2,r3
 607 0178 9AB2     	 uxth r2,r3
 608 017a AA4B     	 ldr r3,.L120+72
 609 017c 1A80     	 strh r2,[r3]
  87:../main.c     **** 		val_Spannung_min = ReadBuffer2[8] * 0x100 + ReadBuffer2[9];
 610              	 .loc 5 87 0
 611 017e A44B     	 ldr r3,.L120+52
 612 0180 1B7A     	 ldrb r3,[r3,#8]
 613 0182 9BB2     	 uxth r3,r3
 614 0184 1B02     	 lsl r3,r3,#8
 615 0186 9AB2     	 uxth r2,r3
 616 0188 A14B     	 ldr r3,.L120+52
 617 018a 5B7A     	 ldrb r3,[r3,#9]
 618 018c 9BB2     	 uxth r3,r3
 619 018e D318     	 add r3,r2,r3
 620 0190 9AB2     	 uxth r2,r3
 621 0192 A54B     	 ldr r3,.L120+76
 622 0194 1A80     	 strh r2,[r3]
  88:../main.c     **** 		val_Spannung_max = ReadBuffer2[10] * 0x100 + ReadBuffer2[11];
 623              	 .loc 5 88 0
 624 0196 9E4B     	 ldr r3,.L120+52
 625 0198 9B7A     	 ldrb r3,[r3,#10]
 626 019a 9BB2     	 uxth r3,r3
 627 019c 1B02     	 lsl r3,r3,#8
 628 019e 9AB2     	 uxth r2,r3
 629 01a0 9B4B     	 ldr r3,.L120+52
 630 01a2 DB7A     	 ldrb r3,[r3,#11]
 631 01a4 9BB2     	 uxth r3,r3
 632 01a6 D318     	 add r3,r2,r3
 633 01a8 9AB2     	 uxth r2,r3
 634 01aa A04B     	 ldr r3,.L120+80
 635 01ac 1A80     	 strh r2,[r3]
  89:../main.c     **** 		led_grupp = ReadBuffer2[12] * 0x100 + ReadBuffer2[13];
 636              	 .loc 5 89 0
 637 01ae 984B     	 ldr r3,.L120+52
 638 01b0 1B7B     	 ldrb r3,[r3,#12]
 639 01b2 9BB2     	 uxth r3,r3
 640 01b4 1B02     	 lsl r3,r3,#8
 641 01b6 9AB2     	 uxth r2,r3
 642 01b8 954B     	 ldr r3,.L120+52
 643 01ba 5B7B     	 ldrb r3,[r3,#13]
 644 01bc 9BB2     	 uxth r3,r3
 645 01be D318     	 add r3,r2,r3
 646 01c0 9AB2     	 uxth r2,r3
 647 01c2 9B4B     	 ldr r3,.L120+84
 648 01c4 1A80     	 strh r2,[r3]
  90:../main.c     **** 		led_Strom = ReadBuffer2[14] * 0x100 + ReadBuffer2[15];
 649              	 .loc 5 90 0
 650 01c6 924B     	 ldr r3,.L120+52
 651 01c8 9B7B     	 ldrb r3,[r3,#14]
 652 01ca 9BB2     	 uxth r3,r3
 653 01cc 1B02     	 lsl r3,r3,#8
 654 01ce 9AB2     	 uxth r2,r3
 655 01d0 8F4B     	 ldr r3,.L120+52
 656 01d2 DB7B     	 ldrb r3,[r3,#15]
 657 01d4 9BB2     	 uxth r3,r3
 658 01d6 D318     	 add r3,r2,r3
 659 01d8 9AB2     	 uxth r2,r3
 660 01da 964B     	 ldr r3,.L120+88
 661 01dc 1A80     	 strh r2,[r3]
  91:../main.c     **** 
  92:../main.c     ****   	   node_id_neu = 1;
 662              	 .loc 5 92 0
 663 01de 964B     	 ldr r3,.L120+92
 664 01e0 0122     	 mov r2,#1
 665 01e2 1A70     	 strb r2,[r3]
 666 01e4 01E0     	 b .L17
 667              	.L16:
  93:../main.c     **** 	}
  94:../main.c     **** 	else
  95:../main.c     **** 	{
  96:../main.c     ****    sysiniValueB2();
 668              	 .loc 5 96 0
 669 01e6 FFF7FEFF 	 bl sysiniValueB2
 670              	.L17:
  97:../main.c     **** 	}
  98:../main.c     **** 
  99:../main.c     **** tester = read_akt_light_EEprom();
 671              	 .loc 5 99 0
 672 01ea FFF7FEFF 	 bl read_akt_light_EEprom
 673 01ee 031C     	 mov r3,r0
 674 01f0 1A1C     	 mov r2,r3
 675 01f2 7B4B     	 ldr r3,.L120+4
 676 01f4 1A60     	 str r2,[r3]
 100:../main.c     **** 	if (tester == 0x03)
 677              	 .loc 5 100 0
 678 01f6 7A4B     	 ldr r3,.L120+4
 679 01f8 1B68     	 ldr r3,[r3]
 680 01fa 032B     	 cmp r3,#3
 681 01fc 00D0     	 beq .LCB498
 682 01fe 82E0     	 b .L18
 683              	.LCB498:
 101:../main.c     **** 	{
 102:../main.c     **** 
 103:../main.c     **** 		Dimm_Gamma = ReadBuffer2[0] ;
 684              	 .loc 5 103 0
 685 0200 834B     	 ldr r3,.L120+52
 686 0202 1A78     	 ldrb r2,[r3]
 687 0204 8D4B     	 ldr r3,.L120+96
 688 0206 1A70     	 strb r2,[r3]
 104:../main.c     **** 		Dimm_Stufen = ReadBuffer2[1];
 689              	 .loc 5 104 0
 690 0208 814B     	 ldr r3,.L120+52
 691 020a 5A78     	 ldrb r2,[r3,#1]
 692 020c 8C4B     	 ldr r3,.L120+100
 693 020e 1A70     	 strb r2,[r3]
 105:../main.c     **** 		Dimm_StufenGR = ReadBuffer2[2] ;
 694              	 .loc 5 105 0
 695 0210 7F4B     	 ldr r3,.L120+52
 696 0212 9A78     	 ldrb r2,[r3,#2]
 697 0214 8B4B     	 ldr r3,.L120+104
 698 0216 1A70     	 strb r2,[r3]
 106:../main.c     **** 		Dimm_Valu = ReadBuffer2[3];
 699              	 .loc 5 106 0
 700 0218 7D4B     	 ldr r3,.L120+52
 701 021a DA78     	 ldrb r2,[r3,#3]
 702 021c 8A4B     	 ldr r3,.L120+108
 703 021e 1A70     	 strb r2,[r3]
 107:../main.c     **** 		Smooth_Value = ReadBuffer2[4] * 0x100 + ReadBuffer2[5];
 704              	 .loc 5 107 0
 705 0220 7B4B     	 ldr r3,.L120+52
 706 0222 1B79     	 ldrb r3,[r3,#4]
 707 0224 9BB2     	 uxth r3,r3
 708 0226 1B02     	 lsl r3,r3,#8
 709 0228 9AB2     	 uxth r2,r3
 710 022a 794B     	 ldr r3,.L120+52
 711 022c 5B79     	 ldrb r3,[r3,#5]
 712 022e 9BB2     	 uxth r3,r3
 713 0230 D318     	 add r3,r2,r3
 714 0232 9AB2     	 uxth r2,r3
 715 0234 854B     	 ldr r3,.L120+112
 716 0236 1A80     	 strh r2,[r3]
 108:../main.c     **** 		linearwalk_gen = ReadBuffer2[6] * 0x100 + ReadBuffer2[7];
 717              	 .loc 5 108 0
 718 0238 754B     	 ldr r3,.L120+52
 719 023a 9B79     	 ldrb r3,[r3,#6]
 720 023c 9BB2     	 uxth r3,r3
 721 023e 1B02     	 lsl r3,r3,#8
 722 0240 9AB2     	 uxth r2,r3
 723 0242 734B     	 ldr r3,.L120+52
 724 0244 DB79     	 ldrb r3,[r3,#7]
 725 0246 9BB2     	 uxth r3,r3
 726 0248 D318     	 add r3,r2,r3
 727 024a 9AB2     	 uxth r2,r3
 728 024c 804B     	 ldr r3,.L120+116
 729 024e 1A80     	 strh r2,[r3]
 109:../main.c     **** 		Farbe_wwcw_Quot_gen = ReadBuffer2[8] * 0x100 + ReadBuffer2[9];
 730              	 .loc 5 109 0
 731 0250 6F4B     	 ldr r3,.L120+52
 732 0252 1B7A     	 ldrb r3,[r3,#8]
 733 0254 9BB2     	 uxth r3,r3
 734 0256 1B02     	 lsl r3,r3,#8
 735 0258 9AB2     	 uxth r2,r3
 736 025a 6D4B     	 ldr r3,.L120+52
 737 025c 5B7A     	 ldrb r3,[r3,#9]
 738 025e 9BB2     	 uxth r3,r3
 739 0260 D318     	 add r3,r2,r3
 740 0262 9AB2     	 uxth r2,r3
 741 0264 7B4B     	 ldr r3,.L120+120
 742 0266 1A80     	 strh r2,[r3]
 110:../main.c     **** 		Reserve_1 = ReadBuffer2[10] * 0x100 + ReadBuffer2[11];
 743              	 .loc 5 110 0
 744 0268 694B     	 ldr r3,.L120+52
 745 026a 9B7A     	 ldrb r3,[r3,#10]
 746 026c 9BB2     	 uxth r3,r3
 747 026e 1B02     	 lsl r3,r3,#8
 748 0270 9AB2     	 uxth r2,r3
 749 0272 674B     	 ldr r3,.L120+52
 750 0274 DB7A     	 ldrb r3,[r3,#11]
 751 0276 9BB2     	 uxth r3,r3
 752 0278 D318     	 add r3,r2,r3
 753 027a 9AB2     	 uxth r2,r3
 754 027c 764B     	 ldr r3,.L120+124
 755 027e 1A80     	 strh r2,[r3]
 111:../main.c     **** 		Dimm_Max_WW = ReadBuffer2[12] * 0x100 + ReadBuffer2[13];
 756              	 .loc 5 111 0
 757 0280 634B     	 ldr r3,.L120+52
 758 0282 1B7B     	 ldrb r3,[r3,#12]
 759 0284 9BB2     	 uxth r3,r3
 760 0286 1B02     	 lsl r3,r3,#8
 761 0288 9AB2     	 uxth r2,r3
 762 028a 614B     	 ldr r3,.L120+52
 763 028c 5B7B     	 ldrb r3,[r3,#13]
 764 028e 9BB2     	 uxth r3,r3
 765 0290 D318     	 add r3,r2,r3
 766 0292 9AB2     	 uxth r2,r3
 767 0294 714B     	 ldr r3,.L120+128
 768 0296 1A80     	 strh r2,[r3]
 112:../main.c     **** 		Dimm_Max_CW = ReadBuffer2[14] * 0x100 + ReadBuffer2[15];
 769              	 .loc 5 112 0
 770 0298 5D4B     	 ldr r3,.L120+52
 771 029a 9B7B     	 ldrb r3,[r3,#14]
 772 029c 9BB2     	 uxth r3,r3
 773 029e 1B02     	 lsl r3,r3,#8
 774 02a0 9AB2     	 uxth r2,r3
 775 02a2 5B4B     	 ldr r3,.L120+52
 776 02a4 DB7B     	 ldrb r3,[r3,#15]
 777 02a6 9BB2     	 uxth r3,r3
 778 02a8 D318     	 add r3,r2,r3
 779 02aa 9AB2     	 uxth r2,r3
 780 02ac 6C4B     	 ldr r3,.L120+132
 781 02ae 1A80     	 strh r2,[r3]
 113:../main.c     **** 
 114:../main.c     **** 	      linearwalk_ww1 = linearwalk_gen;
 782              	 .loc 5 114 0
 783 02b0 674B     	 ldr r3,.L120+116
 784 02b2 1A88     	 ldrh r2,[r3]
 785 02b4 6B4B     	 ldr r3,.L120+136
 786 02b6 1A80     	 strh r2,[r3]
 115:../main.c     **** 	      linearwalk_ww2 = linearwalk_gen;
 787              	 .loc 5 115 0
 788 02b8 654B     	 ldr r3,.L120+116
 789 02ba 1A88     	 ldrh r2,[r3]
 790 02bc 6A4B     	 ldr r3,.L120+140
 791 02be 1A80     	 strh r2,[r3]
 116:../main.c     **** 	      linearwalk_cw1 = linearwalk_gen;
 792              	 .loc 5 116 0
 793 02c0 634B     	 ldr r3,.L120+116
 794 02c2 1A88     	 ldrh r2,[r3]
 795 02c4 694B     	 ldr r3,.L120+144
 796 02c6 1A80     	 strh r2,[r3]
 117:../main.c     **** 	      linearwalk_cw2 = linearwalk_gen;
 797              	 .loc 5 117 0
 798 02c8 614B     	 ldr r3,.L120+116
 799 02ca 1A88     	 ldrh r2,[r3]
 800 02cc 684B     	 ldr r3,.L120+148
 801 02ce 1A80     	 strh r2,[r3]
 118:../main.c     **** 
 119:../main.c     **** 	      Farbe_ww1_Quot = Farbe_wwcw_Quot_gen>>8;
 802              	 .loc 5 119 0
 803 02d0 604B     	 ldr r3,.L120+120
 804 02d2 1B88     	 ldrh r3,[r3]
 805 02d4 1B0A     	 lsr r3,r3,#8
 806 02d6 9AB2     	 uxth r2,r3
 807 02d8 664B     	 ldr r3,.L120+152
 808 02da 1A80     	 strh r2,[r3]
 120:../main.c     **** 	      Farbe_cw1_Quot = Farbe_wwcw_Quot_gen>>8;
 809              	 .loc 5 120 0
 810 02dc 5D4B     	 ldr r3,.L120+120
 811 02de 1B88     	 ldrh r3,[r3]
 812 02e0 1B0A     	 lsr r3,r3,#8
 813 02e2 9AB2     	 uxth r2,r3
 814 02e4 644B     	 ldr r3,.L120+156
 815 02e6 1A80     	 strh r2,[r3]
 121:../main.c     **** 	      Farbe_ww2_Quot = Farbe_wwcw_Quot_gen & 0xff;
 816              	 .loc 5 121 0
 817 02e8 5A4B     	 ldr r3,.L120+120
 818 02ea 1B88     	 ldrh r3,[r3]
 819 02ec FF22     	 mov r2,#255
 820 02ee 1340     	 and r3,r2
 821 02f0 9AB2     	 uxth r2,r3
 822 02f2 624B     	 ldr r3,.L120+160
 823 02f4 1A80     	 strh r2,[r3]
 122:../main.c     **** 	      Farbe_cw2_Quot = Farbe_wwcw_Quot_gen & 0xff;
 824              	 .loc 5 122 0
 825 02f6 574B     	 ldr r3,.L120+120
 826 02f8 1B88     	 ldrh r3,[r3]
 827 02fa FF22     	 mov r2,#255
 828 02fc 1340     	 and r3,r2
 829 02fe 9AB2     	 uxth r2,r3
 830 0300 5F4B     	 ldr r3,.L120+164
 831 0302 1A80     	 strh r2,[r3]
 832 0304 01E0     	 b .L19
 833              	.L18:
 123:../main.c     **** 
 124:../main.c     **** 	}
 125:../main.c     **** 	else
 126:../main.c     **** 	{
 127:../main.c     **** 	sysiniValueB4();
 834              	 .loc 5 127 0
 835 0306 FFF7FEFF 	 bl sysiniValueB4
 836              	.L19:
 128:../main.c     **** 	}
 129:../main.c     **** 
 130:../main.c     **** tester = read_off_light_EEprom();
 837              	 .loc 5 130 0
 838 030a FFF7FEFF 	 bl read_off_light_EEprom
 839 030e 031C     	 mov r3,r0
 840 0310 1A1C     	 mov r2,r3
 841 0312 334B     	 ldr r3,.L120+4
 842 0314 1A60     	 str r2,[r3]
 131:../main.c     **** 	if (tester == 0x03)
 843              	 .loc 5 131 0
 844 0316 324B     	 ldr r3,.L120+4
 845 0318 1B68     	 ldr r3,[r3]
 846 031a 032B     	 cmp r3,#3
 847 031c 00D0     	 beq .LCB644
 848 031e C3E0     	 b .L20
 849              	.LCB644:
 132:../main.c     **** 	{
 133:../main.c     **** 
 134:../main.c     **** 		RegOnOff = ReadBuffer2[0] ;
 850              	 .loc 5 134 0
 851 0320 3B4B     	 ldr r3,.L120+52
 852 0322 1A78     	 ldrb r2,[r3]
 853 0324 574B     	 ldr r3,.L120+168
 854 0326 1A70     	 strb r2,[r3]
 135:../main.c     **** 		RegOnOff2 = ReadBuffer2[1];
 855              	 .loc 5 135 0
 856 0328 394B     	 ldr r3,.L120+52
 857 032a 5A78     	 ldrb r2,[r3,#1]
 858 032c 564B     	 ldr r3,.L120+172
 859 032e 1A70     	 strb r2,[r3]
 136:../main.c     **** 		Reserve_2  = ReadBuffer2[2] * 0x100 + ReadBuffer2[3];
 860              	 .loc 5 136 0
 861 0330 374B     	 ldr r3,.L120+52
 862 0332 9B78     	 ldrb r3,[r3,#2]
 863 0334 9BB2     	 uxth r3,r3
 864 0336 1B02     	 lsl r3,r3,#8
 865 0338 9AB2     	 uxth r2,r3
 866 033a 354B     	 ldr r3,.L120+52
 867 033c DB78     	 ldrb r3,[r3,#3]
 868 033e 9BB2     	 uxth r3,r3
 869 0340 D318     	 add r3,r2,r3
 870 0342 9AB2     	 uxth r2,r3
 871 0344 514B     	 ldr r3,.L120+176
 872 0346 1A80     	 strh r2,[r3]
 137:../main.c     **** 		dimOff_Ww = ReadBuffer2[4] * 0x100 + ReadBuffer2[5];
 873              	 .loc 5 137 0
 874 0348 314B     	 ldr r3,.L120+52
 875 034a 1B79     	 ldrb r3,[r3,#4]
 876 034c 9BB2     	 uxth r3,r3
 877 034e 1B02     	 lsl r3,r3,#8
 878 0350 9AB2     	 uxth r2,r3
 879 0352 2F4B     	 ldr r3,.L120+52
 880 0354 5B79     	 ldrb r3,[r3,#5]
 881 0356 9BB2     	 uxth r3,r3
 882 0358 D318     	 add r3,r2,r3
 883 035a 9AB2     	 uxth r2,r3
 884 035c 4C4B     	 ldr r3,.L120+180
 885 035e 1A80     	 strh r2,[r3]
 138:../main.c     **** 		dimOff_Cw = ReadBuffer2[6] * 0x100 + ReadBuffer2[7];
 886              	 .loc 5 138 0
 887 0360 2B4B     	 ldr r3,.L120+52
 888 0362 9B79     	 ldrb r3,[r3,#6]
 889 0364 9BB2     	 uxth r3,r3
 890 0366 1B02     	 lsl r3,r3,#8
 891 0368 9AB2     	 uxth r2,r3
 892 036a 294B     	 ldr r3,.L120+52
 893 036c DB79     	 ldrb r3,[r3,#7]
 894 036e 9BB2     	 uxth r3,r3
 895 0370 D318     	 add r3,r2,r3
 896 0372 9AB2     	 uxth r2,r3
 897 0374 474B     	 ldr r3,.L120+184
 898 0376 1A80     	 strh r2,[r3]
 139:../main.c     **** 		dimNorm1_Ww  = ReadBuffer2[8] * 0x100 + ReadBuffer2[9];
 899              	 .loc 5 139 0
 900 0378 254B     	 ldr r3,.L120+52
 901 037a 1B7A     	 ldrb r3,[r3,#8]
 902 037c 9BB2     	 uxth r3,r3
 903 037e 1B02     	 lsl r3,r3,#8
 904 0380 9AB2     	 uxth r2,r3
 905 0382 234B     	 ldr r3,.L120+52
 906 0384 5B7A     	 ldrb r3,[r3,#9]
 907 0386 9BB2     	 uxth r3,r3
 908 0388 D318     	 add r3,r2,r3
 909 038a 9AB2     	 uxth r2,r3
 910 038c 424B     	 ldr r3,.L120+188
 911 038e 1A80     	 strh r2,[r3]
 140:../main.c     **** 		dimNorm1_Cw = ReadBuffer2[10] * 0x100 + ReadBuffer2[11];
 912              	 .loc 5 140 0
 913 0390 1F4B     	 ldr r3,.L120+52
 914 0392 9B7A     	 ldrb r3,[r3,#10]
 915 0394 9BB2     	 uxth r3,r3
 916 0396 1B02     	 lsl r3,r3,#8
 917 0398 9AB2     	 uxth r2,r3
 918 039a 1D4B     	 ldr r3,.L120+52
 919 039c DB7A     	 ldrb r3,[r3,#11]
 920 039e 9BB2     	 uxth r3,r3
 921 03a0 D318     	 add r3,r2,r3
 922 03a2 9AB2     	 uxth r2,r3
 923 03a4 3D4B     	 ldr r3,.L120+192
 924 03a6 1A80     	 strh r2,[r3]
 141:../main.c     **** 		dimNorm2_Ww = ReadBuffer2[12] * 0x100 + ReadBuffer2[13];
 925              	 .loc 5 141 0
 926 03a8 194B     	 ldr r3,.L120+52
 927 03aa 1B7B     	 ldrb r3,[r3,#12]
 928 03ac 9BB2     	 uxth r3,r3
 929 03ae 1B02     	 lsl r3,r3,#8
 930 03b0 9AB2     	 uxth r2,r3
 931 03b2 174B     	 ldr r3,.L120+52
 932 03b4 5B7B     	 ldrb r3,[r3,#13]
 933 03b6 9BB2     	 uxth r3,r3
 934 03b8 D318     	 add r3,r2,r3
 935 03ba 9AB2     	 uxth r2,r3
 936 03bc 384B     	 ldr r3,.L120+196
 937 03be 1A80     	 strh r2,[r3]
 142:../main.c     **** 		dimNorm2_Cw = ReadBuffer2[14] * 0x100 + ReadBuffer2[15];
 938              	 .loc 5 142 0
 939 03c0 134B     	 ldr r3,.L120+52
 940 03c2 9B7B     	 ldrb r3,[r3,#14]
 941 03c4 9BB2     	 uxth r3,r3
 942 03c6 1B02     	 lsl r3,r3,#8
 943 03c8 9AB2     	 uxth r2,r3
 944 03ca 114B     	 ldr r3,.L120+52
 945 03cc DB7B     	 ldrb r3,[r3,#15]
 946 03ce 9BB2     	 uxth r3,r3
 947 03d0 D318     	 add r3,r2,r3
 948 03d2 9AB2     	 uxth r2,r3
 949 03d4 334B     	 ldr r3,.L120+200
 950 03d6 1A80     	 strh r2,[r3]
 951 03d8 68E0     	 b .L21
 952              	.L121:
 953 03da C046     	 .align 2
 954              	.L120:
 955 03dc 00000000 	 .word Dstatus
 956 03e0 00000000 	 .word tester
 957 03e4 00000000 	 .word ReadBuffer1
 958 03e8 00000000 	 .word Ser_NrH
 959 03ec 00000000 	 .word Ser_NrL
 960 03f0 00000000 	 .word Hard_Vers
 961 03f4 00000000 	 .word Soft_Vers
 962 03f8 00000000 	 .word GEH_Vers
 963 03fc 00000000 	 .word Mon_Vers
 964 0400 00000000 	 .word LED_WW_Vers
 965 0404 00000000 	 .word LED_CW_Vers
 966 0408 00000000 	 .word neu_Ser_NrH
 967 040c 00000000 	 .word neu_Ser_NrL
 968 0410 00000000 	 .word ReadBuffer2
 969 0414 00000000 	 .word node_id_alt
 970 0418 00000000 	 .word node_id
 971 041c 00000000 	 .word node_id_16bit
 972 0420 00000000 	 .word val_Pow_Nom
 973 0424 00000000 	 .word val_Pow_max
 974 0428 00000000 	 .word val_Spannung_min
 975 042c 00000000 	 .word val_Spannung_max
 976 0430 00000000 	 .word led_grupp
 977 0434 00000000 	 .word led_Strom
 978 0438 00000000 	 .word node_id_neu
 979 043c 00000000 	 .word Dimm_Gamma
 980 0440 00000000 	 .word Dimm_Stufen
 981 0444 00000000 	 .word Dimm_StufenGR
 982 0448 00000000 	 .word Dimm_Valu
 983 044c 00000000 	 .word Smooth_Value
 984 0450 00000000 	 .word linearwalk_gen
 985 0454 00000000 	 .word Farbe_wwcw_Quot_gen
 986 0458 00000000 	 .word Reserve_1
 987 045c 00000000 	 .word Dimm_Max_WW
 988 0460 00000000 	 .word Dimm_Max_CW
 989 0464 00000000 	 .word linearwalk_ww1
 990 0468 00000000 	 .word linearwalk_ww2
 991 046c 00000000 	 .word linearwalk_cw1
 992 0470 00000000 	 .word linearwalk_cw2
 993 0474 00000000 	 .word Farbe_ww1_Quot
 994 0478 00000000 	 .word Farbe_cw1_Quot
 995 047c 00000000 	 .word Farbe_ww2_Quot
 996 0480 00000000 	 .word Farbe_cw2_Quot
 997 0484 00000000 	 .word RegOnOff
 998 0488 00000000 	 .word RegOnOff2
 999 048c 00000000 	 .word Reserve_2
 1000 0490 00000000 	 .word dimOff_Ww
 1001 0494 00000000 	 .word dimOff_Cw
 1002 0498 00000000 	 .word dimNorm1_Ww
 1003 049c 00000000 	 .word dimNorm1_Cw
 1004 04a0 00000000 	 .word dimNorm2_Ww
 1005 04a4 00000000 	 .word dimNorm2_Cw
 1006              	.L20:
 143:../main.c     **** 
 144:../main.c     **** 
 145:../main.c     **** 
 146:../main.c     **** 	}
 147:../main.c     **** 	else
 148:../main.c     **** 	{
 149:../main.c     **** 	sysiniValueB5();
 1007              	 .loc 5 149 0
 1008 04a8 FFF7FEFF 	 bl sysiniValueB5
 1009              	.L21:
 150:../main.c     **** 	}
 151:../main.c     **** 
 152:../main.c     **** 
 153:../main.c     **** 
 154:../main.c     **** 		// bergabe Variablen
 155:../main.c     **** 	    new_data_fill();
 1010              	 .loc 5 155 0
 1011 04ac FFF7FEFF 	 bl new_data_fill
 156:../main.c     **** 
 157:../main.c     **** 		// Start Farbberechnungen
 158:../main.c     **** 
 159:../main.c     **** 		  bcuInit();
 1012              	 .loc 5 159 0
 1013 04b0 FFF7FEFF 	 bl bcuInit
 160:../main.c     **** 		  linearwalk_gen = 100;
 1014              	 .loc 5 160 0
 1015 04b4 CE4B     	 ldr r3,.L122
 1016 04b6 6422     	 mov r2,#100
 1017 04b8 1A80     	 strh r2,[r3]
 161:../main.c     **** 	      linearwalk_ww1 = linearwalk_gen;//n+l
 1018              	 .loc 5 161 0
 1019 04ba CD4B     	 ldr r3,.L122
 1020 04bc 1A88     	 ldrh r2,[r3]
 1021 04be CD4B     	 ldr r3,.L122+4
 1022 04c0 1A80     	 strh r2,[r3]
 162:../main.c     **** 	      linearwalk_ww2 = linearwalk_gen;//n+l
 1023              	 .loc 5 162 0
 1024 04c2 CB4B     	 ldr r3,.L122
 1025 04c4 1A88     	 ldrh r2,[r3]
 1026 04c6 CC4B     	 ldr r3,.L122+8
 1027 04c8 1A80     	 strh r2,[r3]
 163:../main.c     **** 	      linearwalk_cw1 = linearwalk_gen;//n+l
 1028              	 .loc 5 163 0
 1029 04ca C94B     	 ldr r3,.L122
 1030 04cc 1A88     	 ldrh r2,[r3]
 1031 04ce CB4B     	 ldr r3,.L122+12
 1032 04d0 1A80     	 strh r2,[r3]
 164:../main.c     **** 	      linearwalk_cw2 = linearwalk_gen;  //n+l
 1033              	 .loc 5 164 0
 1034 04d2 C74B     	 ldr r3,.L122
 1035 04d4 1A88     	 ldrh r2,[r3]
 1036 04d6 CA4B     	 ldr r3,.L122+16
 1037 04d8 1A80     	 strh r2,[r3]
 165:../main.c     **** 
 166:../main.c     **** 			 dimAkt_Ww =  0x07ff;//n+l
 1038              	 .loc 5 166 0
 1039 04da CA4B     	 ldr r3,.L122+20
 1040 04dc CA4A     	 ldr r2,.L122+24
 1041 04de 1A80     	 strh r2,[r3]
 167:../main.c     **** 			 dimAkt_Cw =  0x07ff;//n+l
 1042              	 .loc 5 167 0
 1043 04e0 CA4B     	 ldr r3,.L122+28
 1044 04e2 C94A     	 ldr r2,.L122+24
 1045 04e4 1A80     	 strh r2,[r3]
 168:../main.c     **** 
 169:../main.c     **** 	//n+l	  bcuAktBerechnung();
 170:../main.c     **** 	//	  bcudirAktBerechnung();//n+l
 171:../main.c     **** 	//	  bcuUebergabe();
 172:../main.c     **** 
 173:../main.c     **** 
 174:../main.c     ****    //Placeholder for user application code. The while loop below can be replaced with user applicat
 175:../main.c     ****    TimerId = SYSTIMER_CreateTimer(ONESEC,SYSTIMER_MODE_PERIODIC,(void*)LED_Toggle_EverySec,NULL);
 1046              	 .loc 5 175 0
 1047 04e6 CA4A     	 ldr r2,.L122+32
 1048 04e8 CA4B     	 ldr r3,.L122+36
 1049 04ea 101C     	 mov r0,r2
 1050 04ec 0121     	 mov r1,#1
 1051 04ee 1A1C     	 mov r2,r3
 1052 04f0 0023     	 mov r3,#0
 1053 04f2 FFF7FEFF 	 bl SYSTIMER_CreateTimer
 1054 04f6 031C     	 mov r3,r0
 1055 04f8 7B61     	 str r3,[r7,#20]
 176:../main.c     ****     if(TimerId != 0U)
 1056              	 .loc 5 176 0
 1057 04fa 7B69     	 ldr r3,[r7,#20]
 1058 04fc 002B     	 cmp r3,#0
 1059 04fe 05D0     	 beq .L22
 177:../main.c     ****     {
 178:../main.c     ****       status = SYSTIMER_StartTimer(TimerId);
 1060              	 .loc 5 178 0
 1061 0500 7B69     	 ldr r3,[r7,#20]
 1062 0502 181C     	 mov r0,r3
 1063 0504 FFF7FEFF 	 bl SYSTIMER_StartTimer
 1064 0508 031C     	 mov r3,r0
 1065 050a 3B61     	 str r3,[r7,#16]
 1066              	.L22:
 179:../main.c     ****       if(status == SYSTIMER_STATUS_SUCCESS)
 180:../main.c     ****       {
 181:../main.c     ****         // Timer is running
 182:../main.c     ****       }
 183:../main.c     ****       else
 184:../main.c     ****       {
 185:../main.c     ****         // Error during software timer start operation
 186:../main.c     ****       }
 187:../main.c     ****     }
 188:../main.c     ****     else
 189:../main.c     ****     {
 190:../main.c     ****       // Timer ID Can not be zero
 191:../main.c     ****     }
 192:../main.c     ****     //____________________________________________
 193:../main.c     **** 
 194:../main.c     ****     Timer1M = SYSTIMER_CreateTimer(T1milliSEC,SYSTIMER_MODE_PERIODIC,(void*)Time1msec,NULL);
 1067              	 .loc 5 194 0
 1068 050c FA23     	 mov r3,#250
 1069 050e 9A00     	 lsl r2,r3,#2
 1070 0510 C14B     	 ldr r3,.L122+40
 1071 0512 101C     	 mov r0,r2
 1072 0514 0121     	 mov r1,#1
 1073 0516 1A1C     	 mov r2,r3
 1074 0518 0023     	 mov r3,#0
 1075 051a FFF7FEFF 	 bl SYSTIMER_CreateTimer
 1076 051e 031C     	 mov r3,r0
 1077 0520 FB60     	 str r3,[r7,#12]
 195:../main.c     ****      if(Timer1M != 0U)
 1078              	 .loc 5 195 0
 1079 0522 FB68     	 ldr r3,[r7,#12]
 1080 0524 002B     	 cmp r3,#0
 1081 0526 05D0     	 beq .L23
 196:../main.c     ****      {
 197:../main.c     ****        status1M = SYSTIMER_StartTimer(Timer1M);
 1082              	 .loc 5 197 0
 1083 0528 FB68     	 ldr r3,[r7,#12]
 1084 052a 181C     	 mov r0,r3
 1085 052c FFF7FEFF 	 bl SYSTIMER_StartTimer
 1086 0530 031C     	 mov r3,r0
 1087 0532 BB60     	 str r3,[r7,#8]
 1088              	.L23:
 198:../main.c     ****        if(status1M == SYSTIMER_STATUS_SUCCESS)
 199:../main.c     ****        {
 200:../main.c     ****        }
 201:../main.c     ****        else
 202:../main.c     ****        {
 203:../main.c     **** 
 204:../main.c     ****        }
 205:../main.c     ****      }
 206:../main.c     ****      else
 207:../main.c     ****      {
 208:../main.c     ****      }
 209:../main.c     ****     //____________________________________________
 210:../main.c     **** 
 211:../main.c     ****      Timer20M = SYSTIMER_CreateTimer(T20milliSEC,SYSTIMER_MODE_PERIODIC,(void*)Time20msec,NULL);
 1089              	 .loc 5 211 0
 1090 0534 B94A     	 ldr r2,.L122+44
 1091 0536 BA4B     	 ldr r3,.L122+48
 1092 0538 101C     	 mov r0,r2
 1093 053a 0121     	 mov r1,#1
 1094 053c 1A1C     	 mov r2,r3
 1095 053e 0023     	 mov r3,#0
 1096 0540 FFF7FEFF 	 bl SYSTIMER_CreateTimer
 1097 0544 031C     	 mov r3,r0
 1098 0546 7B60     	 str r3,[r7,#4]
 212:../main.c     ****       if(Timer20M != 0U)
 1099              	 .loc 5 212 0
 1100 0548 7B68     	 ldr r3,[r7,#4]
 1101 054a 002B     	 cmp r3,#0
 1102 054c 05D0     	 beq .L24
 213:../main.c     ****       {
 214:../main.c     ****         status20M = SYSTIMER_StartTimer(Timer20M);
 1103              	 .loc 5 214 0
 1104 054e 7B68     	 ldr r3,[r7,#4]
 1105 0550 181C     	 mov r0,r3
 1106 0552 FFF7FEFF 	 bl SYSTIMER_StartTimer
 1107 0556 031C     	 mov r3,r0
 1108 0558 3B60     	 str r3,[r7]
 1109              	.L24:
 215:../main.c     ****         if(status20M == SYSTIMER_STATUS_SUCCESS)
 216:../main.c     ****         {
 217:../main.c     ****         }
 218:../main.c     ****         else
 219:../main.c     ****         {
 220:../main.c     **** 
 221:../main.c     ****         }
 222:../main.c     ****       }
 223:../main.c     ****       else
 224:../main.c     ****       {
 225:../main.c     ****       }
 226:../main.c     **** 
 227:../main.c     **** 	//START hardware #################################################################################
 228:../main.c     **** 
 229:../main.c     **** 
 230:../main.c     ****     DIGITAL_IO_SetOutputHigh(&xmc_lin_en);
 1110              	 .loc 5 230 0
 1111 055a B24B     	 ldr r3,.L122+52
 1112 055c 181C     	 mov r0,r3
 1113 055e FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 231:../main.c     **** 	DIGITAL_IO_SetOutputHigh(&VCC_LED_shtdwn);
 1114              	 .loc 5 231 0
 1115 0562 B14B     	 ldr r3,.L122+56
 1116 0564 181C     	 mov r0,r3
 1117 0566 FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 232:../main.c     ****    // analog_start () ;
 233:../main.c     ****     ADC_MEASUREMENT_ADV_SoftwareTrigger(&ADC_MEASUREMENT_ADV_0);
 1118              	 .loc 5 233 0
 1119 056a B04B     	 ldr r3,.L122+60
 1120 056c 181C     	 mov r0,r3
 1121 056e FFF7FEFF 	 bl ADC_MEASUREMENT_ADV_SoftwareTrigger
 1122              	.L117:
 234:../main.c     **** 
 235:../main.c     **** 
 236:../main.c     **** 
 237:../main.c     **** 
 238:../main.c     **** 
 239:../main.c     **** 
 240:../main.c     **** 	//#############################################
 241:../main.c     **** 
 242:../main.c     **** 	while(1U)
 243:../main.c     **** 	{
 244:../main.c     **** 
 245:../main.c     **** 		if(   UART_Receive(&UART_1, ReadData, 1) == UART_STATUS_SUCCESS)
 1123              	 .loc 5 245 0
 1124 0572 AF4A     	 ldr r2,.L122+64
 1125 0574 AF4B     	 ldr r3,.L122+68
 1126 0576 101C     	 mov r0,r2
 1127 0578 191C     	 mov r1,r3
 1128 057a 0122     	 mov r2,#1
 1129 057c FFF7FEFF 	 bl UART_Receive
 1130 0580 031E     	 sub r3,r0,#0
 1131 0582 01D0     	 beq .LCB904
 1132 0584 01F005FC 	 bl .L25
 1133              	.LCB904:
 246:../main.c     **** 		{
 247:../main.c     **** 			while(UART_1.runtime->rx_busy)
 1134              	 .loc 5 247 0
 1135 0588 C046     	 mov r8,r8
 1136              	.L26:
 1137              	 .loc 5 247 0 is_stmt 0 discriminator 1
 1138 058a A94B     	 ldr r3,.L122+64
 1139 058c 9B68     	 ldr r3,[r3,#8]
 1140 058e 5B7E     	 ldrb r3,[r3,#25]
 1141 0590 DBB2     	 uxtb r3,r3
 1142 0592 002B     	 cmp r3,#0
 1143 0594 F9D1     	 bne .L26
 248:../main.c     **** 		 	{
 249:../main.c     **** 		 	}
 250:../main.c     **** 
 251:../main.c     **** 
 252:../main.c     **** 
 253:../main.c     **** 			 //START UART ##################################################################################
 254:../main.c     **** 			 if ( charcount == 0 && synclevel == 0 && ReadData[0] == 0x4C )
 1144              	 .loc 5 254 0 is_stmt 1
 1145 0596 A84B     	 ldr r3,.L122+72
 1146 0598 1B78     	 ldrb r3,[r3]
 1147 059a 002B     	 cmp r3,#0
 1148 059c 0ED1     	 bne .L27
 1149              	 .loc 5 254 0 is_stmt 0 discriminator 1
 1150 059e A74B     	 ldr r3,.L122+76
 1151 05a0 1B78     	 ldrb r3,[r3]
 1152 05a2 002B     	 cmp r3,#0
 1153 05a4 0AD1     	 bne .L27
 1154              	 .loc 5 254 0 discriminator 2
 1155 05a6 A34B     	 ldr r3,.L122+68
 1156 05a8 1B78     	 ldrb r3,[r3]
 1157 05aa 4C2B     	 cmp r3,#76
 1158 05ac 06D1     	 bne .L27
 255:../main.c     **** 			 {
 256:../main.c     **** 			 	charcount = 1;
 1159              	 .loc 5 256 0 is_stmt 1
 1160 05ae A24B     	 ldr r3,.L122+72
 1161 05b0 0122     	 mov r2,#1
 1162 05b2 1A70     	 strb r2,[r3]
 257:../main.c     **** 			 	synclevel = 1;
 1163              	 .loc 5 257 0
 1164 05b4 A14B     	 ldr r3,.L122+76
 1165 05b6 0122     	 mov r2,#1
 1166 05b8 1A70     	 strb r2,[r3]
 1167 05ba B4E0     	 b .L28
 1168              	.L27:
 258:../main.c     **** 			 }
 259:../main.c     **** 			 else if (  charcount == 1 && synclevel == 1 && ReadData[0] == 0x49 )
 1169              	 .loc 5 259 0
 1170 05bc 9E4B     	 ldr r3,.L122+72
 1171 05be 1B78     	 ldrb r3,[r3]
 1172 05c0 012B     	 cmp r3,#1
 1173 05c2 0ED1     	 bne .L29
 1174              	 .loc 5 259 0 is_stmt 0 discriminator 1
 1175 05c4 9D4B     	 ldr r3,.L122+76
 1176 05c6 1B78     	 ldrb r3,[r3]
 1177 05c8 012B     	 cmp r3,#1
 1178 05ca 0AD1     	 bne .L29
 1179              	 .loc 5 259 0 discriminator 2
 1180 05cc 994B     	 ldr r3,.L122+68
 1181 05ce 1B78     	 ldrb r3,[r3]
 1182 05d0 492B     	 cmp r3,#73
 1183 05d2 06D1     	 bne .L29
 260:../main.c     **** 			 {
 261:../main.c     **** 			 	charcount = 2;
 1184              	 .loc 5 261 0 is_stmt 1
 1185 05d4 984B     	 ldr r3,.L122+72
 1186 05d6 0222     	 mov r2,#2
 1187 05d8 1A70     	 strb r2,[r3]
 262:../main.c     **** 			 	synclevel = 2;
 1188              	 .loc 5 262 0
 1189 05da 984B     	 ldr r3,.L122+76
 1190 05dc 0222     	 mov r2,#2
 1191 05de 1A70     	 strb r2,[r3]
 1192 05e0 A1E0     	 b .L28
 1193              	.L29:
 263:../main.c     **** 			 }
 264:../main.c     **** 			 else if (  charcount ==2 && synclevel == 2 && ReadData[0] == 0x4E )
 1194              	 .loc 5 264 0
 1195 05e2 954B     	 ldr r3,.L122+72
 1196 05e4 1B78     	 ldrb r3,[r3]
 1197 05e6 022B     	 cmp r3,#2
 1198 05e8 0ED1     	 bne .L30
 1199              	 .loc 5 264 0 is_stmt 0 discriminator 1
 1200 05ea 944B     	 ldr r3,.L122+76
 1201 05ec 1B78     	 ldrb r3,[r3]
 1202 05ee 022B     	 cmp r3,#2
 1203 05f0 0AD1     	 bne .L30
 1204              	 .loc 5 264 0 discriminator 2
 1205 05f2 904B     	 ldr r3,.L122+68
 1206 05f4 1B78     	 ldrb r3,[r3]
 1207 05f6 4E2B     	 cmp r3,#78
 1208 05f8 06D1     	 bne .L30
 265:../main.c     **** 			 {
 266:../main.c     **** 			 	charcount = 3;
 1209              	 .loc 5 266 0 is_stmt 1
 1210 05fa 8F4B     	 ldr r3,.L122+72
 1211 05fc 0322     	 mov r2,#3
 1212 05fe 1A70     	 strb r2,[r3]
 267:../main.c     **** 			 	synclevel = 3;
 1213              	 .loc 5 267 0
 1214 0600 8E4B     	 ldr r3,.L122+76
 1215 0602 0322     	 mov r2,#3
 1216 0604 1A70     	 strb r2,[r3]
 1217 0606 8EE0     	 b .L28
 1218              	.L30:
 268:../main.c     **** 			 }
 269:../main.c     **** 			 else if (  charcount == 3 && synclevel == 3 )
 1219              	 .loc 5 269 0
 1220 0608 8B4B     	 ldr r3,.L122+72
 1221 060a 1B78     	 ldrb r3,[r3]
 1222 060c 032B     	 cmp r3,#3
 1223 060e 0BD1     	 bne .L31
 1224              	 .loc 5 269 0 is_stmt 0 discriminator 1
 1225 0610 8A4B     	 ldr r3,.L122+76
 1226 0612 1B78     	 ldrb r3,[r3]
 1227 0614 032B     	 cmp r3,#3
 1228 0616 07D1     	 bne .L31
 270:../main.c     **** 			 {
 271:../main.c     **** 			 	charcount = 4;
 1229              	 .loc 5 271 0 is_stmt 1
 1230 0618 874B     	 ldr r3,.L122+72
 1231 061a 0422     	 mov r2,#4
 1232 061c 1A70     	 strb r2,[r3]
 272:../main.c     **** 			 	node_id_resi = ReadData[0];
 1233              	 .loc 5 272 0
 1234 061e 854B     	 ldr r3,.L122+68
 1235 0620 1A78     	 ldrb r2,[r3]
 1236 0622 874B     	 ldr r3,.L122+80
 1237 0624 1A70     	 strb r2,[r3]
 1238 0626 7EE0     	 b .L28
 1239              	.L31:
 273:../main.c     **** 			 }
 274:../main.c     **** 			 else if (  charcount == 4 && synclevel == 3 )
 1240              	 .loc 5 274 0
 1241 0628 834B     	 ldr r3,.L122+72
 1242 062a 1B78     	 ldrb r3,[r3]
 1243 062c 042B     	 cmp r3,#4
 1244 062e 0BD1     	 bne .L32
 1245              	 .loc 5 274 0 is_stmt 0 discriminator 1
 1246 0630 824B     	 ldr r3,.L122+76
 1247 0632 1B78     	 ldrb r3,[r3]
 1248 0634 032B     	 cmp r3,#3
 1249 0636 07D1     	 bne .L32
 275:../main.c     **** 			 {
 276:../main.c     **** 			 	charcount = 5;
 1250              	 .loc 5 276 0 is_stmt 1
 1251 0638 7F4B     	 ldr r3,.L122+72
 1252 063a 0522     	 mov r2,#5
 1253 063c 1A70     	 strb r2,[r3]
 277:../main.c     **** 			 	framelength = ReadData[0];
 1254              	 .loc 5 277 0
 1255 063e 7D4B     	 ldr r3,.L122+68
 1256 0640 1A78     	 ldrb r2,[r3]
 1257 0642 804B     	 ldr r3,.L122+84
 1258 0644 1A70     	 strb r2,[r3]
 1259 0646 6EE0     	 b .L28
 1260              	.L32:
 278:../main.c     **** 			 }
 279:../main.c     **** 			 else if ( charcount == 5 && synclevel == 3 )
 1261              	 .loc 5 279 0
 1262 0648 7B4B     	 ldr r3,.L122+72
 1263 064a 1B78     	 ldrb r3,[r3]
 1264 064c 052B     	 cmp r3,#5
 1265 064e 0BD1     	 bne .L33
 1266              	 .loc 5 279 0 is_stmt 0 discriminator 1
 1267 0650 7A4B     	 ldr r3,.L122+76
 1268 0652 1B78     	 ldrb r3,[r3]
 1269 0654 032B     	 cmp r3,#3
 1270 0656 07D1     	 bne .L33
 280:../main.c     **** 			 {
 281:../main.c     **** 			 	charcount = 6;
 1271              	 .loc 5 281 0 is_stmt 1
 1272 0658 774B     	 ldr r3,.L122+72
 1273 065a 0622     	 mov r2,#6
 1274 065c 1A70     	 strb r2,[r3]
 282:../main.c     **** 		 		command = ReadData[0];
 1275              	 .loc 5 282 0
 1276 065e 754B     	 ldr r3,.L122+68
 1277 0660 1A78     	 ldrb r2,[r3]
 1278 0662 794B     	 ldr r3,.L122+88
 1279 0664 1A70     	 strb r2,[r3]
 1280 0666 5EE0     	 b .L28
 1281              	.L33:
 283:../main.c     **** 			 }
 284:../main.c     **** 			 else if ( charcount == 6 && synclevel == 3 )
 1282              	 .loc 5 284 0
 1283 0668 734B     	 ldr r3,.L122+72
 1284 066a 1B78     	 ldrb r3,[r3]
 1285 066c 062B     	 cmp r3,#6
 1286 066e 0BD1     	 bne .L34
 1287              	 .loc 5 284 0 is_stmt 0 discriminator 1
 1288 0670 724B     	 ldr r3,.L122+76
 1289 0672 1B78     	 ldrb r3,[r3]
 1290 0674 032B     	 cmp r3,#3
 1291 0676 07D1     	 bne .L34
 285:../main.c     **** 			 {
 286:../main.c     **** 			 	charcount = 7;
 1292              	 .loc 5 286 0 is_stmt 1
 1293 0678 6F4B     	 ldr r3,.L122+72
 1294 067a 0722     	 mov r2,#7
 1295 067c 1A70     	 strb r2,[r3]
 287:../main.c     **** 			 	ReadData[1] = ReadData[0];
 1296              	 .loc 5 287 0
 1297 067e 6D4B     	 ldr r3,.L122+68
 1298 0680 1A78     	 ldrb r2,[r3]
 1299 0682 6C4B     	 ldr r3,.L122+68
 1300 0684 5A70     	 strb r2,[r3,#1]
 1301 0686 4EE0     	 b .L28
 1302              	.L34:
 288:../main.c     **** 			 }
 289:../main.c     **** 			 else if ( charcount == 7 && synclevel == 3 )
 1303              	 .loc 5 289 0
 1304 0688 6B4B     	 ldr r3,.L122+72
 1305 068a 1B78     	 ldrb r3,[r3]
 1306 068c 072B     	 cmp r3,#7
 1307 068e 0BD1     	 bne .L35
 1308              	 .loc 5 289 0 is_stmt 0 discriminator 1
 1309 0690 6A4B     	 ldr r3,.L122+76
 1310 0692 1B78     	 ldrb r3,[r3]
 1311 0694 032B     	 cmp r3,#3
 1312 0696 07D1     	 bne .L35
 290:../main.c     **** 			 {
 291:../main.c     **** 			 	charcount = 8;
 1313              	 .loc 5 291 0 is_stmt 1
 1314 0698 674B     	 ldr r3,.L122+72
 1315 069a 0822     	 mov r2,#8
 1316 069c 1A70     	 strb r2,[r3]
 292:../main.c     **** 			 	ReadData[2] = ReadData[0];
 1317              	 .loc 5 292 0
 1318 069e 654B     	 ldr r3,.L122+68
 1319 06a0 1A78     	 ldrb r2,[r3]
 1320 06a2 644B     	 ldr r3,.L122+68
 1321 06a4 9A70     	 strb r2,[r3,#2]
 1322 06a6 3EE0     	 b .L28
 1323              	.L35:
 293:../main.c     **** 			 }
 294:../main.c     **** 			 else if ( charcount == 8 && synclevel == 3 )
 1324              	 .loc 5 294 0
 1325 06a8 634B     	 ldr r3,.L122+72
 1326 06aa 1B78     	 ldrb r3,[r3]
 1327 06ac 082B     	 cmp r3,#8
 1328 06ae 0BD1     	 bne .L36
 1329              	 .loc 5 294 0 is_stmt 0 discriminator 1
 1330 06b0 624B     	 ldr r3,.L122+76
 1331 06b2 1B78     	 ldrb r3,[r3]
 1332 06b4 032B     	 cmp r3,#3
 1333 06b6 07D1     	 bne .L36
 295:../main.c     **** 			 {
 296:../main.c     **** 			 	charcount = 9;
 1334              	 .loc 5 296 0 is_stmt 1
 1335 06b8 5F4B     	 ldr r3,.L122+72
 1336 06ba 0922     	 mov r2,#9
 1337 06bc 1A70     	 strb r2,[r3]
 297:../main.c     **** 			 	ReadData[3] = ReadData[0];
 1338              	 .loc 5 297 0
 1339 06be 5D4B     	 ldr r3,.L122+68
 1340 06c0 1A78     	 ldrb r2,[r3]
 1341 06c2 5C4B     	 ldr r3,.L122+68
 1342 06c4 DA70     	 strb r2,[r3,#3]
 1343 06c6 2EE0     	 b .L28
 1344              	.L36:
 298:../main.c     **** 			 }
 299:../main.c     **** 			 else if ( charcount == 9 && synclevel == 3 )
 1345              	 .loc 5 299 0
 1346 06c8 5B4B     	 ldr r3,.L122+72
 1347 06ca 1B78     	 ldrb r3,[r3]
 1348 06cc 092B     	 cmp r3,#9
 1349 06ce 0BD1     	 bne .L37
 1350              	 .loc 5 299 0 is_stmt 0 discriminator 1
 1351 06d0 5A4B     	 ldr r3,.L122+76
 1352 06d2 1B78     	 ldrb r3,[r3]
 1353 06d4 032B     	 cmp r3,#3
 1354 06d6 07D1     	 bne .L37
 300:../main.c     **** 			 {
 301:../main.c     **** 			 	charcount = 10;
 1355              	 .loc 5 301 0 is_stmt 1
 1356 06d8 574B     	 ldr r3,.L122+72
 1357 06da 0A22     	 mov r2,#10
 1358 06dc 1A70     	 strb r2,[r3]
 302:../main.c     **** 			 	ReadData[4] = ReadData[0];
 1359              	 .loc 5 302 0
 1360 06de 554B     	 ldr r3,.L122+68
 1361 06e0 1A78     	 ldrb r2,[r3]
 1362 06e2 544B     	 ldr r3,.L122+68
 1363 06e4 1A71     	 strb r2,[r3,#4]
 1364 06e6 1EE0     	 b .L28
 1365              	.L37:
 303:../main.c     **** 			 }
 304:../main.c     **** 			 else if ( charcount == 10 && synclevel == 3 && ReadData[0] == 0xFF )
 1366              	 .loc 5 304 0
 1367 06e8 534B     	 ldr r3,.L122+72
 1368 06ea 1B78     	 ldrb r3,[r3]
 1369 06ec 0A2B     	 cmp r3,#10
 1370 06ee 11D1     	 bne .L38
 1371              	 .loc 5 304 0 is_stmt 0 discriminator 1
 1372 06f0 524B     	 ldr r3,.L122+76
 1373 06f2 1B78     	 ldrb r3,[r3]
 1374 06f4 032B     	 cmp r3,#3
 1375 06f6 0DD1     	 bne .L38
 1376              	 .loc 5 304 0 discriminator 2
 1377 06f8 4E4B     	 ldr r3,.L122+68
 1378 06fa 1B78     	 ldrb r3,[r3]
 1379 06fc FF2B     	 cmp r3,#255
 1380 06fe 09D1     	 bne .L38
 305:../main.c     **** 			 {
 306:../main.c     **** 			 	charcount = 0;
 1381              	 .loc 5 306 0 is_stmt 1
 1382 0700 4D4B     	 ldr r3,.L122+72
 1383 0702 0022     	 mov r2,#0
 1384 0704 1A70     	 strb r2,[r3]
 307:../main.c     **** 			 	synclevel = 0;
 1385              	 .loc 5 307 0
 1386 0706 4D4B     	 ldr r3,.L122+76
 1387 0708 0022     	 mov r2,#0
 1388 070a 1A70     	 strb r2,[r3]
 308:../main.c     **** 			 	execute = 1;
 1389              	 .loc 5 308 0
 1390 070c 4F4B     	 ldr r3,.L122+92
 1391 070e 0122     	 mov r2,#1
 1392 0710 1A70     	 strb r2,[r3]
 1393 0712 08E0     	 b .L28
 1394              	.L38:
 309:../main.c     **** 			 }
 310:../main.c     **** 			 else
 311:../main.c     **** 			 {
 312:../main.c     **** 			 	charcount = 0;
 1395              	 .loc 5 312 0
 1396 0714 484B     	 ldr r3,.L122+72
 1397 0716 0022     	 mov r2,#0
 1398 0718 1A70     	 strb r2,[r3]
 313:../main.c     **** 			 	synclevel = 0;
 1399              	 .loc 5 313 0
 1400 071a 484B     	 ldr r3,.L122+76
 1401 071c 0022     	 mov r2,#0
 1402 071e 1A70     	 strb r2,[r3]
 314:../main.c     **** 			 	execute = 0;
 1403              	 .loc 5 314 0
 1404 0720 4A4B     	 ldr r3,.L122+92
 1405 0722 0022     	 mov r2,#0
 1406 0724 1A70     	 strb r2,[r3]
 1407              	.L28:
 315:../main.c     **** 			 }
 316:../main.c     **** 			 // END UART ###################################################################################
 317:../main.c     **** 			 if ( execute == 1 )
 1408              	 .loc 5 317 0
 1409 0726 494B     	 ldr r3,.L122+92
 1410 0728 1B78     	 ldrb r3,[r3]
 1411 072a 012B     	 cmp r3,#1
 1412 072c 01D0     	 beq .LCB1152
 1413 072e 01F030FB 	 bl .L25
 1414              	.LCB1152:
 318:../main.c     **** 		{
 319:../main.c     **** 			 	if (node_id_resi != node_id)
 1415              	 .loc 5 319 0
 1416 0732 434B     	 ldr r3,.L122+80
 1417 0734 1A78     	 ldrb r2,[r3]
 1418 0736 464B     	 ldr r3,.L122+96
 1419 0738 1B78     	 ldrb r3,[r3]
 1420 073a 9A42     	 cmp r2,r3
 1421 073c 00D1     	 bne .LCB1158
 1422 073e DAE0     	 b .L39
 1423              	.LCB1158:
 320:../main.c     **** 			 {
 321:../main.c     **** 				// ohne Node bereinstimmung
 322:../main.c     **** 				switch  (command) {
 1424              	 .loc 5 322 0
 1425 0740 414B     	 ldr r3,.L122+88
 1426 0742 1B78     	 ldrb r3,[r3]
 1427 0744 542B     	 cmp r3,#84
 1428 0746 12D0     	 beq .L41
 1429 0748 552B     	 cmp r3,#85
 1430 074a 00D1     	 bne .LCB1164
 1431 074c 8DE0     	 b .L42
 1432              	.LCB1164:
 1433 074e 4F2B     	 cmp r3,#79
 1434 0750 00D0     	 beq .LCB1166
 1435 0752 CAE0     	 b .L118
 1436              	.LCB1166:
 323:../main.c     **** 				case command_BroadcastResi : 	new_data_BroadcastBack();
 1437              	 .loc 5 323 0
 1438 0754 FFF7FEFF 	 bl new_data_BroadcastBack
 324:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 1439              	 .loc 5 324 0
 1440 0758 3E4B     	 ldr r3,.L122+100
 1441 075a 1B78     	 ldrb r3,[r3]
 1442 075c 1C1C     	 mov r4,r3
 1443 075e 344A     	 ldr r2,.L122+64
 1444 0760 3D4B     	 ldr r3,.L122+104
 1445 0762 101C     	 mov r0,r2
 1446 0764 191C     	 mov r1,r3
 1447 0766 221C     	 mov r2,r4
 1448 0768 FFF7FEFF 	 bl UART_Transmit
 325:../main.c     **** 											break;
 1449              	 .loc 5 325 0
 1450 076c C1E0     	 b .L44
 1451              	.L41:
 326:../main.c     **** 				case command_all_ledOff_Resi :
 327:../main.c     **** 											if (ReadData[1] == 5 && ReadData[2] == 5 &&   ReadData[3] ==  secure_all_ledOffH_Resi  &
 1452              	 .loc 5 327 0
 1453 076e 314B     	 ldr r3,.L122+68
 1454 0770 5B78     	 ldrb r3,[r3,#1]
 1455 0772 052B     	 cmp r3,#5
 1456 0774 00D0     	 beq .LCB1184
 1457 0776 77E0     	 b .L45
 1458              	.LCB1184:
 1459              	 .loc 5 327 0 is_stmt 0 discriminator 1
 1460 0778 2E4B     	 ldr r3,.L122+68
 1461 077a 9B78     	 ldrb r3,[r3,#2]
 1462 077c 052B     	 cmp r3,#5
 1463 077e 73D1     	 bne .L45
 1464              	 .loc 5 327 0 discriminator 2
 1465 0780 2C4B     	 ldr r3,.L122+68
 1466 0782 DB78     	 ldrb r3,[r3,#3]
 1467 0784 342B     	 cmp r3,#52
 1468 0786 6FD1     	 bne .L45
 1469              	 .loc 5 327 0 discriminator 3
 1470 0788 2A4B     	 ldr r3,.L122+68
 1471 078a 1B79     	 ldrb r3,[r3,#4]
 1472 078c 782B     	 cmp r3,#120
 1473 078e 6BD1     	 bne .L45
 328:../main.c     **** 												{new_data_HalloBack();
 1474              	 .loc 5 328 0 is_stmt 1
 1475 0790 FFF7FEFF 	 bl new_data_HalloBack
 329:../main.c     **** 	 	 	 	 	 							B_nextLedOff=1;   // schaltet on led beim spannnungsvergleich aus
 1476              	 .loc 5 329 0
 1477 0794 314B     	 ldr r3,.L122+108
 1478 0796 0122     	 mov r2,#1
 1479 0798 1A70     	 strb r2,[r3]
 330:../main.c     **** 												DIGITAL_IO_SetOutputLow(&VCC_LED_shtdwn);
 1480              	 .loc 5 330 0
 1481 079a 234B     	 ldr r3,.L122+56
 1482 079c 181C     	 mov r0,r3
 1483 079e FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 331:../main.c     **** 												new_data[5]= command_all_ledOffBack ;
 1484              	 .loc 5 331 0
 1485 07a2 2D4B     	 ldr r3,.L122+104
 1486 07a4 7422     	 mov r2,#116
 1487 07a6 5A71     	 strb r2,[r3,#5]
 332:../main.c     **** 												new_data[6]= Ser_NrH  / 0x100 ;
 1488              	 .loc 5 332 0
 1489 07a8 2D4B     	 ldr r3,.L122+112
 1490 07aa 1B88     	 ldrh r3,[r3]
 1491 07ac 1B0A     	 lsr r3,r3,#8
 1492 07ae 9BB2     	 uxth r3,r3
 1493 07b0 DAB2     	 uxtb r2,r3
 1494 07b2 294B     	 ldr r3,.L122+104
 1495 07b4 9A71     	 strb r2,[r3,#6]
 333:../main.c     **** 												new_data[7]= Ser_NrH  & 0xff ;
 1496              	 .loc 5 333 0
 1497 07b6 2A4B     	 ldr r3,.L122+112
 1498 07b8 1B88     	 ldrh r3,[r3]
 1499 07ba DAB2     	 uxtb r2,r3
 1500 07bc 264B     	 ldr r3,.L122+104
 1501 07be DA71     	 strb r2,[r3,#7]
 334:../main.c     **** 												new_data[8]= Ser_NrL  / 0x100 ;
 1502              	 .loc 5 334 0
 1503 07c0 284B     	 ldr r3,.L122+116
 1504 07c2 1B88     	 ldrh r3,[r3]
 1505 07c4 1B0A     	 lsr r3,r3,#8
 1506 07c6 9BB2     	 uxth r3,r3
 1507 07c8 DAB2     	 uxtb r2,r3
 1508 07ca 234B     	 ldr r3,.L122+104
 1509 07cc 1A72     	 strb r2,[r3,#8]
 335:../main.c     **** 												new_data[9]= Ser_NrL  & 0xff ;
 1510              	 .loc 5 335 0
 1511 07ce 254B     	 ldr r3,.L122+116
 1512 07d0 1B88     	 ldrh r3,[r3]
 1513 07d2 DAB2     	 uxtb r2,r3
 1514 07d4 204B     	 ldr r3,.L122+104
 1515 07d6 5A72     	 strb r2,[r3,#9]
 336:../main.c     **** 
 337:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 1516              	 .loc 5 337 0
 1517 07d8 1E4B     	 ldr r3,.L122+100
 1518 07da 1B78     	 ldrb r3,[r3]
 1519 07dc 1C1C     	 mov r4,r3
 1520 07de 144A     	 ldr r2,.L122+64
 1521 07e0 1D4B     	 ldr r3,.L122+104
 1522 07e2 101C     	 mov r0,r2
 1523 07e4 191C     	 mov r1,r3
 1524 07e6 221C     	 mov r2,r4
 1525 07e8 FFF7FEFF 	 bl UART_Transmit
 338:../main.c     **** 												}
 339:../main.c     **** 											break;
 1526              	 .loc 5 339 0
 1527 07ec 81E0     	 b .L44
 1528              	.L123:
 1529 07ee C046     	 .align 2
 1530              	.L122:
 1531 07f0 00000000 	 .word linearwalk_gen
 1532 07f4 00000000 	 .word linearwalk_ww1
 1533 07f8 00000000 	 .word linearwalk_ww2
 1534 07fc 00000000 	 .word linearwalk_cw1
 1535 0800 00000000 	 .word linearwalk_cw2
 1536 0804 00000000 	 .word dimAkt_Ww
 1537 0808 FF070000 	 .word 2047
 1538 080c 00000000 	 .word dimAkt_Cw
 1539 0810 40420F00 	 .word 1000000
 1540 0814 00000000 	 .word LED_Toggle_EverySec
 1541 0818 00000000 	 .word Time1msec
 1542 081c 204E0000 	 .word 20000
 1543 0820 00000000 	 .word Time20msec
 1544 0824 00000000 	 .word xmc_lin_en
 1545 0828 00000000 	 .word VCC_LED_shtdwn
 1546 082c 00000000 	 .word ADC_MEASUREMENT_ADV_0
 1547 0830 00000000 	 .word UART_1
 1548 0834 00000000 	 .word ReadData
 1549 0838 00000000 	 .word charcount
 1550 083c 00000000 	 .word synclevel
 1551 0840 00000000 	 .word node_id_resi
 1552 0844 00000000 	 .word framelength
 1553 0848 00000000 	 .word command
 1554 084c 00000000 	 .word execute
 1555 0850 00000000 	 .word node_id
 1556 0854 00000000 	 .word transmit_buf_size
 1557 0858 00000000 	 .word new_data
 1558 085c 00000000 	 .word B_nextLedOff
 1559 0860 00000000 	 .word Ser_NrH
 1560 0864 00000000 	 .word Ser_NrL
 1561              	.L45:
 1562 0868 43E0     	 b .L44
 1563              	.L42:
 340:../main.c     **** 				case command_all_ledOn_Resi :
 341:../main.c     **** 											if (ReadData[1] == 3 && ReadData[2] == 3 &&   ReadData[3] ==  secure_all_ledOnH_Resi  &&
 1564              	 .loc 5 341 0
 1565 086a ED4B     	 ldr r3,.L124
 1566 086c 5B78     	 ldrb r3,[r3,#1]
 1567 086e 032B     	 cmp r3,#3
 1568 0870 3AD1     	 bne .L46
 1569              	 .loc 5 341 0 is_stmt 0 discriminator 1
 1570 0872 EB4B     	 ldr r3,.L124
 1571 0874 9B78     	 ldrb r3,[r3,#2]
 1572 0876 032B     	 cmp r3,#3
 1573 0878 36D1     	 bne .L46
 1574              	 .loc 5 341 0 discriminator 2
 1575 087a E94B     	 ldr r3,.L124
 1576 087c DB78     	 ldrb r3,[r3,#3]
 1577 087e F52B     	 cmp r3,#245
 1578 0880 32D1     	 bne .L46
 1579              	 .loc 5 341 0 discriminator 3
 1580 0882 E74B     	 ldr r3,.L124
 1581 0884 1B79     	 ldrb r3,[r3,#4]
 1582 0886 C52B     	 cmp r3,#197
 1583 0888 2ED1     	 bne .L46
 342:../main.c     **** 												{new_data_HalloBack();
 1584              	 .loc 5 342 0 is_stmt 1
 1585 088a FFF7FEFF 	 bl new_data_HalloBack
 343:../main.c     **** 
 344:../main.c     **** 			  	 	 	 	 	 	 	 	 	B_nextLedOff=0;
 1586              	 .loc 5 344 0
 1587 088e E54B     	 ldr r3,.L124+4
 1588 0890 0022     	 mov r2,#0
 1589 0892 1A70     	 strb r2,[r3]
 345:../main.c     **** 												DIGITAL_IO_SetOutputHigh(&VCC_LED_shtdwn);
 1590              	 .loc 5 345 0
 1591 0894 E44B     	 ldr r3,.L124+8
 1592 0896 181C     	 mov r0,r3
 1593 0898 FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 346:../main.c     **** 												new_data[5]= command_all_ledOnBack ;
 1594              	 .loc 5 346 0
 1595 089c E34B     	 ldr r3,.L124+12
 1596 089e 7522     	 mov r2,#117
 1597 08a0 5A71     	 strb r2,[r3,#5]
 347:../main.c     **** 												new_data[6]= Ser_NrH  / 0x100 ;
 1598              	 .loc 5 347 0
 1599 08a2 E34B     	 ldr r3,.L124+16
 1600 08a4 1B88     	 ldrh r3,[r3]
 1601 08a6 1B0A     	 lsr r3,r3,#8
 1602 08a8 9BB2     	 uxth r3,r3
 1603 08aa DAB2     	 uxtb r2,r3
 1604 08ac DF4B     	 ldr r3,.L124+12
 1605 08ae 9A71     	 strb r2,[r3,#6]
 348:../main.c     **** 												new_data[7]= Ser_NrH  & 0xff ;
 1606              	 .loc 5 348 0
 1607 08b0 DF4B     	 ldr r3,.L124+16
 1608 08b2 1B88     	 ldrh r3,[r3]
 1609 08b4 DAB2     	 uxtb r2,r3
 1610 08b6 DD4B     	 ldr r3,.L124+12
 1611 08b8 DA71     	 strb r2,[r3,#7]
 349:../main.c     **** 												new_data[8]= Ser_NrL  / 0x100 ;
 1612              	 .loc 5 349 0
 1613 08ba DE4B     	 ldr r3,.L124+20
 1614 08bc 1B88     	 ldrh r3,[r3]
 1615 08be 1B0A     	 lsr r3,r3,#8
 1616 08c0 9BB2     	 uxth r3,r3
 1617 08c2 DAB2     	 uxtb r2,r3
 1618 08c4 D94B     	 ldr r3,.L124+12
 1619 08c6 1A72     	 strb r2,[r3,#8]
 350:../main.c     **** 												new_data[9]= Ser_NrL  & 0xff ;
 1620              	 .loc 5 350 0
 1621 08c8 DA4B     	 ldr r3,.L124+20
 1622 08ca 1B88     	 ldrh r3,[r3]
 1623 08cc DAB2     	 uxtb r2,r3
 1624 08ce D74B     	 ldr r3,.L124+12
 1625 08d0 5A72     	 strb r2,[r3,#9]
 351:../main.c     **** 
 352:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 1626              	 .loc 5 352 0
 1627 08d2 D94B     	 ldr r3,.L124+24
 1628 08d4 1B78     	 ldrb r3,[r3]
 1629 08d6 1C1C     	 mov r4,r3
 1630 08d8 D84A     	 ldr r2,.L124+28
 1631 08da D44B     	 ldr r3,.L124+12
 1632 08dc 101C     	 mov r0,r2
 1633 08de 191C     	 mov r1,r3
 1634 08e0 221C     	 mov r2,r4
 1635 08e2 FFF7FEFF 	 bl UART_Transmit
 353:../main.c     **** 												}
 354:../main.c     **** 											break;
 1636              	 .loc 5 354 0
 1637 08e6 04E0     	 b .L44
 1638              	.L46:
 1639              	 .loc 5 354 0 is_stmt 0 discriminator 6
 1640 08e8 03E0     	 b .L44
 1641              	.L118:
 355:../main.c     **** 
 356:../main.c     **** 
 357:../main.c     **** 				default: 						execute = 0;
 1642              	 .loc 5 357 0 is_stmt 1
 1643 08ea D54B     	 ldr r3,.L124+32
 1644 08ec 0022     	 mov r2,#0
 1645 08ee 1A70     	 strb r2,[r3]
 358:../main.c     **** 				break;
 1646              	 .loc 5 358 0
 1647 08f0 C046     	 mov r8,r8
 1648              	.L44:
 1649 08f2 01F04BFA 	 bl .L47
 1650              	.L39:
 359:../main.c     **** 				}
 360:../main.c     **** 			 }
 361:../main.c     **** 			 	else //node_id_resi = node_id)
 362:../main.c     **** 			 {
 363:../main.c     **** 
 364:../main.c     **** 				switch  (command) {
 1651              	 .loc 5 364 0
 1652 08f6 D34B     	 ldr r3,.L124+36
 1653 08f8 1B78     	 ldrb r3,[r3]
 1654 08fa 333B     	 sub r3,r3,#51
 1655 08fc 202B     	 cmp r3,#32
 1656 08fe 01D9     	 bls .LCB1364
 1657 0900 01F043FA 	 bl .L119
 1658              	.LCB1364:
 1659 0904 9A00     	 lsl r2,r3,#2
 1660 0906 D04B     	 ldr r3,.L124+40
 1661 0908 D318     	 add r3,r2,r3
 1662 090a 1B68     	 ldr r3,[r3]
 1663 090c 9F46     	 mov pc,r3
 1664              	 .section .rodata.main,"a",%progbits
 1665              	 .align 2
 1666              	.L50:
 1667 0000 B8170000 	 .word .L49
 1668 0004 3C0F0000 	 .word .L51
 1669 0008 D8100000 	 .word .L52
 1670 000c 8A1D0000 	 .word .L119
 1671 0010 B8150000 	 .word .L53
 1672 0014 86160000 	 .word .L54
 1673 0018 10140000 	 .word .L55
 1674 001c 8A1D0000 	 .word .L119
 1675 0020 8A1D0000 	 .word .L119
 1676 0024 18120000 	 .word .L56
 1677 0028 8A1D0000 	 .word .L119
 1678 002c 8A1D0000 	 .word .L119
 1679 0030 8A1D0000 	 .word .L119
 1680 0034 8A1D0000 	 .word .L119
 1681 0038 2A090000 	 .word .L57
 1682 003c 46090000 	 .word .L58
 1683 0040 8A1D0000 	 .word .L119
 1684 0044 8A1D0000 	 .word .L119
 1685 0048 8A1D0000 	 .word .L119
 1686 004c 62090000 	 .word .L59
 1687 0050 B6090000 	 .word .L60
 1688 0054 DE0A0000 	 .word .L61
 1689 0058 360B0000 	 .word .L62
 1690 005c 020A0000 	 .word .L63
 1691 0060 D20B0000 	 .word .L64
 1692 0064 E20C0000 	 .word .L65
 1693 0068 CC0D0000 	 .word .L66
 1694 006c 340D0000 	 .word .L67
 1695 0070 0E090000 	 .word .L68
 1696 0074 600E0000 	 .word .L69
 1697 0078 CE0E0000 	 .word .L70
 1698 007c 1E0A0000 	 .word .L71
 1699 0080 7E0A0000 	 .word .L72
 1700              	 .section .text.main
 1701              	.L68:
 365:../main.c     **** 
 366:../main.c     **** 				case command_BroadcastResi : 	new_data_BroadcastBack();
 1702              	 .loc 5 366 0
 1703 090e FFF7FEFF 	 bl new_data_BroadcastBack
 367:../main.c     **** 											UART_Transmit(&UART_1, new_data,transmit_buf_size);
 1704              	 .loc 5 367 0
 1705 0912 C94B     	 ldr r3,.L124+24
 1706 0914 1B78     	 ldrb r3,[r3]
 1707 0916 1C1C     	 mov r4,r3
 1708 0918 C84A     	 ldr r2,.L124+28
 1709 091a C44B     	 ldr r3,.L124+12
 1710 091c 101C     	 mov r0,r2
 1711 091e 191C     	 mov r1,r3
 1712 0920 221C     	 mov r2,r4
 1713 0922 FFF7FEFF 	 bl UART_Transmit
 368:../main.c     **** 											break;
 1714              	 .loc 5 368 0
 1715 0926 01F031FA 	 bl .L47
 1716              	.L57:
 369:../main.c     **** 				case command_ana1Resi  :
 370:../main.c     **** 												new_data_analog1Back();
 1717              	 .loc 5 370 0
 1718 092a FFF7FEFF 	 bl new_data_analog1Back
 371:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 1719              	 .loc 5 371 0
 1720 092e C24B     	 ldr r3,.L124+24
 1721 0930 1B78     	 ldrb r3,[r3]
 1722 0932 1C1C     	 mov r4,r3
 1723 0934 C14A     	 ldr r2,.L124+28
 1724 0936 BD4B     	 ldr r3,.L124+12
 1725 0938 101C     	 mov r0,r2
 1726 093a 191C     	 mov r1,r3
 1727 093c 221C     	 mov r2,r4
 1728 093e FFF7FEFF 	 bl UART_Transmit
 372:../main.c     **** 											break;
 1729              	 .loc 5 372 0
 1730 0942 01F023FA 	 bl .L47
 1731              	.L58:
 373:../main.c     **** 				case command_ana2Resi  :
 374:../main.c     **** 												new_data_analog2Back();
 1732              	 .loc 5 374 0
 1733 0946 FFF7FEFF 	 bl new_data_analog2Back
 375:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 1734              	 .loc 5 375 0
 1735 094a BB4B     	 ldr r3,.L124+24
 1736 094c 1B78     	 ldrb r3,[r3]
 1737 094e 1C1C     	 mov r4,r3
 1738 0950 BA4A     	 ldr r2,.L124+28
 1739 0952 B64B     	 ldr r3,.L124+12
 1740 0954 101C     	 mov r0,r2
 1741 0956 191C     	 mov r1,r3
 1742 0958 221C     	 mov r2,r4
 1743 095a FFF7FEFF 	 bl UART_Transmit
 376:../main.c     **** 											break;
 1744              	 .loc 5 376 0
 1745 095e 01F015FA 	 bl .L47
 1746              	.L59:
 377:../main.c     **** 				case command_aktLichtResi : 	dimAkt_Ww=ReadData[1]*0x100+ReadData[2];
 1747              	 .loc 5 377 0
 1748 0962 AF4B     	 ldr r3,.L124
 1749 0964 5B78     	 ldrb r3,[r3,#1]
 1750 0966 9BB2     	 uxth r3,r3
 1751 0968 1B02     	 lsl r3,r3,#8
 1752 096a 9AB2     	 uxth r2,r3
 1753 096c AC4B     	 ldr r3,.L124
 1754 096e 9B78     	 ldrb r3,[r3,#2]
 1755 0970 9BB2     	 uxth r3,r3
 1756 0972 D318     	 add r3,r2,r3
 1757 0974 9AB2     	 uxth r2,r3
 1758 0976 B54B     	 ldr r3,.L124+44
 1759 0978 1A80     	 strh r2,[r3]
 378:../main.c     **** 												dimAkt_Cw=ReadData[3]*0x100+ReadData[4];
 1760              	 .loc 5 378 0
 1761 097a A94B     	 ldr r3,.L124
 1762 097c DB78     	 ldrb r3,[r3,#3]
 1763 097e 9BB2     	 uxth r3,r3
 1764 0980 1B02     	 lsl r3,r3,#8
 1765 0982 9AB2     	 uxth r2,r3
 1766 0984 A64B     	 ldr r3,.L124
 1767 0986 1B79     	 ldrb r3,[r3,#4]
 1768 0988 9BB2     	 uxth r3,r3
 1769 098a D318     	 add r3,r2,r3
 1770 098c 9AB2     	 uxth r2,r3
 1771 098e B04B     	 ldr r3,.L124+48
 1772 0990 1A80     	 strh r2,[r3]
 379:../main.c     **** 
 380:../main.c     **** 												bcuAktBerechnung();
 1773              	 .loc 5 380 0
 1774 0992 FFF7FEFF 	 bl bcuAktBerechnung
 381:../main.c     **** 											    bcuUebergabe();
 1775              	 .loc 5 381 0
 1776 0996 FFF7FEFF 	 bl bcuUebergabe
 382:../main.c     **** 
 383:../main.c     **** 												new_data_aktLichtBack();
 1777              	 .loc 5 383 0
 1778 099a FFF7FEFF 	 bl new_data_aktLichtBack
 384:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 1779              	 .loc 5 384 0
 1780 099e A64B     	 ldr r3,.L124+24
 1781 09a0 1B78     	 ldrb r3,[r3]
 1782 09a2 1C1C     	 mov r4,r3
 1783 09a4 A54A     	 ldr r2,.L124+28
 1784 09a6 A14B     	 ldr r3,.L124+12
 1785 09a8 101C     	 mov r0,r2
 1786 09aa 191C     	 mov r1,r3
 1787 09ac 221C     	 mov r2,r4
 1788 09ae FFF7FEFF 	 bl UART_Transmit
 385:../main.c     **** 											break;
 1789              	 .loc 5 385 0
 1790 09b2 01F0EBF9 	 bl .L47
 1791              	.L60:
 386:../main.c     **** 				case command_offLichtResi :
 387:../main.c     **** 											dimOff_Ww=ReadData[1]*0x100+ReadData[2];
 1792              	 .loc 5 387 0
 1793 09b6 9A4B     	 ldr r3,.L124
 1794 09b8 5B78     	 ldrb r3,[r3,#1]
 1795 09ba 9BB2     	 uxth r3,r3
 1796 09bc 1B02     	 lsl r3,r3,#8
 1797 09be 9AB2     	 uxth r2,r3
 1798 09c0 974B     	 ldr r3,.L124
 1799 09c2 9B78     	 ldrb r3,[r3,#2]
 1800 09c4 9BB2     	 uxth r3,r3
 1801 09c6 D318     	 add r3,r2,r3
 1802 09c8 9AB2     	 uxth r2,r3
 1803 09ca A24B     	 ldr r3,.L124+52
 1804 09cc 1A80     	 strh r2,[r3]
 388:../main.c     **** 											dimOff_Cw=ReadData[3]*0x100+ReadData[4];
 1805              	 .loc 5 388 0
 1806 09ce 944B     	 ldr r3,.L124
 1807 09d0 DB78     	 ldrb r3,[r3,#3]
 1808 09d2 9BB2     	 uxth r3,r3
 1809 09d4 1B02     	 lsl r3,r3,#8
 1810 09d6 9AB2     	 uxth r2,r3
 1811 09d8 914B     	 ldr r3,.L124
 1812 09da 1B79     	 ldrb r3,[r3,#4]
 1813 09dc 9BB2     	 uxth r3,r3
 1814 09de D318     	 add r3,r2,r3
 1815 09e0 9AB2     	 uxth r2,r3
 1816 09e2 9D4B     	 ldr r3,.L124+56
 1817 09e4 1A80     	 strh r2,[r3]
 389:../main.c     **** 
 390:../main.c     **** 												new_data_offLichtBack();
 1818              	 .loc 5 390 0
 1819 09e6 FFF7FEFF 	 bl new_data_offLichtBack
 391:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 1820              	 .loc 5 391 0
 1821 09ea 934B     	 ldr r3,.L124+24
 1822 09ec 1B78     	 ldrb r3,[r3]
 1823 09ee 1C1C     	 mov r4,r3
 1824 09f0 924A     	 ldr r2,.L124+28
 1825 09f2 8E4B     	 ldr r3,.L124+12
 1826 09f4 101C     	 mov r0,r2
 1827 09f6 191C     	 mov r1,r3
 1828 09f8 221C     	 mov r2,r4
 1829 09fa FFF7FEFF 	 bl UART_Transmit
 392:../main.c     **** 											break;
 1830              	 .loc 5 392 0
 1831 09fe 01F0C5F9 	 bl .L47
 1832              	.L63:
 393:../main.c     **** 				case command_HalloResi : 		new_data_HalloBack();
 1833              	 .loc 5 393 0
 1834 0a02 FFF7FEFF 	 bl new_data_HalloBack
 394:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 1835              	 .loc 5 394 0
 1836 0a06 8C4B     	 ldr r3,.L124+24
 1837 0a08 1B78     	 ldrb r3,[r3]
 1838 0a0a 1C1C     	 mov r4,r3
 1839 0a0c 8B4A     	 ldr r2,.L124+28
 1840 0a0e 874B     	 ldr r3,.L124+12
 1841 0a10 101C     	 mov r0,r2
 1842 0a12 191C     	 mov r1,r3
 1843 0a14 221C     	 mov r2,r4
 1844 0a16 FFF7FEFF 	 bl UART_Transmit
 395:../main.c     **** 											break;
 1845              	 .loc 5 395 0
 1846 0a1a 01F0B7F9 	 bl .L47
 1847              	.L71:
 396:../main.c     **** 				case command_nextledOff_Resi : 		new_data_HalloBack();
 1848              	 .loc 5 396 0
 1849 0a1e FFF7FEFF 	 bl new_data_HalloBack
 397:../main.c     **** 	 	 	 	 	 							B_nextLedOff=1;   // schaltet on led beim spannnungsvergleich aus
 1850              	 .loc 5 397 0
 1851 0a22 804B     	 ldr r3,.L124+4
 1852 0a24 0122     	 mov r2,#1
 1853 0a26 1A70     	 strb r2,[r3]
 398:../main.c     **** 												DIGITAL_IO_SetOutputLow(&VCC_LED_shtdwn);
 1854              	 .loc 5 398 0
 1855 0a28 7F4B     	 ldr r3,.L124+8
 1856 0a2a 181C     	 mov r0,r3
 1857 0a2c FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 399:../main.c     **** 												new_data[5]= command_nextledOffBack ;
 1858              	 .loc 5 399 0
 1859 0a30 7E4B     	 ldr r3,.L124+12
 1860 0a32 7222     	 mov r2,#114
 1861 0a34 5A71     	 strb r2,[r3,#5]
 400:../main.c     **** 												new_data[6]= Ser_NrH  / 0x100 ;
 1862              	 .loc 5 400 0
 1863 0a36 7E4B     	 ldr r3,.L124+16
 1864 0a38 1B88     	 ldrh r3,[r3]
 1865 0a3a 1B0A     	 lsr r3,r3,#8
 1866 0a3c 9BB2     	 uxth r3,r3
 1867 0a3e DAB2     	 uxtb r2,r3
 1868 0a40 7A4B     	 ldr r3,.L124+12
 1869 0a42 9A71     	 strb r2,[r3,#6]
 401:../main.c     **** 												new_data[7]= Ser_NrH  & 0xff ;
 1870              	 .loc 5 401 0
 1871 0a44 7A4B     	 ldr r3,.L124+16
 1872 0a46 1B88     	 ldrh r3,[r3]
 1873 0a48 DAB2     	 uxtb r2,r3
 1874 0a4a 784B     	 ldr r3,.L124+12
 1875 0a4c DA71     	 strb r2,[r3,#7]
 402:../main.c     **** 												new_data[8]= Ser_NrL  / 0x100 ;
 1876              	 .loc 5 402 0
 1877 0a4e 794B     	 ldr r3,.L124+20
 1878 0a50 1B88     	 ldrh r3,[r3]
 1879 0a52 1B0A     	 lsr r3,r3,#8
 1880 0a54 9BB2     	 uxth r3,r3
 1881 0a56 DAB2     	 uxtb r2,r3
 1882 0a58 744B     	 ldr r3,.L124+12
 1883 0a5a 1A72     	 strb r2,[r3,#8]
 403:../main.c     **** 												new_data[9]= Ser_NrL  & 0xff ;
 1884              	 .loc 5 403 0
 1885 0a5c 754B     	 ldr r3,.L124+20
 1886 0a5e 1B88     	 ldrh r3,[r3]
 1887 0a60 DAB2     	 uxtb r2,r3
 1888 0a62 724B     	 ldr r3,.L124+12
 1889 0a64 5A72     	 strb r2,[r3,#9]
 404:../main.c     **** 
 405:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 1890              	 .loc 5 405 0
 1891 0a66 744B     	 ldr r3,.L124+24
 1892 0a68 1B78     	 ldrb r3,[r3]
 1893 0a6a 1C1C     	 mov r4,r3
 1894 0a6c 734A     	 ldr r2,.L124+28
 1895 0a6e 6F4B     	 ldr r3,.L124+12
 1896 0a70 101C     	 mov r0,r2
 1897 0a72 191C     	 mov r1,r3
 1898 0a74 221C     	 mov r2,r4
 1899 0a76 FFF7FEFF 	 bl UART_Transmit
 406:../main.c     **** 											break;
 1900              	 .loc 5 406 0
 1901 0a7a 01F087F9 	 bl .L47
 1902              	.L72:
 407:../main.c     **** 				case command_nextledOn_Resi : 		new_data_HalloBack();
 1903              	 .loc 5 407 0
 1904 0a7e FFF7FEFF 	 bl new_data_HalloBack
 408:../main.c     **** 
 409:../main.c     **** 			  	 	 	 	 	 	 	 	 	B_nextLedOff=0;
 1905              	 .loc 5 409 0
 1906 0a82 684B     	 ldr r3,.L124+4
 1907 0a84 0022     	 mov r2,#0
 1908 0a86 1A70     	 strb r2,[r3]
 410:../main.c     **** 												DIGITAL_IO_SetOutputHigh(&VCC_LED_shtdwn);
 1909              	 .loc 5 410 0
 1910 0a88 674B     	 ldr r3,.L124+8
 1911 0a8a 181C     	 mov r0,r3
 1912 0a8c FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 411:../main.c     **** 												new_data[5]= command_nextledOnBack ;
 1913              	 .loc 5 411 0
 1914 0a90 664B     	 ldr r3,.L124+12
 1915 0a92 7322     	 mov r2,#115
 1916 0a94 5A71     	 strb r2,[r3,#5]
 412:../main.c     **** 												new_data[6]= Ser_NrH  / 0x100 ;
 1917              	 .loc 5 412 0
 1918 0a96 664B     	 ldr r3,.L124+16
 1919 0a98 1B88     	 ldrh r3,[r3]
 1920 0a9a 1B0A     	 lsr r3,r3,#8
 1921 0a9c 9BB2     	 uxth r3,r3
 1922 0a9e DAB2     	 uxtb r2,r3
 1923 0aa0 624B     	 ldr r3,.L124+12
 1924 0aa2 9A71     	 strb r2,[r3,#6]
 413:../main.c     **** 												new_data[7]= Ser_NrH  & 0xff ;
 1925              	 .loc 5 413 0
 1926 0aa4 624B     	 ldr r3,.L124+16
 1927 0aa6 1B88     	 ldrh r3,[r3]
 1928 0aa8 DAB2     	 uxtb r2,r3
 1929 0aaa 604B     	 ldr r3,.L124+12
 1930 0aac DA71     	 strb r2,[r3,#7]
 414:../main.c     **** 												new_data[8]= Ser_NrL  / 0x100 ;
 1931              	 .loc 5 414 0
 1932 0aae 614B     	 ldr r3,.L124+20
 1933 0ab0 1B88     	 ldrh r3,[r3]
 1934 0ab2 1B0A     	 lsr r3,r3,#8
 1935 0ab4 9BB2     	 uxth r3,r3
 1936 0ab6 DAB2     	 uxtb r2,r3
 1937 0ab8 5C4B     	 ldr r3,.L124+12
 1938 0aba 1A72     	 strb r2,[r3,#8]
 415:../main.c     **** 												new_data[9]= Ser_NrL  & 0xff ;
 1939              	 .loc 5 415 0
 1940 0abc 5D4B     	 ldr r3,.L124+20
 1941 0abe 1B88     	 ldrh r3,[r3]
 1942 0ac0 DAB2     	 uxtb r2,r3
 1943 0ac2 5A4B     	 ldr r3,.L124+12
 1944 0ac4 5A72     	 strb r2,[r3,#9]
 416:../main.c     **** 
 417:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 1945              	 .loc 5 417 0
 1946 0ac6 5C4B     	 ldr r3,.L124+24
 1947 0ac8 1B78     	 ldrb r3,[r3]
 1948 0aca 1C1C     	 mov r4,r3
 1949 0acc 5B4A     	 ldr r2,.L124+28
 1950 0ace 574B     	 ldr r3,.L124+12
 1951 0ad0 101C     	 mov r0,r2
 1952 0ad2 191C     	 mov r1,r3
 1953 0ad4 221C     	 mov r2,r4
 1954 0ad6 FFF7FEFF 	 bl UART_Transmit
 418:../main.c     **** 											break;
 1955              	 .loc 5 418 0
 1956 0ada 01F057F9 	 bl .L47
 1957              	.L61:
 419:../main.c     **** 
 420:../main.c     **** 				case command_Bright_Color_Resi :	Brightness_Gen=ReadData[1]*0x100+ReadData[2];
 1958              	 .loc 5 420 0
 1959 0ade 504B     	 ldr r3,.L124
 1960 0ae0 5B78     	 ldrb r3,[r3,#1]
 1961 0ae2 9BB2     	 uxth r3,r3
 1962 0ae4 1B02     	 lsl r3,r3,#8
 1963 0ae6 9AB2     	 uxth r2,r3
 1964 0ae8 4D4B     	 ldr r3,.L124
 1965 0aea 9B78     	 ldrb r3,[r3,#2]
 1966 0aec 9BB2     	 uxth r3,r3
 1967 0aee D318     	 add r3,r2,r3
 1968 0af0 9AB2     	 uxth r2,r3
 1969 0af2 5A4B     	 ldr r3,.L124+60
 1970 0af4 1A80     	 strh r2,[r3]
 421:../main.c     **** 													ColorQuot_Gen=ReadData[3]*0x100+ReadData[4];
 1971              	 .loc 5 421 0
 1972 0af6 4A4B     	 ldr r3,.L124
 1973 0af8 DB78     	 ldrb r3,[r3,#3]
 1974 0afa 9BB2     	 uxth r3,r3
 1975 0afc 1B02     	 lsl r3,r3,#8
 1976 0afe 9AB2     	 uxth r2,r3
 1977 0b00 474B     	 ldr r3,.L124
 1978 0b02 1B79     	 ldrb r3,[r3,#4]
 1979 0b04 9BB2     	 uxth r3,r3
 1980 0b06 D318     	 add r3,r2,r3
 1981 0b08 9AB2     	 uxth r2,r3
 1982 0b0a 554B     	 ldr r3,.L124+64
 1983 0b0c 1A80     	 strh r2,[r3]
 422:../main.c     **** 
 423:../main.c     **** 
 424:../main.c     **** 													bcuColorBerechnung();
 1984              	 .loc 5 424 0
 1985 0b0e FFF7FEFF 	 bl bcuColorBerechnung
 425:../main.c     **** 													bcuAktBerechnung();
 1986              	 .loc 5 425 0
 1987 0b12 FFF7FEFF 	 bl bcuAktBerechnung
 426:../main.c     **** 													  bcuUebergabe();
 1988              	 .loc 5 426 0
 1989 0b16 FFF7FEFF 	 bl bcuUebergabe
 427:../main.c     **** 													  //DimmUebergabe();
 428:../main.c     **** 
 429:../main.c     **** 													new_data_Bright_Color_Back();
 1990              	 .loc 5 429 0
 1991 0b1a FFF7FEFF 	 bl new_data_Bright_Color_Back
 430:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 1992              	 .loc 5 430 0
 1993 0b1e 464B     	 ldr r3,.L124+24
 1994 0b20 1B78     	 ldrb r3,[r3]
 1995 0b22 1C1C     	 mov r4,r3
 1996 0b24 454A     	 ldr r2,.L124+28
 1997 0b26 414B     	 ldr r3,.L124+12
 1998 0b28 101C     	 mov r0,r2
 1999 0b2a 191C     	 mov r1,r3
 2000 0b2c 221C     	 mov r2,r4
 2001 0b2e FFF7FEFF 	 bl UART_Transmit
 431:../main.c     **** 											break;
 2002              	 .loc 5 431 0
 2003 0b32 01F02BF9 	 bl .L47
 2004              	.L62:
 432:../main.c     **** 
 433:../main.c     **** 				case command_Quot_Walk_Resi :	linearwalk_gen = ReadData[1]*0x100+ReadData[2];
 2005              	 .loc 5 433 0
 2006 0b36 3A4B     	 ldr r3,.L124
 2007 0b38 5B78     	 ldrb r3,[r3,#1]
 2008 0b3a 9BB2     	 uxth r3,r3
 2009 0b3c 1B02     	 lsl r3,r3,#8
 2010 0b3e 9AB2     	 uxth r2,r3
 2011 0b40 374B     	 ldr r3,.L124
 2012 0b42 9B78     	 ldrb r3,[r3,#2]
 2013 0b44 9BB2     	 uxth r3,r3
 2014 0b46 D318     	 add r3,r2,r3
 2015 0b48 9AB2     	 uxth r2,r3
 2016 0b4a 464B     	 ldr r3,.L124+68
 2017 0b4c 1A80     	 strh r2,[r3]
 434:../main.c     **** 												linearwalk_ww1 = linearwalk_gen;
 2018              	 .loc 5 434 0
 2019 0b4e 454B     	 ldr r3,.L124+68
 2020 0b50 1A88     	 ldrh r2,[r3]
 2021 0b52 454B     	 ldr r3,.L124+72
 2022 0b54 1A80     	 strh r2,[r3]
 435:../main.c     **** 												linearwalk_ww2 = linearwalk_gen;
 2023              	 .loc 5 435 0
 2024 0b56 434B     	 ldr r3,.L124+68
 2025 0b58 1A88     	 ldrh r2,[r3]
 2026 0b5a 444B     	 ldr r3,.L124+76
 2027 0b5c 1A80     	 strh r2,[r3]
 436:../main.c     **** 												linearwalk_cw1 = linearwalk_gen;
 2028              	 .loc 5 436 0
 2029 0b5e 414B     	 ldr r3,.L124+68
 2030 0b60 1A88     	 ldrh r2,[r3]
 2031 0b62 434B     	 ldr r3,.L124+80
 2032 0b64 1A80     	 strh r2,[r3]
 437:../main.c     **** 												linearwalk_cw2 = linearwalk_gen;
 2033              	 .loc 5 437 0
 2034 0b66 3F4B     	 ldr r3,.L124+68
 2035 0b68 1A88     	 ldrh r2,[r3]
 2036 0b6a 424B     	 ldr r3,.L124+84
 2037 0b6c 1A80     	 strh r2,[r3]
 438:../main.c     **** 
 439:../main.c     **** 												Farbe_wwcw_Quot_gen=ReadData[3]*0x100+ReadData[4];
 2038              	 .loc 5 439 0
 2039 0b6e 2C4B     	 ldr r3,.L124
 2040 0b70 DB78     	 ldrb r3,[r3,#3]
 2041 0b72 9BB2     	 uxth r3,r3
 2042 0b74 1B02     	 lsl r3,r3,#8
 2043 0b76 9AB2     	 uxth r2,r3
 2044 0b78 294B     	 ldr r3,.L124
 2045 0b7a 1B79     	 ldrb r3,[r3,#4]
 2046 0b7c 9BB2     	 uxth r3,r3
 2047 0b7e D318     	 add r3,r2,r3
 2048 0b80 9AB2     	 uxth r2,r3
 2049 0b82 3D4B     	 ldr r3,.L124+88
 2050 0b84 1A80     	 strh r2,[r3]
 440:../main.c     **** 												Farbe_ww1_Quot = ReadData[3];
 2051              	 .loc 5 440 0
 2052 0b86 264B     	 ldr r3,.L124
 2053 0b88 DB78     	 ldrb r3,[r3,#3]
 2054 0b8a 9AB2     	 uxth r2,r3
 2055 0b8c 3B4B     	 ldr r3,.L124+92
 2056 0b8e 1A80     	 strh r2,[r3]
 441:../main.c     **** 												Farbe_cw1_Quot = ReadData[3];
 2057              	 .loc 5 441 0
 2058 0b90 234B     	 ldr r3,.L124
 2059 0b92 DB78     	 ldrb r3,[r3,#3]
 2060 0b94 9AB2     	 uxth r2,r3
 2061 0b96 3A4B     	 ldr r3,.L124+96
 2062 0b98 1A80     	 strh r2,[r3]
 442:../main.c     **** 												Farbe_ww2_Quot = ReadData[4];
 2063              	 .loc 5 442 0
 2064 0b9a 214B     	 ldr r3,.L124
 2065 0b9c 1B79     	 ldrb r3,[r3,#4]
 2066 0b9e 9AB2     	 uxth r2,r3
 2067 0ba0 384B     	 ldr r3,.L124+100
 2068 0ba2 1A80     	 strh r2,[r3]
 443:../main.c     **** 												Farbe_cw2_Quot = ReadData[4];
 2069              	 .loc 5 443 0
 2070 0ba4 1E4B     	 ldr r3,.L124
 2071 0ba6 1B79     	 ldrb r3,[r3,#4]
 2072 0ba8 9AB2     	 uxth r2,r3
 2073 0baa 374B     	 ldr r3,.L124+104
 2074 0bac 1A80     	 strh r2,[r3]
 444:../main.c     **** 
 445:../main.c     **** 												bcuAktBerechnung();
 2075              	 .loc 5 445 0
 2076 0bae FFF7FEFF 	 bl bcuAktBerechnung
 446:../main.c     **** 												  bcuUebergabe();
 2077              	 .loc 5 446 0
 2078 0bb2 FFF7FEFF 	 bl bcuUebergabe
 447:../main.c     **** 												 // DimmUebergabe();
 448:../main.c     **** 
 449:../main.c     **** 													new_data_Quot_Walk_Back();
 2079              	 .loc 5 449 0
 2080 0bb6 FFF7FEFF 	 bl new_data_Quot_Walk_Back
 450:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2081              	 .loc 5 450 0
 2082 0bba 1F4B     	 ldr r3,.L124+24
 2083 0bbc 1B78     	 ldrb r3,[r3]
 2084 0bbe 1C1C     	 mov r4,r3
 2085 0bc0 1E4A     	 ldr r2,.L124+28
 2086 0bc2 1A4B     	 ldr r3,.L124+12
 2087 0bc4 101C     	 mov r0,r2
 2088 0bc6 191C     	 mov r1,r3
 2089 0bc8 221C     	 mov r2,r4
 2090 0bca FFF7FEFF 	 bl UART_Transmit
 451:../main.c     **** 											break;
 2091              	 .loc 5 451 0
 2092 0bce 01F0DDF8 	 bl .L47
 2093              	.L64:
 452:../main.c     **** 
 453:../main.c     **** 
 454:../main.c     **** 
 455:../main.c     **** 
 456:../main.c     **** 
 457:../main.c     **** 				case command_neuNodeIdResi :	if (ReadData[1] == ReadData[2] &&  Ser_NrL  == (ReadData[3] * 0x10
 2094              	 .loc 5 457 0
 2095 0bd2 134B     	 ldr r3,.L124
 2096 0bd4 5A78     	 ldrb r2,[r3,#1]
 2097 0bd6 124B     	 ldr r3,.L124
 2098 0bd8 9B78     	 ldrb r3,[r3,#2]
 2099 0bda 9A42     	 cmp r2,r3
 2100 0bdc 5AD1     	 bne .L73
 2101              	 .loc 5 457 0 is_stmt 0 discriminator 1
 2102 0bde 154B     	 ldr r3,.L124+20
 2103 0be0 1B88     	 ldrh r3,[r3]
 2104 0be2 191C     	 mov r1,r3
 2105 0be4 0E4B     	 ldr r3,.L124
 2106 0be6 DB78     	 ldrb r3,[r3,#3]
 2107 0be8 1B02     	 lsl r3,r3,#8
 2108 0bea 0D4A     	 ldr r2,.L124
 2109 0bec 1279     	 ldrb r2,[r2,#4]
 2110 0bee 9B18     	 add r3,r3,r2
 2111 0bf0 9942     	 cmp r1,r3
 2112 0bf2 4FD1     	 bne .L73
 458:../main.c     **** 												{
 459:../main.c     **** 												node_id_neu = ReadData[1];
 2113              	 .loc 5 459 0 is_stmt 1
 2114 0bf4 0A4B     	 ldr r3,.L124
 2115 0bf6 5A78     	 ldrb r2,[r3,#1]
 2116 0bf8 244B     	 ldr r3,.L124+108
 2117 0bfa 1A70     	 strb r2,[r3]
 460:../main.c     **** 												command_nr=0x30;
 2118              	 .loc 5 460 0
 2119 0bfc 244B     	 ldr r3,.L124+112
 2120 0bfe 3022     	 mov r2,#48
 2121 0c00 1A80     	 strh r2,[r3]
 461:../main.c     **** 												new_data_neuNodeIdBack();
 2122              	 .loc 5 461 0
 2123 0c02 FFF7FEFF 	 bl new_data_neuNodeIdBack
 462:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2124              	 .loc 5 462 0
 2125 0c06 0C4B     	 ldr r3,.L124+24
 2126 0c08 1B78     	 ldrb r3,[r3]
 2127 0c0a 1C1C     	 mov r4,r3
 2128 0c0c 0B4A     	 ldr r2,.L124+28
 2129 0c0e 074B     	 ldr r3,.L124+12
 2130 0c10 101C     	 mov r0,r2
 2131 0c12 191C     	 mov r1,r3
 2132 0c14 221C     	 mov r2,r4
 2133 0c16 FFF7FEFF 	 bl UART_Transmit
 463:../main.c     **** 												}
 464:../main.c     **** 												else {
 465:../main.c     **** 												node_id_neu = node_id;
 466:../main.c     **** 												command_nr=0x0;
 467:../main.c     **** 												 new_data_HalloBack();
 468:../main.c     **** 												 new_data[6]='e';
 469:../main.c     **** 												 new_data[7]= 4;
 470:../main.c     **** 												 new_data[8]= Ser_NrL  / 0x100 ;
 471:../main.c     **** 												 new_data[9]= Ser_NrL  & 0xff ;
 472:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 473:../main.c     **** 												}
 474:../main.c     **** 
 475:../main.c     **** 											break;
 2134              	 .loc 5 475 0
 2135 0c1a 01F0B7F8 	 bl .L47
 2136              	.L125:
 2137 0c1e C046     	 .align 2
 2138              	.L124:
 2139 0c20 00000000 	 .word ReadData
 2140 0c24 00000000 	 .word B_nextLedOff
 2141 0c28 00000000 	 .word VCC_LED_shtdwn
 2142 0c2c 00000000 	 .word new_data
 2143 0c30 00000000 	 .word Ser_NrH
 2144 0c34 00000000 	 .word Ser_NrL
 2145 0c38 00000000 	 .word transmit_buf_size
 2146 0c3c 00000000 	 .word UART_1
 2147 0c40 00000000 	 .word execute
 2148 0c44 00000000 	 .word command
 2149 0c48 00000000 	 .word .L50
 2150 0c4c 00000000 	 .word dimAkt_Ww
 2151 0c50 00000000 	 .word dimAkt_Cw
 2152 0c54 00000000 	 .word dimOff_Ww
 2153 0c58 00000000 	 .word dimOff_Cw
 2154 0c5c 00000000 	 .word Brightness_Gen
 2155 0c60 00000000 	 .word ColorQuot_Gen
 2156 0c64 00000000 	 .word linearwalk_gen
 2157 0c68 00000000 	 .word linearwalk_ww1
 2158 0c6c 00000000 	 .word linearwalk_ww2
 2159 0c70 00000000 	 .word linearwalk_cw1
 2160 0c74 00000000 	 .word linearwalk_cw2
 2161 0c78 00000000 	 .word Farbe_wwcw_Quot_gen
 2162 0c7c 00000000 	 .word Farbe_ww1_Quot
 2163 0c80 00000000 	 .word Farbe_cw1_Quot
 2164 0c84 00000000 	 .word Farbe_ww2_Quot
 2165 0c88 00000000 	 .word Farbe_cw2_Quot
 2166 0c8c 00000000 	 .word node_id_neu
 2167 0c90 00000000 	 .word command_nr
 2168              	.L73:
 465:../main.c     **** 												command_nr=0x0;
 2169              	 .loc 5 465 0
 2170 0c94 F04B     	 ldr r3,.L126
 2171 0c96 1A78     	 ldrb r2,[r3]
 2172 0c98 F04B     	 ldr r3,.L126+4
 2173 0c9a 1A70     	 strb r2,[r3]
 466:../main.c     **** 												 new_data_HalloBack();
 2174              	 .loc 5 466 0
 2175 0c9c F04B     	 ldr r3,.L126+8
 2176 0c9e 0022     	 mov r2,#0
 2177 0ca0 1A80     	 strh r2,[r3]
 467:../main.c     **** 												 new_data[6]='e';
 2178              	 .loc 5 467 0
 2179 0ca2 FFF7FEFF 	 bl new_data_HalloBack
 468:../main.c     **** 												 new_data[7]= 4;
 2180              	 .loc 5 468 0
 2181 0ca6 EF4B     	 ldr r3,.L126+12
 2182 0ca8 6522     	 mov r2,#101
 2183 0caa 9A71     	 strb r2,[r3,#6]
 469:../main.c     **** 												 new_data[8]= Ser_NrL  / 0x100 ;
 2184              	 .loc 5 469 0
 2185 0cac ED4B     	 ldr r3,.L126+12
 2186 0cae 0422     	 mov r2,#4
 2187 0cb0 DA71     	 strb r2,[r3,#7]
 470:../main.c     **** 												 new_data[9]= Ser_NrL  & 0xff ;
 2188              	 .loc 5 470 0
 2189 0cb2 ED4B     	 ldr r3,.L126+16
 2190 0cb4 1B88     	 ldrh r3,[r3]
 2191 0cb6 1B0A     	 lsr r3,r3,#8
 2192 0cb8 9BB2     	 uxth r3,r3
 2193 0cba DAB2     	 uxtb r2,r3
 2194 0cbc E94B     	 ldr r3,.L126+12
 2195 0cbe 1A72     	 strb r2,[r3,#8]
 471:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2196              	 .loc 5 471 0
 2197 0cc0 E94B     	 ldr r3,.L126+16
 2198 0cc2 1B88     	 ldrh r3,[r3]
 2199 0cc4 DAB2     	 uxtb r2,r3
 2200 0cc6 E74B     	 ldr r3,.L126+12
 2201 0cc8 5A72     	 strb r2,[r3,#9]
 472:../main.c     **** 												}
 2202              	 .loc 5 472 0
 2203 0cca E84B     	 ldr r3,.L126+20
 2204 0ccc 1B78     	 ldrb r3,[r3]
 2205 0cce 1C1C     	 mov r4,r3
 2206 0cd0 E74A     	 ldr r2,.L126+24
 2207 0cd2 E44B     	 ldr r3,.L126+12
 2208 0cd4 101C     	 mov r0,r2
 2209 0cd6 191C     	 mov r1,r3
 2210 0cd8 221C     	 mov r2,r4
 2211 0cda FFF7FEFF 	 bl UART_Transmit
 2212              	 .loc 5 475 0
 2213 0cde 01F055F8 	 bl .L47
 2214              	.L65:
 476:../main.c     **** 
 477:../main.c     **** 				case command_neuSerNrResi :
 478:../main.c     **** 												command_nr = 0x45;
 2215              	 .loc 5 478 0
 2216 0ce2 DF4B     	 ldr r3,.L126+8
 2217 0ce4 4522     	 mov r2,#69
 2218 0ce6 1A80     	 strh r2,[r3]
 479:../main.c     **** 												neu_Ser_NrH  = ReadData[1] * 0x100 + ReadData[2];
 2219              	 .loc 5 479 0
 2220 0ce8 E24B     	 ldr r3,.L126+28
 2221 0cea 5B78     	 ldrb r3,[r3,#1]
 2222 0cec 9BB2     	 uxth r3,r3
 2223 0cee 1B02     	 lsl r3,r3,#8
 2224 0cf0 9AB2     	 uxth r2,r3
 2225 0cf2 E04B     	 ldr r3,.L126+28
 2226 0cf4 9B78     	 ldrb r3,[r3,#2]
 2227 0cf6 9BB2     	 uxth r3,r3
 2228 0cf8 D318     	 add r3,r2,r3
 2229 0cfa 9AB2     	 uxth r2,r3
 2230 0cfc DE4B     	 ldr r3,.L126+32
 2231 0cfe 1A80     	 strh r2,[r3]
 480:../main.c     **** 												neu_Ser_NrL  = ReadData[3] * 0x100 + ReadData[4];
 2232              	 .loc 5 480 0
 2233 0d00 DC4B     	 ldr r3,.L126+28
 2234 0d02 DB78     	 ldrb r3,[r3,#3]
 2235 0d04 9BB2     	 uxth r3,r3
 2236 0d06 1B02     	 lsl r3,r3,#8
 2237 0d08 9AB2     	 uxth r2,r3
 2238 0d0a DA4B     	 ldr r3,.L126+28
 2239 0d0c 1B79     	 ldrb r3,[r3,#4]
 2240 0d0e 9BB2     	 uxth r3,r3
 2241 0d10 D318     	 add r3,r2,r3
 2242 0d12 9AB2     	 uxth r2,r3
 2243 0d14 D94B     	 ldr r3,.L126+36
 2244 0d16 1A80     	 strh r2,[r3]
 481:../main.c     **** 												new_data_neuSerNrBack();
 2245              	 .loc 5 481 0
 2246 0d18 FFF7FEFF 	 bl new_data_neuSerNrBack
 482:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2247              	 .loc 5 482 0
 2248 0d1c D34B     	 ldr r3,.L126+20
 2249 0d1e 1B78     	 ldrb r3,[r3]
 2250 0d20 1C1C     	 mov r4,r3
 2251 0d22 D34A     	 ldr r2,.L126+24
 2252 0d24 CF4B     	 ldr r3,.L126+12
 2253 0d26 101C     	 mov r0,r2
 2254 0d28 191C     	 mov r1,r3
 2255 0d2a 221C     	 mov r2,r4
 2256 0d2c FFF7FEFF 	 bl UART_Transmit
 483:../main.c     **** 											break;
 2257              	 .loc 5 483 0
 2258 0d30 01F02CF8 	 bl .L47
 2259              	.L67:
 484:../main.c     **** 				case command_SerNrResi :		tester = readSerNrEEprom();
 2260              	 .loc 5 484 0
 2261 0d34 FFF7FEFF 	 bl readSerNrEEprom
 2262 0d38 031C     	 mov r3,r0
 2263 0d3a 1A1C     	 mov r2,r3
 2264 0d3c D04B     	 ldr r3,.L126+40
 2265 0d3e 1A60     	 str r2,[r3]
 485:../main.c     **** 												if (tester == 0x03)
 2266              	 .loc 5 485 0
 2267 0d40 CF4B     	 ldr r3,.L126+40
 2268 0d42 1B68     	 ldr r3,[r3]
 2269 0d44 032B     	 cmp r3,#3
 2270 0d46 25D1     	 bne .L75
 486:../main.c     **** 												{
 487:../main.c     **** 												Ser_NrH = ReadBuffer1[0] * 0x100 + ReadBuffer1[1];
 2271              	 .loc 5 487 0
 2272 0d48 CE4B     	 ldr r3,.L126+44
 2273 0d4a 1B78     	 ldrb r3,[r3]
 2274 0d4c 9BB2     	 uxth r3,r3
 2275 0d4e 1B02     	 lsl r3,r3,#8
 2276 0d50 9AB2     	 uxth r2,r3
 2277 0d52 CC4B     	 ldr r3,.L126+44
 2278 0d54 5B78     	 ldrb r3,[r3,#1]
 2279 0d56 9BB2     	 uxth r3,r3
 2280 0d58 D318     	 add r3,r2,r3
 2281 0d5a 9AB2     	 uxth r2,r3
 2282 0d5c CA4B     	 ldr r3,.L126+48
 2283 0d5e 1A80     	 strh r2,[r3]
 488:../main.c     **** 												Ser_NrL = ReadBuffer1[2] * 0x100 + ReadBuffer1[3];
 2284              	 .loc 5 488 0
 2285 0d60 C84B     	 ldr r3,.L126+44
 2286 0d62 9B78     	 ldrb r3,[r3,#2]
 2287 0d64 9BB2     	 uxth r3,r3
 2288 0d66 1B02     	 lsl r3,r3,#8
 2289 0d68 9AB2     	 uxth r2,r3
 2290 0d6a C64B     	 ldr r3,.L126+44
 2291 0d6c DB78     	 ldrb r3,[r3,#3]
 2292 0d6e 9BB2     	 uxth r3,r3
 2293 0d70 D318     	 add r3,r2,r3
 2294 0d72 9AB2     	 uxth r2,r3
 2295 0d74 BC4B     	 ldr r3,.L126+16
 2296 0d76 1A80     	 strh r2,[r3]
 489:../main.c     **** 												new_data_SerNrBack();
 2297              	 .loc 5 489 0
 2298 0d78 FFF7FEFF 	 bl new_data_SerNrBack
 490:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2299              	 .loc 5 490 0
 2300 0d7c BB4B     	 ldr r3,.L126+20
 2301 0d7e 1B78     	 ldrb r3,[r3]
 2302 0d80 1C1C     	 mov r4,r3
 2303 0d82 BB4A     	 ldr r2,.L126+24
 2304 0d84 B74B     	 ldr r3,.L126+12
 2305 0d86 101C     	 mov r0,r2
 2306 0d88 191C     	 mov r1,r3
 2307 0d8a 221C     	 mov r2,r4
 2308 0d8c FFF7FEFF 	 bl UART_Transmit
 491:../main.c     **** 												}
 492:../main.c     **** 												else
 493:../main.c     **** 												{
 494:../main.c     **** 											    new_data_HalloBack();
 495:../main.c     **** 												new_data[6]='e';
 496:../main.c     **** 												new_data[7]=10;
 497:../main.c     **** 												new_data[8]=tester;
 498:../main.c     **** 												new_data[9]=0;
 499:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 500:../main.c     **** 												}
 501:../main.c     **** 
 502:../main.c     **** 											break;
 2309              	 .loc 5 502 0
 2310 0d90 00F0FCFF 	 bl .L47
 2311              	.L75:
 494:../main.c     **** 												new_data[6]='e';
 2312              	 .loc 5 494 0
 2313 0d94 FFF7FEFF 	 bl new_data_HalloBack
 495:../main.c     **** 												new_data[7]=10;
 2314              	 .loc 5 495 0
 2315 0d98 B24B     	 ldr r3,.L126+12
 2316 0d9a 6522     	 mov r2,#101
 2317 0d9c 9A71     	 strb r2,[r3,#6]
 496:../main.c     **** 												new_data[8]=tester;
 2318              	 .loc 5 496 0
 2319 0d9e B14B     	 ldr r3,.L126+12
 2320 0da0 0A22     	 mov r2,#10
 2321 0da2 DA71     	 strb r2,[r3,#7]
 497:../main.c     **** 												new_data[9]=0;
 2322              	 .loc 5 497 0
 2323 0da4 B64B     	 ldr r3,.L126+40
 2324 0da6 1B68     	 ldr r3,[r3]
 2325 0da8 DAB2     	 uxtb r2,r3
 2326 0daa AE4B     	 ldr r3,.L126+12
 2327 0dac 1A72     	 strb r2,[r3,#8]
 498:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2328              	 .loc 5 498 0
 2329 0dae AD4B     	 ldr r3,.L126+12
 2330 0db0 0022     	 mov r2,#0
 2331 0db2 5A72     	 strb r2,[r3,#9]
 499:../main.c     **** 												}
 2332              	 .loc 5 499 0
 2333 0db4 AD4B     	 ldr r3,.L126+20
 2334 0db6 1B78     	 ldrb r3,[r3]
 2335 0db8 1C1C     	 mov r4,r3
 2336 0dba AD4A     	 ldr r2,.L126+24
 2337 0dbc A94B     	 ldr r3,.L126+12
 2338 0dbe 101C     	 mov r0,r2
 2339 0dc0 191C     	 mov r1,r3
 2340 0dc2 221C     	 mov r2,r4
 2341 0dc4 FFF7FEFF 	 bl UART_Transmit
 2342              	 .loc 5 502 0
 2343 0dc8 00F0E0FF 	 bl .L47
 2344              	.L66:
 503:../main.c     **** 				case command_NodeIdResi :		tester = readNodeIdEEprom();
 2345              	 .loc 5 503 0
 2346 0dcc FFF7FEFF 	 bl readNodeIdEEprom
 2347 0dd0 031C     	 mov r3,r0
 2348 0dd2 1A1C     	 mov r2,r3
 2349 0dd4 AA4B     	 ldr r3,.L126+40
 2350 0dd6 1A60     	 str r2,[r3]
 504:../main.c     **** 												if (tester == 0x03)
 2351              	 .loc 5 504 0
 2352 0dd8 A94B     	 ldr r3,.L126+40
 2353 0dda 1B68     	 ldr r3,[r3]
 2354 0ddc 032B     	 cmp r3,#3
 2355 0dde 23D1     	 bne .L77
 505:../main.c     **** 												{
 506:../main.c     **** 												node_id_alt = ReadBuffer2[0];
 2356              	 .loc 5 506 0
 2357 0de0 AA4B     	 ldr r3,.L126+52
 2358 0de2 1A78     	 ldrb r2,[r3]
 2359 0de4 AA4B     	 ldr r3,.L126+56
 2360 0de6 1A70     	 strb r2,[r3]
 507:../main.c     **** 												node_id  = ReadBuffer2[1];
 2361              	 .loc 5 507 0
 2362 0de8 A84B     	 ldr r3,.L126+52
 2363 0dea 5A78     	 ldrb r2,[r3,#1]
 2364 0dec 9A4B     	 ldr r3,.L126
 2365 0dee 1A70     	 strb r2,[r3]
 508:../main.c     **** 												node_id_16bit = ReadBuffer2[2] * 0xFF + ReadBuffer2[3];
 2366              	 .loc 5 508 0
 2367 0df0 A64B     	 ldr r3,.L126+52
 2368 0df2 9B78     	 ldrb r3,[r3,#2]
 2369 0df4 9BB2     	 uxth r3,r3
 2370 0df6 1A1C     	 add r2,r3,#0
 2371 0df8 1202     	 lsl r2,r2,#8
 2372 0dfa D31A     	 sub r3,r2,r3
 2373 0dfc 9AB2     	 uxth r2,r3
 2374 0dfe A34B     	 ldr r3,.L126+52
 2375 0e00 DB78     	 ldrb r3,[r3,#3]
 2376 0e02 9BB2     	 uxth r3,r3
 2377 0e04 D318     	 add r3,r2,r3
 2378 0e06 9AB2     	 uxth r2,r3
 2379 0e08 A24B     	 ldr r3,.L126+60
 2380 0e0a 1A80     	 strh r2,[r3]
 509:../main.c     **** 												new_data_NodeIdBack();
 2381              	 .loc 5 509 0
 2382 0e0c FFF7FEFF 	 bl new_data_NodeIdBack
 510:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2383              	 .loc 5 510 0
 2384 0e10 964B     	 ldr r3,.L126+20
 2385 0e12 1B78     	 ldrb r3,[r3]
 2386 0e14 1C1C     	 mov r4,r3
 2387 0e16 964A     	 ldr r2,.L126+24
 2388 0e18 924B     	 ldr r3,.L126+12
 2389 0e1a 101C     	 mov r0,r2
 2390 0e1c 191C     	 mov r1,r3
 2391 0e1e 221C     	 mov r2,r4
 2392 0e20 FFF7FEFF 	 bl UART_Transmit
 511:../main.c     **** 												}
 512:../main.c     **** 												else
 513:../main.c     **** 												{
 514:../main.c     **** 											    new_data_HalloBack();
 515:../main.c     **** 												new_data[6]='e';
 516:../main.c     **** 												new_data[7]=11;
 517:../main.c     **** 												new_data[8]=tester;
 518:../main.c     **** 												new_data[9]=0;
 519:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 520:../main.c     **** 												}
 521:../main.c     **** 											break;
 2393              	 .loc 5 521 0
 2394 0e24 00F0B2FF 	 bl .L47
 2395              	.L77:
 514:../main.c     **** 												new_data[6]='e';
 2396              	 .loc 5 514 0
 2397 0e28 FFF7FEFF 	 bl new_data_HalloBack
 515:../main.c     **** 												new_data[7]=11;
 2398              	 .loc 5 515 0
 2399 0e2c 8D4B     	 ldr r3,.L126+12
 2400 0e2e 6522     	 mov r2,#101
 2401 0e30 9A71     	 strb r2,[r3,#6]
 516:../main.c     **** 												new_data[8]=tester;
 2402              	 .loc 5 516 0
 2403 0e32 8C4B     	 ldr r3,.L126+12
 2404 0e34 0B22     	 mov r2,#11
 2405 0e36 DA71     	 strb r2,[r3,#7]
 517:../main.c     **** 												new_data[9]=0;
 2406              	 .loc 5 517 0
 2407 0e38 914B     	 ldr r3,.L126+40
 2408 0e3a 1B68     	 ldr r3,[r3]
 2409 0e3c DAB2     	 uxtb r2,r3
 2410 0e3e 894B     	 ldr r3,.L126+12
 2411 0e40 1A72     	 strb r2,[r3,#8]
 518:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2412              	 .loc 5 518 0
 2413 0e42 884B     	 ldr r3,.L126+12
 2414 0e44 0022     	 mov r2,#0
 2415 0e46 5A72     	 strb r2,[r3,#9]
 519:../main.c     **** 												}
 2416              	 .loc 5 519 0
 2417 0e48 884B     	 ldr r3,.L126+20
 2418 0e4a 1B78     	 ldrb r3,[r3]
 2419 0e4c 1C1C     	 mov r4,r3
 2420 0e4e 884A     	 ldr r2,.L126+24
 2421 0e50 844B     	 ldr r3,.L126+12
 2422 0e52 101C     	 mov r0,r2
 2423 0e54 191C     	 mov r1,r3
 2424 0e56 221C     	 mov r2,r4
 2425 0e58 FFF7FEFF 	 bl UART_Transmit
 2426              	 .loc 5 521 0
 2427 0e5c 00F096FF 	 bl .L47
 2428              	.L69:
 522:../main.c     **** 
 523:../main.c     **** 				case command_akt_lightEEResi :		tester = read_akt_light_EEprom();
 2429              	 .loc 5 523 0
 2430 0e60 FFF7FEFF 	 bl read_akt_light_EEprom
 2431 0e64 031C     	 mov r3,r0
 2432 0e66 1A1C     	 mov r2,r3
 2433 0e68 854B     	 ldr r3,.L126+40
 2434 0e6a 1A60     	 str r2,[r3]
 524:../main.c     **** 												if (tester == 0x03)
 2435              	 .loc 5 524 0
 2436 0e6c 844B     	 ldr r3,.L126+40
 2437 0e6e 1B68     	 ldr r3,[r3]
 2438 0e70 032B     	 cmp r3,#3
 2439 0e72 10D1     	 bne .L79
 525:../main.c     **** 												{
 526:../main.c     **** 													new_data_readbuff2Back();
 2440              	 .loc 5 526 0
 2441 0e74 FFF7FEFF 	 bl new_data_readbuff2Back
 527:../main.c     ****   		  											 new_data[6]=4;  // 4= akt_light buffertyp
 2442              	 .loc 5 527 0
 2443 0e78 7A4B     	 ldr r3,.L126+12
 2444 0e7a 0422     	 mov r2,#4
 2445 0e7c 9A71     	 strb r2,[r3,#6]
 528:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2446              	 .loc 5 528 0
 2447 0e7e 7B4B     	 ldr r3,.L126+20
 2448 0e80 1B78     	 ldrb r3,[r3]
 2449 0e82 1C1C     	 mov r4,r3
 2450 0e84 7A4A     	 ldr r2,.L126+24
 2451 0e86 774B     	 ldr r3,.L126+12
 2452 0e88 101C     	 mov r0,r2
 2453 0e8a 191C     	 mov r1,r3
 2454 0e8c 221C     	 mov r2,r4
 2455 0e8e FFF7FEFF 	 bl UART_Transmit
 529:../main.c     **** 												}
 530:../main.c     **** 												else
 531:../main.c     **** 												{
 532:../main.c     **** 											    new_data_HalloBack();
 533:../main.c     **** 												new_data[6]='e';
 534:../main.c     **** 												new_data[7]=45;
 535:../main.c     **** 												new_data[8]=tester;
 536:../main.c     **** 												new_data[9]=0;
 537:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 538:../main.c     **** 												}
 539:../main.c     **** 											break;
 2456              	 .loc 5 539 0
 2457 0e92 00F07BFF 	 bl .L47
 2458              	.L79:
 532:../main.c     **** 												new_data[6]='e';
 2459              	 .loc 5 532 0
 2460 0e96 FFF7FEFF 	 bl new_data_HalloBack
 533:../main.c     **** 												new_data[7]=45;
 2461              	 .loc 5 533 0
 2462 0e9a 724B     	 ldr r3,.L126+12
 2463 0e9c 6522     	 mov r2,#101
 2464 0e9e 9A71     	 strb r2,[r3,#6]
 534:../main.c     **** 												new_data[8]=tester;
 2465              	 .loc 5 534 0
 2466 0ea0 704B     	 ldr r3,.L126+12
 2467 0ea2 2D22     	 mov r2,#45
 2468 0ea4 DA71     	 strb r2,[r3,#7]
 535:../main.c     **** 												new_data[9]=0;
 2469              	 .loc 5 535 0
 2470 0ea6 764B     	 ldr r3,.L126+40
 2471 0ea8 1B68     	 ldr r3,[r3]
 2472 0eaa DAB2     	 uxtb r2,r3
 2473 0eac 6D4B     	 ldr r3,.L126+12
 2474 0eae 1A72     	 strb r2,[r3,#8]
 536:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2475              	 .loc 5 536 0
 2476 0eb0 6C4B     	 ldr r3,.L126+12
 2477 0eb2 0022     	 mov r2,#0
 2478 0eb4 5A72     	 strb r2,[r3,#9]
 537:../main.c     **** 												}
 2479              	 .loc 5 537 0
 2480 0eb6 6D4B     	 ldr r3,.L126+20
 2481 0eb8 1B78     	 ldrb r3,[r3]
 2482 0eba 1C1C     	 mov r4,r3
 2483 0ebc 6C4A     	 ldr r2,.L126+24
 2484 0ebe 694B     	 ldr r3,.L126+12
 2485 0ec0 101C     	 mov r0,r2
 2486 0ec2 191C     	 mov r1,r3
 2487 0ec4 221C     	 mov r2,r4
 2488 0ec6 FFF7FEFF 	 bl UART_Transmit
 2489              	 .loc 5 539 0
 2490 0eca 00F05FFF 	 bl .L47
 2491              	.L70:
 540:../main.c     **** 				case command_offlightEEResi :		tester = read_off_light_EEprom();
 2492              	 .loc 5 540 0
 2493 0ece FFF7FEFF 	 bl read_off_light_EEprom
 2494 0ed2 031C     	 mov r3,r0
 2495 0ed4 1A1C     	 mov r2,r3
 2496 0ed6 6A4B     	 ldr r3,.L126+40
 2497 0ed8 1A60     	 str r2,[r3]
 541:../main.c     **** 												if (tester == 0x03)
 2498              	 .loc 5 541 0
 2499 0eda 694B     	 ldr r3,.L126+40
 2500 0edc 1B68     	 ldr r3,[r3]
 2501 0ede 032B     	 cmp r3,#3
 2502 0ee0 10D1     	 bne .L81
 542:../main.c     **** 												{
 543:../main.c     **** 													new_data_readbuff2Back();
 2503              	 .loc 5 543 0
 2504 0ee2 FFF7FEFF 	 bl new_data_readbuff2Back
 544:../main.c     ****   		  											 new_data[6]=5;  // 5= offlight buffertyp
 2505              	 .loc 5 544 0
 2506 0ee6 5F4B     	 ldr r3,.L126+12
 2507 0ee8 0522     	 mov r2,#5
 2508 0eea 9A71     	 strb r2,[r3,#6]
 545:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2509              	 .loc 5 545 0
 2510 0eec 5F4B     	 ldr r3,.L126+20
 2511 0eee 1B78     	 ldrb r3,[r3]
 2512 0ef0 1C1C     	 mov r4,r3
 2513 0ef2 5F4A     	 ldr r2,.L126+24
 2514 0ef4 5B4B     	 ldr r3,.L126+12
 2515 0ef6 101C     	 mov r0,r2
 2516 0ef8 191C     	 mov r1,r3
 2517 0efa 221C     	 mov r2,r4
 2518 0efc FFF7FEFF 	 bl UART_Transmit
 546:../main.c     **** 												}
 547:../main.c     **** 												else
 548:../main.c     **** 												{
 549:../main.c     **** 											    new_data_HalloBack();
 550:../main.c     **** 												new_data[6]='e';
 551:../main.c     **** 												new_data[7]=21;
 552:../main.c     **** 												new_data[8]=tester;
 553:../main.c     **** 												new_data[9]=0;
 554:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 555:../main.c     **** 												}
 556:../main.c     **** 											break;
 2519              	 .loc 5 556 0
 2520 0f00 00F044FF 	 bl .L47
 2521              	.L81:
 549:../main.c     **** 												new_data[6]='e';
 2522              	 .loc 5 549 0
 2523 0f04 FFF7FEFF 	 bl new_data_HalloBack
 550:../main.c     **** 												new_data[7]=21;
 2524              	 .loc 5 550 0
 2525 0f08 564B     	 ldr r3,.L126+12
 2526 0f0a 6522     	 mov r2,#101
 2527 0f0c 9A71     	 strb r2,[r3,#6]
 551:../main.c     **** 												new_data[8]=tester;
 2528              	 .loc 5 551 0
 2529 0f0e 554B     	 ldr r3,.L126+12
 2530 0f10 1522     	 mov r2,#21
 2531 0f12 DA71     	 strb r2,[r3,#7]
 552:../main.c     **** 												new_data[9]=0;
 2532              	 .loc 5 552 0
 2533 0f14 5A4B     	 ldr r3,.L126+40
 2534 0f16 1B68     	 ldr r3,[r3]
 2535 0f18 DAB2     	 uxtb r2,r3
 2536 0f1a 524B     	 ldr r3,.L126+12
 2537 0f1c 1A72     	 strb r2,[r3,#8]
 553:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2538              	 .loc 5 553 0
 2539 0f1e 514B     	 ldr r3,.L126+12
 2540 0f20 0022     	 mov r2,#0
 2541 0f22 5A72     	 strb r2,[r3,#9]
 554:../main.c     **** 												}
 2542              	 .loc 5 554 0
 2543 0f24 514B     	 ldr r3,.L126+20
 2544 0f26 1B78     	 ldrb r3,[r3]
 2545 0f28 1C1C     	 mov r4,r3
 2546 0f2a 514A     	 ldr r2,.L126+24
 2547 0f2c 4D4B     	 ldr r3,.L126+12
 2548 0f2e 101C     	 mov r0,r2
 2549 0f30 191C     	 mov r1,r3
 2550 0f32 221C     	 mov r2,r4
 2551 0f34 FFF7FEFF 	 bl UART_Transmit
 2552              	 .loc 5 556 0
 2553 0f38 00F028FF 	 bl .L47
 2554              	.L51:
 557:../main.c     **** 
 558:../main.c     **** 				case command_neuNodeIdWriteResi:
 559:../main.c     **** 											if (command_nr == 0x47 && Ser_NrH == (ReadData[1] * 0x100 + ReadData[2]) && Ser_NrL  == 
 2555              	 .loc 5 559 0
 2556 0f3c 484B     	 ldr r3,.L126+8
 2557 0f3e 1B88     	 ldrh r3,[r3]
 2558 0f40 472B     	 cmp r3,#71
 2559 0f42 00D0     	 beq .LCB2132
 2560 0f44 AAE0     	 b .L83
 2561              	.LCB2132:
 2562              	 .loc 5 559 0 is_stmt 0 discriminator 1
 2563 0f46 504B     	 ldr r3,.L126+48
 2564 0f48 1B88     	 ldrh r3,[r3]
 2565 0f4a 191C     	 mov r1,r3
 2566 0f4c 494B     	 ldr r3,.L126+28
 2567 0f4e 5B78     	 ldrb r3,[r3,#1]
 2568 0f50 1B02     	 lsl r3,r3,#8
 2569 0f52 484A     	 ldr r2,.L126+28
 2570 0f54 9278     	 ldrb r2,[r2,#2]
 2571 0f56 9B18     	 add r3,r3,r2
 2572 0f58 9942     	 cmp r1,r3
 2573 0f5a 00D0     	 beq .LCB2143
 2574 0f5c 9EE0     	 b .L83
 2575              	.LCB2143:
 2576              	 .loc 5 559 0 discriminator 2
 2577 0f5e 424B     	 ldr r3,.L126+16
 2578 0f60 1B88     	 ldrh r3,[r3]
 2579 0f62 191C     	 mov r1,r3
 2580 0f64 434B     	 ldr r3,.L126+28
 2581 0f66 DB78     	 ldrb r3,[r3,#3]
 2582 0f68 1B02     	 lsl r3,r3,#8
 2583 0f6a 424A     	 ldr r2,.L126+28
 2584 0f6c 1279     	 ldrb r2,[r2,#4]
 2585 0f6e 9B18     	 add r3,r3,r2
 2586 0f70 9942     	 cmp r1,r3
 2587 0f72 00D0     	 beq .LCB2154
 2588 0f74 92E0     	 b .L83
 2589              	.LCB2154:
 560:../main.c     **** 												{
 561:../main.c     **** 												tester = readNodeIdEEprom();
 2590              	 .loc 5 561 0 is_stmt 1
 2591 0f76 FFF7FEFF 	 bl readNodeIdEEprom
 2592 0f7a 031C     	 mov r3,r0
 2593 0f7c 1A1C     	 mov r2,r3
 2594 0f7e 404B     	 ldr r3,.L126+40
 2595 0f80 1A60     	 str r2,[r3]
 562:../main.c     **** 												  if (tester == 0x03)
 2596              	 .loc 5 562 0
 2597 0f82 3F4B     	 ldr r3,.L126+40
 2598 0f84 1B68     	 ldr r3,[r3]
 2599 0f86 032B     	 cmp r3,#3
 2600 0f88 4BD1     	 bne .L84
 563:../main.c     **** 											      {
 564:../main.c     **** 												  ReadBuffer2[0]= 	node_id; //highbyte
 2601              	 .loc 5 564 0
 2602 0f8a 334B     	 ldr r3,.L126
 2603 0f8c 1A78     	 ldrb r2,[r3]
 2604 0f8e 3F4B     	 ldr r3,.L126+52
 2605 0f90 1A70     	 strb r2,[r3]
 565:../main.c     **** 												  ReadBuffer2[1]= 	node_id_neu; //lowbyte
 2606              	 .loc 5 565 0
 2607 0f92 324B     	 ldr r3,.L126+4
 2608 0f94 1A78     	 ldrb r2,[r3]
 2609 0f96 3D4B     	 ldr r3,.L126+52
 2610 0f98 5A70     	 strb r2,[r3,#1]
 566:../main.c     **** 												  tester2 = writeNodeid_B2_EEprom();
 2611              	 .loc 5 566 0
 2612 0f9a FFF7FEFF 	 bl writeNodeid_B2_EEprom
 2613 0f9e 031C     	 mov r3,r0
 2614 0fa0 9AB2     	 uxth r2,r3
 2615 0fa2 3D4B     	 ldr r3,.L126+64
 2616 0fa4 1A80     	 strh r2,[r3]
 567:../main.c     **** 												    if( tester2  == 0x03 )
 2617              	 .loc 5 567 0
 2618 0fa6 3C4B     	 ldr r3,.L126+64
 2619 0fa8 1B88     	 ldrh r3,[r3]
 2620 0faa 032B     	 cmp r3,#3
 2621 0fac 1CD1     	 bne .L85
 568:../main.c     **** 											        {
 569:../main.c     **** 														new_data_HalloBack();
 2622              	 .loc 5 569 0
 2623 0fae FFF7FEFF 	 bl new_data_HalloBack
 570:../main.c     **** 														 new_data[6]='i';
 2624              	 .loc 5 570 0
 2625 0fb2 2C4B     	 ldr r3,.L126+12
 2626 0fb4 6922     	 mov r2,#105
 2627 0fb6 9A71     	 strb r2,[r3,#6]
 571:../main.c     **** 														 new_data[7]='n';
 2628              	 .loc 5 571 0
 2629 0fb8 2A4B     	 ldr r3,.L126+12
 2630 0fba 6E22     	 mov r2,#110
 2631 0fbc DA71     	 strb r2,[r3,#7]
 572:../main.c     **** 														 new_data[8]=tester;
 2632              	 .loc 5 572 0
 2633 0fbe 304B     	 ldr r3,.L126+40
 2634 0fc0 1B68     	 ldr r3,[r3]
 2635 0fc2 DAB2     	 uxtb r2,r3
 2636 0fc4 274B     	 ldr r3,.L126+12
 2637 0fc6 1A72     	 strb r2,[r3,#8]
 573:../main.c     **** 														 new_data[9]=tester2;
 2638              	 .loc 5 573 0
 2639 0fc8 334B     	 ldr r3,.L126+64
 2640 0fca 1B88     	 ldrh r3,[r3]
 2641 0fcc DAB2     	 uxtb r2,r3
 2642 0fce 254B     	 ldr r3,.L126+12
 2643 0fd0 5A72     	 strb r2,[r3,#9]
 574:../main.c     **** 														UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2644              	 .loc 5 574 0
 2645 0fd2 264B     	 ldr r3,.L126+20
 2646 0fd4 1B78     	 ldrb r3,[r3]
 2647 0fd6 1C1C     	 mov r4,r3
 2648 0fd8 254A     	 ldr r2,.L126+24
 2649 0fda 224B     	 ldr r3,.L126+12
 2650 0fdc 101C     	 mov r0,r2
 2651 0fde 191C     	 mov r1,r3
 2652 0fe0 221C     	 mov r2,r4
 2653 0fe2 FFF7FEFF 	 bl UART_Transmit
 562:../main.c     **** 											      {
 2654              	 .loc 5 562 0
 2655 0fe6 75E0     	 b .L88
 2656              	.L85:
 575:../main.c     **** 											        }
 576:../main.c     **** 												    else
 577:../main.c     **** 												    {
 578:../main.c     **** 													new_data_HalloBack();
 2657              	 .loc 5 578 0
 2658 0fe8 FFF7FEFF 	 bl new_data_HalloBack
 579:../main.c     **** 														 new_data[6]='e';
 2659              	 .loc 5 579 0
 2660 0fec 1D4B     	 ldr r3,.L126+12
 2661 0fee 6522     	 mov r2,#101
 2662 0ff0 9A71     	 strb r2,[r3,#6]
 580:../main.c     **** 														 new_data[7]=7;
 2663              	 .loc 5 580 0
 2664 0ff2 1C4B     	 ldr r3,.L126+12
 2665 0ff4 0722     	 mov r2,#7
 2666 0ff6 DA71     	 strb r2,[r3,#7]
 581:../main.c     **** 														 new_data[8]=tester;
 2667              	 .loc 5 581 0
 2668 0ff8 214B     	 ldr r3,.L126+40
 2669 0ffa 1B68     	 ldr r3,[r3]
 2670 0ffc DAB2     	 uxtb r2,r3
 2671 0ffe 194B     	 ldr r3,.L126+12
 2672 1000 1A72     	 strb r2,[r3,#8]
 582:../main.c     **** 														 new_data[9]=tester2;
 2673              	 .loc 5 582 0
 2674 1002 254B     	 ldr r3,.L126+64
 2675 1004 1B88     	 ldrh r3,[r3]
 2676 1006 DAB2     	 uxtb r2,r3
 2677 1008 164B     	 ldr r3,.L126+12
 2678 100a 5A72     	 strb r2,[r3,#9]
 583:../main.c     **** 														UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2679              	 .loc 5 583 0
 2680 100c 174B     	 ldr r3,.L126+20
 2681 100e 1B78     	 ldrb r3,[r3]
 2682 1010 1C1C     	 mov r4,r3
 2683 1012 174A     	 ldr r2,.L126+24
 2684 1014 134B     	 ldr r3,.L126+12
 2685 1016 101C     	 mov r0,r2
 2686 1018 191C     	 mov r1,r3
 2687 101a 221C     	 mov r2,r4
 2688 101c FFF7FEFF 	 bl UART_Transmit
 562:../main.c     **** 											      {
 2689              	 .loc 5 562 0
 2690 1020 58E0     	 b .L88
 2691              	.L84:
 584:../main.c     **** 												    }
 585:../main.c     **** 											      }
 586:../main.c     **** 												    else
 587:../main.c     **** 												  {
 588:../main.c     **** 												  new_data_HalloBack();
 2692              	 .loc 5 588 0
 2693 1022 FFF7FEFF 	 bl new_data_HalloBack
 589:../main.c     **** 												  new_data[6]='e';
 2694              	 .loc 5 589 0
 2695 1026 0F4B     	 ldr r3,.L126+12
 2696 1028 6522     	 mov r2,#101
 2697 102a 9A71     	 strb r2,[r3,#6]
 590:../main.c     **** 												  new_data[7]=8;
 2698              	 .loc 5 590 0
 2699 102c 0D4B     	 ldr r3,.L126+12
 2700 102e 0822     	 mov r2,#8
 2701 1030 DA71     	 strb r2,[r3,#7]
 591:../main.c     **** 												  new_data[8]=tester;
 2702              	 .loc 5 591 0
 2703 1032 134B     	 ldr r3,.L126+40
 2704 1034 1B68     	 ldr r3,[r3]
 2705 1036 DAB2     	 uxtb r2,r3
 2706 1038 0A4B     	 ldr r3,.L126+12
 2707 103a 1A72     	 strb r2,[r3,#8]
 592:../main.c     **** 												  new_data[9]=0;
 2708              	 .loc 5 592 0
 2709 103c 094B     	 ldr r3,.L126+12
 2710 103e 0022     	 mov r2,#0
 2711 1040 5A72     	 strb r2,[r3,#9]
 593:../main.c     **** 												  UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2712              	 .loc 5 593 0
 2713 1042 0A4B     	 ldr r3,.L126+20
 2714 1044 1B78     	 ldrb r3,[r3]
 2715 1046 1C1C     	 mov r4,r3
 2716 1048 094A     	 ldr r2,.L126+24
 2717 104a 064B     	 ldr r3,.L126+12
 2718 104c 101C     	 mov r0,r2
 2719 104e 191C     	 mov r1,r3
 2720 1050 221C     	 mov r2,r4
 2721 1052 FFF7FEFF 	 bl UART_Transmit
 562:../main.c     **** 											      {
 2722              	 .loc 5 562 0
 2723 1056 3DE0     	 b .L88
 2724              	.L127:
 2725              	 .align 2
 2726              	.L126:
 2727 1058 00000000 	 .word node_id
 2728 105c 00000000 	 .word node_id_neu
 2729 1060 00000000 	 .word command_nr
 2730 1064 00000000 	 .word new_data
 2731 1068 00000000 	 .word Ser_NrL
 2732 106c 00000000 	 .word transmit_buf_size
 2733 1070 00000000 	 .word UART_1
 2734 1074 00000000 	 .word ReadData
 2735 1078 00000000 	 .word neu_Ser_NrH
 2736 107c 00000000 	 .word neu_Ser_NrL
 2737 1080 00000000 	 .word tester
 2738 1084 00000000 	 .word ReadBuffer1
 2739 1088 00000000 	 .word Ser_NrH
 2740 108c 00000000 	 .word ReadBuffer2
 2741 1090 00000000 	 .word node_id_alt
 2742 1094 00000000 	 .word node_id_16bit
 2743 1098 00000000 	 .word tester2
 2744              	.L83:
 594:../main.c     **** 												  }
 595:../main.c     **** 												}
 596:../main.c     **** 										        else
 597:../main.c     **** 										        {
 598:../main.c     **** 										         new_data_HalloBack();
 2745              	 .loc 5 598 0
 2746 109c FFF7FEFF 	 bl new_data_HalloBack
 599:../main.c     **** 										         new_data[6]='e';
 2747              	 .loc 5 599 0
 2748 10a0 C54B     	 ldr r3,.L128
 2749 10a2 6522     	 mov r2,#101
 2750 10a4 9A71     	 strb r2,[r3,#6]
 600:../main.c     **** 										         new_data[7]=9;
 2751              	 .loc 5 600 0
 2752 10a6 C44B     	 ldr r3,.L128
 2753 10a8 0922     	 mov r2,#9
 2754 10aa DA71     	 strb r2,[r3,#7]
 601:../main.c     **** 										         new_data[8]=command_nr;
 2755              	 .loc 5 601 0
 2756 10ac C34B     	 ldr r3,.L128+4
 2757 10ae 1B88     	 ldrh r3,[r3]
 2758 10b0 DAB2     	 uxtb r2,r3
 2759 10b2 C14B     	 ldr r3,.L128
 2760 10b4 1A72     	 strb r2,[r3,#8]
 602:../main.c     **** 										         new_data[9]=0;
 2761              	 .loc 5 602 0
 2762 10b6 C04B     	 ldr r3,.L128
 2763 10b8 0022     	 mov r2,#0
 2764 10ba 5A72     	 strb r2,[r3,#9]
 603:../main.c     **** 										         UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2765              	 .loc 5 603 0
 2766 10bc C04B     	 ldr r3,.L128+8
 2767 10be 1B78     	 ldrb r3,[r3]
 2768 10c0 1C1C     	 mov r4,r3
 2769 10c2 C04A     	 ldr r2,.L128+12
 2770 10c4 BC4B     	 ldr r3,.L128
 2771 10c6 101C     	 mov r0,r2
 2772 10c8 191C     	 mov r1,r3
 2773 10ca 221C     	 mov r2,r4
 2774 10cc FFF7FEFF 	 bl UART_Transmit
 604:../main.c     **** 										         }
 605:../main.c     **** 
 606:../main.c     **** 											break;
 2775              	 .loc 5 606 0
 2776 10d0 00F05CFE 	 bl .L47
 2777              	.L88:
 2778              	 .loc 5 606 0 is_stmt 0 discriminator 8
 2779 10d4 00F05AFE 	 bl .L47
 2780              	.L52:
 607:../main.c     **** 
 608:../main.c     **** 				case command_neuSerNrWriteResi:
 609:../main.c     **** 											if (command_nr == 0x66 && Ser_NrH == (ReadData[1] * 0x100 + ReadData[2]) && Ser_NrL  == 
 2781              	 .loc 5 609 0 is_stmt 1
 2782 10d8 B84B     	 ldr r3,.L128+4
 2783 10da 1B88     	 ldrh r3,[r3]
 2784 10dc 662B     	 cmp r3,#102
 2785 10de 00D0     	 beq .LCB2326
 2786 10e0 7AE0     	 b .L89
 2787              	.LCB2326:
 2788              	 .loc 5 609 0 is_stmt 0 discriminator 1
 2789 10e2 B94B     	 ldr r3,.L128+16
 2790 10e4 1B88     	 ldrh r3,[r3]
 2791 10e6 191C     	 mov r1,r3
 2792 10e8 B84B     	 ldr r3,.L128+20
 2793 10ea 5B78     	 ldrb r3,[r3,#1]
 2794 10ec 1B02     	 lsl r3,r3,#8
 2795 10ee B74A     	 ldr r2,.L128+20
 2796 10f0 9278     	 ldrb r2,[r2,#2]
 2797 10f2 9B18     	 add r3,r3,r2
 2798 10f4 9942     	 cmp r1,r3
 2799 10f6 6FD1     	 bne .L89
 2800              	 .loc 5 609 0 discriminator 2
 2801 10f8 B54B     	 ldr r3,.L128+24
 2802 10fa 1B88     	 ldrh r3,[r3]
 2803 10fc 191C     	 mov r1,r3
 2804 10fe B34B     	 ldr r3,.L128+20
 2805 1100 DB78     	 ldrb r3,[r3,#3]
 2806 1102 1B02     	 lsl r3,r3,#8
 2807 1104 B14A     	 ldr r2,.L128+20
 2808 1106 1279     	 ldrb r2,[r2,#4]
 2809 1108 9B18     	 add r3,r3,r2
 2810 110a 9942     	 cmp r1,r3
 2811 110c 64D1     	 bne .L89
 610:../main.c     **** 											{
 611:../main.c     **** 												tester2=0xff;
 2812              	 .loc 5 611 0 is_stmt 1
 2813 110e B14B     	 ldr r3,.L128+28
 2814 1110 FF22     	 mov r2,#255
 2815 1112 1A80     	 strh r2,[r3]
 612:../main.c     **** 												tester = readSerNrEEprom();
 2816              	 .loc 5 612 0
 2817 1114 FFF7FEFF 	 bl readSerNrEEprom
 2818 1118 031C     	 mov r3,r0
 2819 111a 1A1C     	 mov r2,r3
 2820 111c AE4B     	 ldr r3,.L128+32
 2821 111e 1A60     	 str r2,[r3]
 613:../main.c     **** 											    if( tester  == 0x03 )
 2822              	 .loc 5 613 0
 2823 1120 AD4B     	 ldr r3,.L128+32
 2824 1122 1B68     	 ldr r3,[r3]
 2825 1124 032B     	 cmp r3,#3
 2826 1126 3AD1     	 bne .L90
 614:../main.c     **** 
 615:../main.c     **** 											    {
 616:../main.c     **** 												 ReadBuffer1[0]= 	Ser_NrH  / 0x100; //highbyte
 2827              	 .loc 5 616 0
 2828 1128 A74B     	 ldr r3,.L128+16
 2829 112a 1B88     	 ldrh r3,[r3]
 2830 112c 1B0A     	 lsr r3,r3,#8
 2831 112e 9BB2     	 uxth r3,r3
 2832 1130 DAB2     	 uxtb r2,r3
 2833 1132 AA4B     	 ldr r3,.L128+36
 2834 1134 1A70     	 strb r2,[r3]
 617:../main.c     **** 												 ReadBuffer1[1]= 	Ser_NrH  & 0xff; //lowbyte
 2835              	 .loc 5 617 0
 2836 1136 A44B     	 ldr r3,.L128+16
 2837 1138 1B88     	 ldrh r3,[r3]
 2838 113a DAB2     	 uxtb r2,r3
 2839 113c A74B     	 ldr r3,.L128+36
 2840 113e 5A70     	 strb r2,[r3,#1]
 618:../main.c     **** 												 ReadBuffer1[2]= 	Ser_NrL  / 0x100; //highbyte
 2841              	 .loc 5 618 0
 2842 1140 A34B     	 ldr r3,.L128+24
 2843 1142 1B88     	 ldrh r3,[r3]
 2844 1144 1B0A     	 lsr r3,r3,#8
 2845 1146 9BB2     	 uxth r3,r3
 2846 1148 DAB2     	 uxtb r2,r3
 2847 114a A44B     	 ldr r3,.L128+36
 2848 114c 9A70     	 strb r2,[r3,#2]
 619:../main.c     **** 												 ReadBuffer1[3]= 	Ser_NrL  & 0xff; //lowbyte
 2849              	 .loc 5 619 0
 2850 114e A04B     	 ldr r3,.L128+24
 2851 1150 1B88     	 ldrh r3,[r3]
 2852 1152 DAB2     	 uxtb r2,r3
 2853 1154 A14B     	 ldr r3,.L128+36
 2854 1156 DA70     	 strb r2,[r3,#3]
 620:../main.c     **** 												 tester2 = writeSernr_B1_EEprom() ;
 2855              	 .loc 5 620 0
 2856 1158 FFF7FEFF 	 bl writeSernr_B1_EEprom
 2857 115c 031C     	 mov r3,r0
 2858 115e 9AB2     	 uxth r2,r3
 2859 1160 9C4B     	 ldr r3,.L128+28
 2860 1162 1A80     	 strh r2,[r3]
 621:../main.c     **** 												new_data_HalloBack();
 2861              	 .loc 5 621 0
 2862 1164 FFF7FEFF 	 bl new_data_HalloBack
 622:../main.c     **** 												new_data[6]='i';
 2863              	 .loc 5 622 0
 2864 1168 934B     	 ldr r3,.L128
 2865 116a 6922     	 mov r2,#105
 2866 116c 9A71     	 strb r2,[r3,#6]
 623:../main.c     **** 												new_data[7]='n';
 2867              	 .loc 5 623 0
 2868 116e 924B     	 ldr r3,.L128
 2869 1170 6E22     	 mov r2,#110
 2870 1172 DA71     	 strb r2,[r3,#7]
 624:../main.c     **** 												new_data[8]=tester;
 2871              	 .loc 5 624 0
 2872 1174 984B     	 ldr r3,.L128+32
 2873 1176 1B68     	 ldr r3,[r3]
 2874 1178 DAB2     	 uxtb r2,r3
 2875 117a 8F4B     	 ldr r3,.L128
 2876 117c 1A72     	 strb r2,[r3,#8]
 625:../main.c     **** 												new_data[9]=tester2;
 2877              	 .loc 5 625 0
 2878 117e 954B     	 ldr r3,.L128+28
 2879 1180 1B88     	 ldrh r3,[r3]
 2880 1182 DAB2     	 uxtb r2,r3
 2881 1184 8C4B     	 ldr r3,.L128
 2882 1186 5A72     	 strb r2,[r3,#9]
 626:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2883              	 .loc 5 626 0
 2884 1188 8D4B     	 ldr r3,.L128+8
 2885 118a 1B78     	 ldrb r3,[r3]
 2886 118c 1C1C     	 mov r4,r3
 2887 118e 8D4A     	 ldr r2,.L128+12
 2888 1190 894B     	 ldr r3,.L128
 2889 1192 101C     	 mov r0,r2
 2890 1194 191C     	 mov r1,r3
 2891 1196 221C     	 mov r2,r4
 2892 1198 FFF7FEFF 	 bl UART_Transmit
 613:../main.c     **** 
 2893              	 .loc 5 613 0
 2894 119c 3AE0     	 b .L92
 2895              	.L90:
 627:../main.c     **** 											    }
 628:../main.c     **** 											    else {
 629:../main.c     **** 												new_data_HalloBack();
 2896              	 .loc 5 629 0
 2897 119e FFF7FEFF 	 bl new_data_HalloBack
 630:../main.c     **** 												 new_data[6]='e';
 2898              	 .loc 5 630 0
 2899 11a2 854B     	 ldr r3,.L128
 2900 11a4 6522     	 mov r2,#101
 2901 11a6 9A71     	 strb r2,[r3,#6]
 631:../main.c     **** 												 new_data[7]=17;
 2902              	 .loc 5 631 0
 2903 11a8 834B     	 ldr r3,.L128
 2904 11aa 1122     	 mov r2,#17
 2905 11ac DA71     	 strb r2,[r3,#7]
 632:../main.c     **** 												 new_data[8]=tester;
 2906              	 .loc 5 632 0
 2907 11ae 8A4B     	 ldr r3,.L128+32
 2908 11b0 1B68     	 ldr r3,[r3]
 2909 11b2 DAB2     	 uxtb r2,r3
 2910 11b4 804B     	 ldr r3,.L128
 2911 11b6 1A72     	 strb r2,[r3,#8]
 633:../main.c     **** 												 new_data[9]=tester2;
 2912              	 .loc 5 633 0
 2913 11b8 864B     	 ldr r3,.L128+28
 2914 11ba 1B88     	 ldrh r3,[r3]
 2915 11bc DAB2     	 uxtb r2,r3
 2916 11be 7E4B     	 ldr r3,.L128
 2917 11c0 5A72     	 strb r2,[r3,#9]
 634:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2918              	 .loc 5 634 0
 2919 11c2 7F4B     	 ldr r3,.L128+8
 2920 11c4 1B78     	 ldrb r3,[r3]
 2921 11c6 1C1C     	 mov r4,r3
 2922 11c8 7E4A     	 ldr r2,.L128+12
 2923 11ca 7B4B     	 ldr r3,.L128
 2924 11cc 101C     	 mov r0,r2
 2925 11ce 191C     	 mov r1,r3
 2926 11d0 221C     	 mov r2,r4
 2927 11d2 FFF7FEFF 	 bl UART_Transmit
 613:../main.c     **** 
 2928              	 .loc 5 613 0
 2929 11d6 1DE0     	 b .L92
 2930              	.L89:
 635:../main.c     **** 											    }
 636:../main.c     **** 											}
 637:../main.c     **** 											 else {
 638:../main.c     **** 											new_data_HalloBack();
 2931              	 .loc 5 638 0
 2932 11d8 FFF7FEFF 	 bl new_data_HalloBack
 639:../main.c     **** 											new_data[6]='e';
 2933              	 .loc 5 639 0
 2934 11dc 764B     	 ldr r3,.L128
 2935 11de 6522     	 mov r2,#101
 2936 11e0 9A71     	 strb r2,[r3,#6]
 640:../main.c     **** 											new_data[7]=18;
 2937              	 .loc 5 640 0
 2938 11e2 754B     	 ldr r3,.L128
 2939 11e4 1222     	 mov r2,#18
 2940 11e6 DA71     	 strb r2,[r3,#7]
 641:../main.c     **** 											new_data[8]=tester;
 2941              	 .loc 5 641 0
 2942 11e8 7B4B     	 ldr r3,.L128+32
 2943 11ea 1B68     	 ldr r3,[r3]
 2944 11ec DAB2     	 uxtb r2,r3
 2945 11ee 724B     	 ldr r3,.L128
 2946 11f0 1A72     	 strb r2,[r3,#8]
 642:../main.c     **** 											new_data[9]=tester2;
 2947              	 .loc 5 642 0
 2948 11f2 784B     	 ldr r3,.L128+28
 2949 11f4 1B88     	 ldrh r3,[r3]
 2950 11f6 DAB2     	 uxtb r2,r3
 2951 11f8 6F4B     	 ldr r3,.L128
 2952 11fa 5A72     	 strb r2,[r3,#9]
 643:../main.c     **** 											UART_Transmit(&UART_1, new_data,transmit_buf_size);
 2953              	 .loc 5 643 0
 2954 11fc 704B     	 ldr r3,.L128+8
 2955 11fe 1B78     	 ldrb r3,[r3]
 2956 1200 1C1C     	 mov r4,r3
 2957 1202 704A     	 ldr r2,.L128+12
 2958 1204 6C4B     	 ldr r3,.L128
 2959 1206 101C     	 mov r0,r2
 2960 1208 191C     	 mov r1,r3
 2961 120a 221C     	 mov r2,r4
 2962 120c FFF7FEFF 	 bl UART_Transmit
 644:../main.c     **** 											 }
 645:../main.c     **** 											break;
 2963              	 .loc 5 645 0
 2964 1210 00F0BCFD 	 bl .L47
 2965              	.L92:
 2966              	 .loc 5 645 0 is_stmt 0 discriminator 9
 2967 1214 00F0BAFD 	 bl .L47
 2968              	.L56:
 646:../main.c     **** 				case command_neuakt_lightWriteResi:
 647:../main.c     **** 												if (Ser_NrH == (ReadData[1] * 0x100 + ReadData[2]) && Ser_NrL  == (ReadData[3] * 0x100 
 2969              	 .loc 5 647 0 is_stmt 1
 2970 1218 6B4B     	 ldr r3,.L128+16
 2971 121a 1B88     	 ldrh r3,[r3]
 2972 121c 191C     	 mov r1,r3
 2973 121e 6B4B     	 ldr r3,.L128+20
 2974 1220 5B78     	 ldrb r3,[r3,#1]
 2975 1222 1B02     	 lsl r3,r3,#8
 2976 1224 694A     	 ldr r2,.L128+20
 2977 1226 9278     	 ldrb r2,[r2,#2]
 2978 1228 9B18     	 add r3,r3,r2
 2979 122a 9942     	 cmp r1,r3
 2980 122c 00D0     	 beq .LCB2494
 2981 122e A5E0     	 b .L93
 2982              	.LCB2494:
 2983              	 .loc 5 647 0 is_stmt 0 discriminator 1
 2984 1230 674B     	 ldr r3,.L128+24
 2985 1232 1B88     	 ldrh r3,[r3]
 2986 1234 191C     	 mov r1,r3
 2987 1236 654B     	 ldr r3,.L128+20
 2988 1238 DB78     	 ldrb r3,[r3,#3]
 2989 123a 1B02     	 lsl r3,r3,#8
 2990 123c 634A     	 ldr r2,.L128+20
 2991 123e 1279     	 ldrb r2,[r2,#4]
 2992 1240 9B18     	 add r3,r3,r2
 2993 1242 9942     	 cmp r1,r3
 2994 1244 00D0     	 beq .LCB2505
 2995 1246 99E0     	 b .L93
 2996              	.LCB2505:
 648:../main.c     **** 												{
 649:../main.c     **** 													    ReadBuffer2[0]=Dimm_Gamma;
 2997              	 .loc 5 649 0 is_stmt 1
 2998 1248 654B     	 ldr r3,.L128+40
 2999 124a 1A78     	 ldrb r2,[r3]
 3000 124c 654B     	 ldr r3,.L128+44
 3001 124e 1A70     	 strb r2,[r3]
 650:../main.c     **** 													    ReadBuffer2[1]=Dimm_Stufen;
 3002              	 .loc 5 650 0
 3003 1250 654B     	 ldr r3,.L128+48
 3004 1252 1A78     	 ldrb r2,[r3]
 3005 1254 634B     	 ldr r3,.L128+44
 3006 1256 5A70     	 strb r2,[r3,#1]
 651:../main.c     **** 													    ReadBuffer2[2] = Dimm_StufenGR;
 3007              	 .loc 5 651 0
 3008 1258 644B     	 ldr r3,.L128+52
 3009 125a 1A78     	 ldrb r2,[r3]
 3010 125c 614B     	 ldr r3,.L128+44
 3011 125e 9A70     	 strb r2,[r3,#2]
 652:../main.c     **** 													    ReadBuffer2[3] = Dimm_Valu;
 3012              	 .loc 5 652 0
 3013 1260 634B     	 ldr r3,.L128+56
 3014 1262 1A78     	 ldrb r2,[r3]
 3015 1264 5F4B     	 ldr r3,.L128+44
 3016 1266 DA70     	 strb r2,[r3,#3]
 653:../main.c     **** 													    ReadBuffer2[4] = Smooth_Value / 0x100;
 3017              	 .loc 5 653 0
 3018 1268 624B     	 ldr r3,.L128+60
 3019 126a 1B88     	 ldrh r3,[r3]
 3020 126c 1B0A     	 lsr r3,r3,#8
 3021 126e 9BB2     	 uxth r3,r3
 3022 1270 DAB2     	 uxtb r2,r3
 3023 1272 5C4B     	 ldr r3,.L128+44
 3024 1274 1A71     	 strb r2,[r3,#4]
 654:../main.c     **** 													    ReadBuffer2[5] = Smooth_Value & 0xff;
 3025              	 .loc 5 654 0
 3026 1276 5F4B     	 ldr r3,.L128+60
 3027 1278 1B88     	 ldrh r3,[r3]
 3028 127a DAB2     	 uxtb r2,r3
 3029 127c 594B     	 ldr r3,.L128+44
 3030 127e 5A71     	 strb r2,[r3,#5]
 655:../main.c     **** 													    ReadBuffer2[6] = linearwalk_gen /0x100;
 3031              	 .loc 5 655 0
 3032 1280 5D4B     	 ldr r3,.L128+64
 3033 1282 1B88     	 ldrh r3,[r3]
 3034 1284 1B0A     	 lsr r3,r3,#8
 3035 1286 9BB2     	 uxth r3,r3
 3036 1288 DAB2     	 uxtb r2,r3
 3037 128a 564B     	 ldr r3,.L128+44
 3038 128c 9A71     	 strb r2,[r3,#6]
 656:../main.c     **** 													    ReadBuffer2[7] = linearwalk_gen & 0xff;
 3039              	 .loc 5 656 0
 3040 128e 5A4B     	 ldr r3,.L128+64
 3041 1290 1B88     	 ldrh r3,[r3]
 3042 1292 DAB2     	 uxtb r2,r3
 3043 1294 534B     	 ldr r3,.L128+44
 3044 1296 DA71     	 strb r2,[r3,#7]
 657:../main.c     **** 													    ReadBuffer2[8] = Farbe_wwcw_Quot_gen / 0x100;
 3045              	 .loc 5 657 0
 3046 1298 584B     	 ldr r3,.L128+68
 3047 129a 1B88     	 ldrh r3,[r3]
 3048 129c 1B0A     	 lsr r3,r3,#8
 3049 129e 9BB2     	 uxth r3,r3
 3050 12a0 DAB2     	 uxtb r2,r3
 3051 12a2 504B     	 ldr r3,.L128+44
 3052 12a4 1A72     	 strb r2,[r3,#8]
 658:../main.c     **** 													    ReadBuffer2[9] = Farbe_wwcw_Quot_gen & 0xff;
 3053              	 .loc 5 658 0
 3054 12a6 554B     	 ldr r3,.L128+68
 3055 12a8 1B88     	 ldrh r3,[r3]
 3056 12aa DAB2     	 uxtb r2,r3
 3057 12ac 4D4B     	 ldr r3,.L128+44
 3058 12ae 5A72     	 strb r2,[r3,#9]
 659:../main.c     **** 													    ReadBuffer2[10] = Reserve_1 /0x100;
 3059              	 .loc 5 659 0
 3060 12b0 534B     	 ldr r3,.L128+72
 3061 12b2 1B88     	 ldrh r3,[r3]
 3062 12b4 1B0A     	 lsr r3,r3,#8
 3063 12b6 9BB2     	 uxth r3,r3
 3064 12b8 DAB2     	 uxtb r2,r3
 3065 12ba 4A4B     	 ldr r3,.L128+44
 3066 12bc 9A72     	 strb r2,[r3,#10]
 660:../main.c     **** 													    ReadBuffer2[11] = Reserve_1 & 0xff;
 3067              	 .loc 5 660 0
 3068 12be 504B     	 ldr r3,.L128+72
 3069 12c0 1B88     	 ldrh r3,[r3]
 3070 12c2 DAB2     	 uxtb r2,r3
 3071 12c4 474B     	 ldr r3,.L128+44
 3072 12c6 DA72     	 strb r2,[r3,#11]
 661:../main.c     **** 													    ReadBuffer2[12] = Dimm_Max_WW /0x100;
 3073              	 .loc 5 661 0
 3074 12c8 4E4B     	 ldr r3,.L128+76
 3075 12ca 1B88     	 ldrh r3,[r3]
 3076 12cc 1B0A     	 lsr r3,r3,#8
 3077 12ce 9BB2     	 uxth r3,r3
 3078 12d0 DAB2     	 uxtb r2,r3
 3079 12d2 444B     	 ldr r3,.L128+44
 3080 12d4 1A73     	 strb r2,[r3,#12]
 662:../main.c     **** 													    ReadBuffer2[13] = Dimm_Max_WW & 0xff;
 3081              	 .loc 5 662 0
 3082 12d6 4B4B     	 ldr r3,.L128+76
 3083 12d8 1B88     	 ldrh r3,[r3]
 3084 12da DAB2     	 uxtb r2,r3
 3085 12dc 414B     	 ldr r3,.L128+44
 3086 12de 5A73     	 strb r2,[r3,#13]
 663:../main.c     **** 													    ReadBuffer2[14] = Dimm_Max_CW /0x100;
 3087              	 .loc 5 663 0
 3088 12e0 494B     	 ldr r3,.L128+80
 3089 12e2 1B88     	 ldrh r3,[r3]
 3090 12e4 1B0A     	 lsr r3,r3,#8
 3091 12e6 9BB2     	 uxth r3,r3
 3092 12e8 DAB2     	 uxtb r2,r3
 3093 12ea 3E4B     	 ldr r3,.L128+44
 3094 12ec 9A73     	 strb r2,[r3,#14]
 664:../main.c     **** 													    ReadBuffer2[15] = Dimm_Max_CW & 0xff;
 3095              	 .loc 5 664 0
 3096 12ee 464B     	 ldr r3,.L128+80
 3097 12f0 1B88     	 ldrh r3,[r3]
 3098 12f2 DAB2     	 uxtb r2,r3
 3099 12f4 3B4B     	 ldr r3,.L128+44
 3100 12f6 DA73     	 strb r2,[r3,#15]
 665:../main.c     **** 
 666:../main.c     **** 												   if (resultB2 > min_EEP_Voltage_Uin)
 3101              	 .loc 5 666 0
 3102 12f8 444B     	 ldr r3,.L128+84
 3103 12fa 1A88     	 ldrh r2,[r3]
 3104 12fc BA23     	 mov r3,#186
 3105 12fe 1B01     	 lsl r3,r3,#4
 3106 1300 9A42     	 cmp r2,r3
 3107 1302 20D9     	 bls .L94
 667:../main.c     **** 												   {
 668:../main.c     **** 											        tester2 = writeakt_light_data_B4_EEprom();
 3108              	 .loc 5 668 0
 3109 1304 FFF7FEFF 	 bl writeakt_light_data_B4_EEprom
 3110 1308 031C     	 mov r3,r0
 3111 130a 9AB2     	 uxth r2,r3
 3112 130c 314B     	 ldr r3,.L128+28
 3113 130e 1A80     	 strh r2,[r3]
 669:../main.c     **** 													new_data_HalloBack();
 3114              	 .loc 5 669 0
 3115 1310 FFF7FEFF 	 bl new_data_HalloBack
 670:../main.c     **** 													new_data[6]='i';
 3116              	 .loc 5 670 0
 3117 1314 284B     	 ldr r3,.L128
 3118 1316 6922     	 mov r2,#105
 3119 1318 9A71     	 strb r2,[r3,#6]
 671:../main.c     **** 													new_data[7]='n';
 3120              	 .loc 5 671 0
 3121 131a 274B     	 ldr r3,.L128
 3122 131c 6E22     	 mov r2,#110
 3123 131e DA71     	 strb r2,[r3,#7]
 672:../main.c     **** 													new_data[8]=0;
 3124              	 .loc 5 672 0
 3125 1320 254B     	 ldr r3,.L128
 3126 1322 0022     	 mov r2,#0
 3127 1324 1A72     	 strb r2,[r3,#8]
 673:../main.c     **** 													new_data[9]=tester2;
 3128              	 .loc 5 673 0
 3129 1326 2B4B     	 ldr r3,.L128+28
 3130 1328 1B88     	 ldrh r3,[r3]
 3131 132a DAB2     	 uxtb r2,r3
 3132 132c 224B     	 ldr r3,.L128
 3133 132e 5A72     	 strb r2,[r3,#9]
 674:../main.c     **** 													UART_Transmit(&UART_1, new_data,transmit_buf_size);
 3134              	 .loc 5 674 0
 3135 1330 234B     	 ldr r3,.L128+8
 3136 1332 1B78     	 ldrb r3,[r3]
 3137 1334 1C1C     	 mov r4,r3
 3138 1336 234A     	 ldr r2,.L128+12
 3139 1338 1F4B     	 ldr r3,.L128
 3140 133a 101C     	 mov r0,r2
 3141 133c 191C     	 mov r1,r3
 3142 133e 221C     	 mov r2,r4
 3143 1340 FFF7FEFF 	 bl UART_Transmit
 666:../main.c     **** 												   {
 3144              	 .loc 5 666 0
 3145 1344 36E0     	 b .L96
 3146              	.L94:
 675:../main.c     **** 												   }
 676:../main.c     **** 												    else {
 677:../main.c     **** 													new_data_HalloBack();
 3147              	 .loc 5 677 0
 3148 1346 FFF7FEFF 	 bl new_data_HalloBack
 678:../main.c     **** 													 new_data[6]='e';
 3149              	 .loc 5 678 0
 3150 134a 1B4B     	 ldr r3,.L128
 3151 134c 6522     	 mov r2,#101
 3152 134e 9A71     	 strb r2,[r3,#6]
 679:../main.c     **** 													 new_data[7]=75;
 3153              	 .loc 5 679 0
 3154 1350 194B     	 ldr r3,.L128
 3155 1352 4B22     	 mov r2,#75
 3156 1354 DA71     	 strb r2,[r3,#7]
 680:../main.c     **** 													 new_data[8]=0;
 3157              	 .loc 5 680 0
 3158 1356 184B     	 ldr r3,.L128
 3159 1358 0022     	 mov r2,#0
 3160 135a 1A72     	 strb r2,[r3,#8]
 681:../main.c     **** 													 new_data[9]=tester2;
 3161              	 .loc 5 681 0
 3162 135c 1D4B     	 ldr r3,.L128+28
 3163 135e 1B88     	 ldrh r3,[r3]
 3164 1360 DAB2     	 uxtb r2,r3
 3165 1362 154B     	 ldr r3,.L128
 3166 1364 5A72     	 strb r2,[r3,#9]
 682:../main.c     **** 													UART_Transmit(&UART_1, new_data,transmit_buf_size);
 3167              	 .loc 5 682 0
 3168 1366 164B     	 ldr r3,.L128+8
 3169 1368 1B78     	 ldrb r3,[r3]
 3170 136a 1C1C     	 mov r4,r3
 3171 136c 154A     	 ldr r2,.L128+12
 3172 136e 124B     	 ldr r3,.L128
 3173 1370 101C     	 mov r0,r2
 3174 1372 191C     	 mov r1,r3
 3175 1374 221C     	 mov r2,r4
 3176 1376 FFF7FEFF 	 bl UART_Transmit
 666:../main.c     **** 												   {
 3177              	 .loc 5 666 0
 3178 137a 1BE0     	 b .L96
 3179              	.L93:
 683:../main.c     **** 												    }
 684:../main.c     **** 												}
 685:../main.c     **** 												 else {
 686:../main.c     **** 												new_data_HalloBack();
 3180              	 .loc 5 686 0
 3181 137c FFF7FEFF 	 bl new_data_HalloBack
 687:../main.c     **** 												new_data[6]='e';
 3182              	 .loc 5 687 0
 3183 1380 0D4B     	 ldr r3,.L128
 3184 1382 6522     	 mov r2,#101
 3185 1384 9A71     	 strb r2,[r3,#6]
 688:../main.c     **** 												new_data[7]=28;
 3186              	 .loc 5 688 0
 3187 1386 0C4B     	 ldr r3,.L128
 3188 1388 1C22     	 mov r2,#28
 3189 138a DA71     	 strb r2,[r3,#7]
 689:../main.c     **** 												new_data[8]=0;
 3190              	 .loc 5 689 0
 3191 138c 0A4B     	 ldr r3,.L128
 3192 138e 0022     	 mov r2,#0
 3193 1390 1A72     	 strb r2,[r3,#8]
 690:../main.c     **** 												new_data[9]=tester2;
 3194              	 .loc 5 690 0
 3195 1392 104B     	 ldr r3,.L128+28
 3196 1394 1B88     	 ldrh r3,[r3]
 3197 1396 DAB2     	 uxtb r2,r3
 3198 1398 074B     	 ldr r3,.L128
 3199 139a 5A72     	 strb r2,[r3,#9]
 691:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 3200              	 .loc 5 691 0
 3201 139c 084B     	 ldr r3,.L128+8
 3202 139e 1B78     	 ldrb r3,[r3]
 3203 13a0 1C1C     	 mov r4,r3
 3204 13a2 084A     	 ldr r2,.L128+12
 3205 13a4 044B     	 ldr r3,.L128
 3206 13a6 101C     	 mov r0,r2
 3207 13a8 191C     	 mov r1,r3
 3208 13aa 221C     	 mov r2,r4
 3209 13ac FFF7FEFF 	 bl UART_Transmit
 692:../main.c     **** 												 }
 693:../main.c     **** 												break;
 3210              	 .loc 5 693 0
 3211 13b0 00F0ECFC 	 bl .L47
 3212              	.L96:
 3213              	 .loc 5 693 0 is_stmt 0 discriminator 10
 3214 13b4 00F0EAFC 	 bl .L47
 3215              	.L129:
 3216              	 .align 2
 3217              	.L128:
 3218 13b8 00000000 	 .word new_data
 3219 13bc 00000000 	 .word command_nr
 3220 13c0 00000000 	 .word transmit_buf_size
 3221 13c4 00000000 	 .word UART_1
 3222 13c8 00000000 	 .word Ser_NrH
 3223 13cc 00000000 	 .word ReadData
 3224 13d0 00000000 	 .word Ser_NrL
 3225 13d4 00000000 	 .word tester2
 3226 13d8 00000000 	 .word tester
 3227 13dc 00000000 	 .word ReadBuffer1
 3228 13e0 00000000 	 .word Dimm_Gamma
 3229 13e4 00000000 	 .word ReadBuffer2
 3230 13e8 00000000 	 .word Dimm_Stufen
 3231 13ec 00000000 	 .word Dimm_StufenGR
 3232 13f0 00000000 	 .word Dimm_Valu
 3233 13f4 00000000 	 .word Smooth_Value
 3234 13f8 00000000 	 .word linearwalk_gen
 3235 13fc 00000000 	 .word Farbe_wwcw_Quot_gen
 3236 1400 00000000 	 .word Reserve_1
 3237 1404 00000000 	 .word Dimm_Max_WW
 3238 1408 00000000 	 .word Dimm_Max_CW
 3239 140c 00000000 	 .word resultB2
 3240              	.L55:
 694:../main.c     **** 				case command_neuofflightWriteResi:
 695:../main.c     **** 												if (Ser_NrH == (ReadData[1] * 0x100 + ReadData[2]) && Ser_NrL  == (ReadData[3] * 0x100 
 3241              	 .loc 5 695 0 is_stmt 1
 3242 1410 D24B     	 ldr r3,.L130
 3243 1412 1B88     	 ldrh r3,[r3]
 3244 1414 191C     	 mov r1,r3
 3245 1416 D24B     	 ldr r3,.L130+4
 3246 1418 5B78     	 ldrb r3,[r3,#1]
 3247 141a 1B02     	 lsl r3,r3,#8
 3248 141c D04A     	 ldr r2,.L130+4
 3249 141e 9278     	 ldrb r2,[r2,#2]
 3250 1420 9B18     	 add r3,r3,r2
 3251 1422 9942     	 cmp r1,r3
 3252 1424 00D0     	 beq .LCB2730
 3253 1426 A9E0     	 b .L97
 3254              	.LCB2730:
 3255              	 .loc 5 695 0 is_stmt 0 discriminator 1
 3256 1428 CE4B     	 ldr r3,.L130+8
 3257 142a 1B88     	 ldrh r3,[r3]
 3258 142c 191C     	 mov r1,r3
 3259 142e CC4B     	 ldr r3,.L130+4
 3260 1430 DB78     	 ldrb r3,[r3,#3]
 3261 1432 1B02     	 lsl r3,r3,#8
 3262 1434 CA4A     	 ldr r2,.L130+4
 3263 1436 1279     	 ldrb r2,[r2,#4]
 3264 1438 9B18     	 add r3,r3,r2
 3265 143a 9942     	 cmp r1,r3
 3266 143c 00D0     	 beq .LCB2741
 3267 143e 9DE0     	 b .L97
 3268              	.LCB2741:
 696:../main.c     **** 												{
 697:../main.c     **** 													    ReadBuffer2[0]=RegOnOff;
 3269              	 .loc 5 697 0 is_stmt 1
 3270 1440 C94B     	 ldr r3,.L130+12
 3271 1442 1A78     	 ldrb r2,[r3]
 3272 1444 C94B     	 ldr r3,.L130+16
 3273 1446 1A70     	 strb r2,[r3]
 698:../main.c     **** 													    ReadBuffer2[1]=RegOnOff2;
 3274              	 .loc 5 698 0
 3275 1448 C94B     	 ldr r3,.L130+20
 3276 144a 1A78     	 ldrb r2,[r3]
 3277 144c C74B     	 ldr r3,.L130+16
 3278 144e 5A70     	 strb r2,[r3,#1]
 699:../main.c     **** 													    ReadBuffer2[2] = Reserve_2 / 0x100;
 3279              	 .loc 5 699 0
 3280 1450 C84B     	 ldr r3,.L130+24
 3281 1452 1B88     	 ldrh r3,[r3]
 3282 1454 1B0A     	 lsr r3,r3,#8
 3283 1456 9BB2     	 uxth r3,r3
 3284 1458 DAB2     	 uxtb r2,r3
 3285 145a C44B     	 ldr r3,.L130+16
 3286 145c 9A70     	 strb r2,[r3,#2]
 700:../main.c     **** 													    ReadBuffer2[3] = Reserve_2 & 0xff;
 3287              	 .loc 5 700 0
 3288 145e C54B     	 ldr r3,.L130+24
 3289 1460 1B88     	 ldrh r3,[r3]
 3290 1462 DAB2     	 uxtb r2,r3
 3291 1464 C14B     	 ldr r3,.L130+16
 3292 1466 DA70     	 strb r2,[r3,#3]
 701:../main.c     **** 													    ReadBuffer2[4] = dimOff_Ww / 0x100;
 3293              	 .loc 5 701 0
 3294 1468 C34B     	 ldr r3,.L130+28
 3295 146a 1B88     	 ldrh r3,[r3]
 3296 146c 1B0A     	 lsr r3,r3,#8
 3297 146e 9BB2     	 uxth r3,r3
 3298 1470 DAB2     	 uxtb r2,r3
 3299 1472 BE4B     	 ldr r3,.L130+16
 3300 1474 1A71     	 strb r2,[r3,#4]
 702:../main.c     **** 													    ReadBuffer2[5] = dimOff_Ww & 0xff;
 3301              	 .loc 5 702 0
 3302 1476 C04B     	 ldr r3,.L130+28
 3303 1478 1B88     	 ldrh r3,[r3]
 3304 147a DAB2     	 uxtb r2,r3
 3305 147c BB4B     	 ldr r3,.L130+16
 3306 147e 5A71     	 strb r2,[r3,#5]
 703:../main.c     **** 													    ReadBuffer2[6] = dimOff_Cw / 0x100;
 3307              	 .loc 5 703 0
 3308 1480 BE4B     	 ldr r3,.L130+32
 3309 1482 1B88     	 ldrh r3,[r3]
 3310 1484 1B0A     	 lsr r3,r3,#8
 3311 1486 9BB2     	 uxth r3,r3
 3312 1488 DAB2     	 uxtb r2,r3
 3313 148a B84B     	 ldr r3,.L130+16
 3314 148c 9A71     	 strb r2,[r3,#6]
 704:../main.c     **** 													    ReadBuffer2[7] = dimOff_Cw & 0xff;
 3315              	 .loc 5 704 0
 3316 148e BB4B     	 ldr r3,.L130+32
 3317 1490 1B88     	 ldrh r3,[r3]
 3318 1492 DAB2     	 uxtb r2,r3
 3319 1494 B54B     	 ldr r3,.L130+16
 3320 1496 DA71     	 strb r2,[r3,#7]
 705:../main.c     **** 													    ReadBuffer2[8] = dimNorm1_Ww / 0x100;
 3321              	 .loc 5 705 0
 3322 1498 B94B     	 ldr r3,.L130+36
 3323 149a 1B88     	 ldrh r3,[r3]
 3324 149c 1B0A     	 lsr r3,r3,#8
 3325 149e 9BB2     	 uxth r3,r3
 3326 14a0 DAB2     	 uxtb r2,r3
 3327 14a2 B24B     	 ldr r3,.L130+16
 3328 14a4 1A72     	 strb r2,[r3,#8]
 706:../main.c     **** 													    ReadBuffer2[9] = dimNorm1_Ww & 0xff;
 3329              	 .loc 5 706 0
 3330 14a6 B64B     	 ldr r3,.L130+36
 3331 14a8 1B88     	 ldrh r3,[r3]
 3332 14aa DAB2     	 uxtb r2,r3
 3333 14ac AF4B     	 ldr r3,.L130+16
 3334 14ae 5A72     	 strb r2,[r3,#9]
 707:../main.c     **** 													    ReadBuffer2[10] = dimNorm1_Cw / 0x100;
 3335              	 .loc 5 707 0
 3336 14b0 B44B     	 ldr r3,.L130+40
 3337 14b2 1B88     	 ldrh r3,[r3]
 3338 14b4 1B0A     	 lsr r3,r3,#8
 3339 14b6 9BB2     	 uxth r3,r3
 3340 14b8 DAB2     	 uxtb r2,r3
 3341 14ba AC4B     	 ldr r3,.L130+16
 3342 14bc 9A72     	 strb r2,[r3,#10]
 708:../main.c     **** 													    ReadBuffer2[11] = dimNorm1_Cw & 0xff;
 3343              	 .loc 5 708 0
 3344 14be B14B     	 ldr r3,.L130+40
 3345 14c0 1B88     	 ldrh r3,[r3]
 3346 14c2 DAB2     	 uxtb r2,r3
 3347 14c4 A94B     	 ldr r3,.L130+16
 3348 14c6 DA72     	 strb r2,[r3,#11]
 709:../main.c     **** 													    ReadBuffer2[12] = dimNorm2_Ww / 0x100;
 3349              	 .loc 5 709 0
 3350 14c8 AF4B     	 ldr r3,.L130+44
 3351 14ca 1B88     	 ldrh r3,[r3]
 3352 14cc 1B0A     	 lsr r3,r3,#8
 3353 14ce 9BB2     	 uxth r3,r3
 3354 14d0 DAB2     	 uxtb r2,r3
 3355 14d2 A64B     	 ldr r3,.L130+16
 3356 14d4 1A73     	 strb r2,[r3,#12]
 710:../main.c     **** 													    ReadBuffer2[13] = dimNorm2_Ww & 0xff;
 3357              	 .loc 5 710 0
 3358 14d6 AC4B     	 ldr r3,.L130+44
 3359 14d8 1B88     	 ldrh r3,[r3]
 3360 14da DAB2     	 uxtb r2,r3
 3361 14dc A34B     	 ldr r3,.L130+16
 3362 14de 5A73     	 strb r2,[r3,#13]
 711:../main.c     **** 													    ReadBuffer2[14] = dimNorm2_Cw / 0x100;;
 3363              	 .loc 5 711 0
 3364 14e0 AA4B     	 ldr r3,.L130+48
 3365 14e2 1B88     	 ldrh r3,[r3]
 3366 14e4 1B0A     	 lsr r3,r3,#8
 3367 14e6 9BB2     	 uxth r3,r3
 3368 14e8 DAB2     	 uxtb r2,r3
 3369 14ea A04B     	 ldr r3,.L130+16
 3370 14ec 9A73     	 strb r2,[r3,#14]
 712:../main.c     **** 													    ReadBuffer2[15] = dimNorm2_Cw & 0xff;
 3371              	 .loc 5 712 0
 3372 14ee A74B     	 ldr r3,.L130+48
 3373 14f0 1B88     	 ldrh r3,[r3]
 3374 14f2 DAB2     	 uxtb r2,r3
 3375 14f4 9D4B     	 ldr r3,.L130+16
 3376 14f6 DA73     	 strb r2,[r3,#15]
 713:../main.c     **** 
 714:../main.c     **** 												   if (resultB2 > min_EEP_Voltage_Uin)
 3377              	 .loc 5 714 0
 3378 14f8 A54B     	 ldr r3,.L130+52
 3379 14fa 1A88     	 ldrh r2,[r3]
 3380 14fc BA23     	 mov r3,#186
 3381 14fe 1B01     	 lsl r3,r3,#4
 3382 1500 9A42     	 cmp r2,r3
 3383 1502 20D9     	 bls .L98
 715:../main.c     **** 												   {
 716:../main.c     **** 											        tester2 = writeOff_light_B5_EEprom();
 3384              	 .loc 5 716 0
 3385 1504 FFF7FEFF 	 bl writeOff_light_B5_EEprom
 3386 1508 031C     	 mov r3,r0
 3387 150a 9AB2     	 uxth r2,r3
 3388 150c A14B     	 ldr r3,.L130+56
 3389 150e 1A80     	 strh r2,[r3]
 717:../main.c     **** 													new_data_HalloBack();
 3390              	 .loc 5 717 0
 3391 1510 FFF7FEFF 	 bl new_data_HalloBack
 718:../main.c     **** 													new_data[6]='i';
 3392              	 .loc 5 718 0
 3393 1514 A04B     	 ldr r3,.L130+60
 3394 1516 6922     	 mov r2,#105
 3395 1518 9A71     	 strb r2,[r3,#6]
 719:../main.c     **** 													new_data[7]='n';
 3396              	 .loc 5 719 0
 3397 151a 9F4B     	 ldr r3,.L130+60
 3398 151c 6E22     	 mov r2,#110
 3399 151e DA71     	 strb r2,[r3,#7]
 720:../main.c     **** 													new_data[8]=0;
 3400              	 .loc 5 720 0
 3401 1520 9D4B     	 ldr r3,.L130+60
 3402 1522 0022     	 mov r2,#0
 3403 1524 1A72     	 strb r2,[r3,#8]
 721:../main.c     **** 													new_data[9]=tester2;
 3404              	 .loc 5 721 0
 3405 1526 9B4B     	 ldr r3,.L130+56
 3406 1528 1B88     	 ldrh r3,[r3]
 3407 152a DAB2     	 uxtb r2,r3
 3408 152c 9A4B     	 ldr r3,.L130+60
 3409 152e 5A72     	 strb r2,[r3,#9]
 722:../main.c     **** 													UART_Transmit(&UART_1, new_data,transmit_buf_size);
 3410              	 .loc 5 722 0
 3411 1530 9A4B     	 ldr r3,.L130+64
 3412 1532 1B78     	 ldrb r3,[r3]
 3413 1534 1C1C     	 mov r4,r3
 3414 1536 9A4A     	 ldr r2,.L130+68
 3415 1538 974B     	 ldr r3,.L130+60
 3416 153a 101C     	 mov r0,r2
 3417 153c 191C     	 mov r1,r3
 3418 153e 221C     	 mov r2,r4
 3419 1540 FFF7FEFF 	 bl UART_Transmit
 714:../main.c     **** 												   {
 3420              	 .loc 5 714 0
 3421 1544 36E0     	 b .L100
 3422              	.L98:
 723:../main.c     **** 												   }
 724:../main.c     **** 												    else {
 725:../main.c     **** 													new_data_HalloBack();
 3423              	 .loc 5 725 0
 3424 1546 FFF7FEFF 	 bl new_data_HalloBack
 726:../main.c     **** 													 new_data[6]='e';
 3425              	 .loc 5 726 0
 3426 154a 934B     	 ldr r3,.L130+60
 3427 154c 6522     	 mov r2,#101
 3428 154e 9A71     	 strb r2,[r3,#6]
 727:../main.c     **** 													 new_data[7]=27;
 3429              	 .loc 5 727 0
 3430 1550 914B     	 ldr r3,.L130+60
 3431 1552 1B22     	 mov r2,#27
 3432 1554 DA71     	 strb r2,[r3,#7]
 728:../main.c     **** 													 new_data[8]=0;
 3433              	 .loc 5 728 0
 3434 1556 904B     	 ldr r3,.L130+60
 3435 1558 0022     	 mov r2,#0
 3436 155a 1A72     	 strb r2,[r3,#8]
 729:../main.c     **** 													 new_data[9]=tester2;
 3437              	 .loc 5 729 0
 3438 155c 8D4B     	 ldr r3,.L130+56
 3439 155e 1B88     	 ldrh r3,[r3]
 3440 1560 DAB2     	 uxtb r2,r3
 3441 1562 8D4B     	 ldr r3,.L130+60
 3442 1564 5A72     	 strb r2,[r3,#9]
 730:../main.c     **** 													UART_Transmit(&UART_1, new_data,transmit_buf_size);
 3443              	 .loc 5 730 0
 3444 1566 8D4B     	 ldr r3,.L130+64
 3445 1568 1B78     	 ldrb r3,[r3]
 3446 156a 1C1C     	 mov r4,r3
 3447 156c 8C4A     	 ldr r2,.L130+68
 3448 156e 8A4B     	 ldr r3,.L130+60
 3449 1570 101C     	 mov r0,r2
 3450 1572 191C     	 mov r1,r3
 3451 1574 221C     	 mov r2,r4
 3452 1576 FFF7FEFF 	 bl UART_Transmit
 714:../main.c     **** 												   {
 3453              	 .loc 5 714 0
 3454 157a 1BE0     	 b .L100
 3455              	.L97:
 731:../main.c     **** 												    }
 732:../main.c     **** 												}
 733:../main.c     **** 												 else {
 734:../main.c     **** 												new_data_HalloBack();
 3456              	 .loc 5 734 0
 3457 157c FFF7FEFF 	 bl new_data_HalloBack
 735:../main.c     **** 												new_data[6]='e';
 3458              	 .loc 5 735 0
 3459 1580 854B     	 ldr r3,.L130+60
 3460 1582 6522     	 mov r2,#101
 3461 1584 9A71     	 strb r2,[r3,#6]
 736:../main.c     **** 												new_data[7]=28;
 3462              	 .loc 5 736 0
 3463 1586 844B     	 ldr r3,.L130+60
 3464 1588 1C22     	 mov r2,#28
 3465 158a DA71     	 strb r2,[r3,#7]
 737:../main.c     **** 												new_data[8]=0;
 3466              	 .loc 5 737 0
 3467 158c 824B     	 ldr r3,.L130+60
 3468 158e 0022     	 mov r2,#0
 3469 1590 1A72     	 strb r2,[r3,#8]
 738:../main.c     **** 												new_data[9]=tester2;
 3470              	 .loc 5 738 0
 3471 1592 804B     	 ldr r3,.L130+56
 3472 1594 1B88     	 ldrh r3,[r3]
 3473 1596 DAB2     	 uxtb r2,r3
 3474 1598 7F4B     	 ldr r3,.L130+60
 3475 159a 5A72     	 strb r2,[r3,#9]
 739:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 3476              	 .loc 5 739 0
 3477 159c 7F4B     	 ldr r3,.L130+64
 3478 159e 1B78     	 ldrb r3,[r3]
 3479 15a0 1C1C     	 mov r4,r3
 3480 15a2 7F4A     	 ldr r2,.L130+68
 3481 15a4 7C4B     	 ldr r3,.L130+60
 3482 15a6 101C     	 mov r0,r2
 3483 15a8 191C     	 mov r1,r3
 3484 15aa 221C     	 mov r2,r4
 3485 15ac FFF7FEFF 	 bl UART_Transmit
 740:../main.c     **** 												 }
 741:../main.c     **** 												break;
 3486              	 .loc 5 741 0
 3487 15b0 00F0ECFB 	 bl .L47
 3488              	.L100:
 3489              	 .loc 5 741 0 is_stmt 0 discriminator 11
 3490 15b4 00F0EAFB 	 bl .L47
 3491              	.L53:
 742:../main.c     **** 
 743:../main.c     **** 
 744:../main.c     **** 				case command_neuNodeConResi:
 745:../main.c     **** 												if (command_nr == 0x30 &&  Ser_NrH  == (ReadData[1] * 0x100 + ReadData[2]) && Ser_NrL  
 3492              	 .loc 5 745 0 is_stmt 1
 3493 15b8 7A4B     	 ldr r3,.L130+72
 3494 15ba 1B88     	 ldrh r3,[r3]
 3495 15bc 302B     	 cmp r3,#48
 3496 15be 41D1     	 bne .L101
 3497              	 .loc 5 745 0 is_stmt 0 discriminator 1
 3498 15c0 664B     	 ldr r3,.L130
 3499 15c2 1B88     	 ldrh r3,[r3]
 3500 15c4 191C     	 mov r1,r3
 3501 15c6 664B     	 ldr r3,.L130+4
 3502 15c8 5B78     	 ldrb r3,[r3,#1]
 3503 15ca 1B02     	 lsl r3,r3,#8
 3504 15cc 644A     	 ldr r2,.L130+4
 3505 15ce 9278     	 ldrb r2,[r2,#2]
 3506 15d0 9B18     	 add r3,r3,r2
 3507 15d2 9942     	 cmp r1,r3
 3508 15d4 36D1     	 bne .L101
 3509              	 .loc 5 745 0 discriminator 2
 3510 15d6 634B     	 ldr r3,.L130+8
 3511 15d8 1B88     	 ldrh r3,[r3]
 3512 15da 191C     	 mov r1,r3
 3513 15dc 604B     	 ldr r3,.L130+4
 3514 15de DB78     	 ldrb r3,[r3,#3]
 3515 15e0 1B02     	 lsl r3,r3,#8
 3516 15e2 5F4A     	 ldr r2,.L130+4
 3517 15e4 1279     	 ldrb r2,[r2,#4]
 3518 15e6 9B18     	 add r3,r3,r2
 3519 15e8 9942     	 cmp r1,r3
 3520 15ea 2BD1     	 bne .L101
 746:../main.c     **** 				                                { command_nr = command_nr + 0x17;
 3521              	 .loc 5 746 0 is_stmt 1
 3522 15ec 6D4B     	 ldr r3,.L130+72
 3523 15ee 1B88     	 ldrh r3,[r3]
 3524 15f0 1733     	 add r3,r3,#23
 3525 15f2 9AB2     	 uxth r2,r3
 3526 15f4 6B4B     	 ldr r3,.L130+72
 3527 15f6 1A80     	 strh r2,[r3]
 747:../main.c     **** 				                                node_id = node_id_neu;
 3528              	 .loc 5 747 0
 3529 15f8 6B4B     	 ldr r3,.L130+76
 3530 15fa 1A78     	 ldrb r2,[r3]
 3531 15fc 6B4B     	 ldr r3,.L130+80
 3532 15fe 1A70     	 strb r2,[r3]
 748:../main.c     **** 
 749:../main.c     **** 												new_data_HalloBack();
 3533              	 .loc 5 749 0
 3534 1600 FFF7FEFF 	 bl new_data_HalloBack
 750:../main.c     **** 												 new_data[6]='i';
 3535              	 .loc 5 750 0
 3536 1604 644B     	 ldr r3,.L130+60
 3537 1606 6922     	 mov r2,#105
 3538 1608 9A71     	 strb r2,[r3,#6]
 751:../main.c     **** 												 new_data[7]= command_nr;
 3539              	 .loc 5 751 0
 3540 160a 664B     	 ldr r3,.L130+72
 3541 160c 1B88     	 ldrh r3,[r3]
 3542 160e DAB2     	 uxtb r2,r3
 3543 1610 614B     	 ldr r3,.L130+60
 3544 1612 DA71     	 strb r2,[r3,#7]
 752:../main.c     **** 												 new_data[8]= Ser_NrL  / 0x100 ;
 3545              	 .loc 5 752 0
 3546 1614 534B     	 ldr r3,.L130+8
 3547 1616 1B88     	 ldrh r3,[r3]
 3548 1618 1B0A     	 lsr r3,r3,#8
 3549 161a 9BB2     	 uxth r3,r3
 3550 161c DAB2     	 uxtb r2,r3
 3551 161e 5E4B     	 ldr r3,.L130+60
 3552 1620 1A72     	 strb r2,[r3,#8]
 753:../main.c     **** 												 new_data[9]= Ser_NrL  & 0xff ;
 3553              	 .loc 5 753 0
 3554 1622 504B     	 ldr r3,.L130+8
 3555 1624 1B88     	 ldrh r3,[r3]
 3556 1626 DAB2     	 uxtb r2,r3
 3557 1628 5B4B     	 ldr r3,.L130+60
 3558 162a 5A72     	 strb r2,[r3,#9]
 754:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 3559              	 .loc 5 754 0
 3560 162c 5B4B     	 ldr r3,.L130+64
 3561 162e 1B78     	 ldrb r3,[r3]
 3562 1630 1C1C     	 mov r4,r3
 3563 1632 5B4A     	 ldr r2,.L130+68
 3564 1634 584B     	 ldr r3,.L130+60
 3565 1636 101C     	 mov r0,r2
 3566 1638 191C     	 mov r1,r3
 3567 163a 221C     	 mov r2,r4
 3568 163c FFF7FEFF 	 bl UART_Transmit
 755:../main.c     **** 				                                }
 756:../main.c     **** 												else
 757:../main.c     **** 												{
 758:../main.c     **** 												 new_data_HalloBack();
 759:../main.c     **** 												 new_data[6]='e';
 760:../main.c     **** 												 new_data[7]= command_nr;
 761:../main.c     **** 												 new_data[8]= Ser_NrL  / 0x100 ;
 762:../main.c     **** 												 new_data[9]= Ser_NrL  & 0xff ;
 763:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 764:../main.c     **** 												}
 765:../main.c     **** 											break;
 3569              	 .loc 5 765 0
 3570 1640 00F0A4FB 	 bl .L47
 3571              	.L101:
 758:../main.c     **** 												 new_data[6]='e';
 3572              	 .loc 5 758 0
 3573 1644 FFF7FEFF 	 bl new_data_HalloBack
 759:../main.c     **** 												 new_data[7]= command_nr;
 3574              	 .loc 5 759 0
 3575 1648 534B     	 ldr r3,.L130+60
 3576 164a 6522     	 mov r2,#101
 3577 164c 9A71     	 strb r2,[r3,#6]
 760:../main.c     **** 												 new_data[8]= Ser_NrL  / 0x100 ;
 3578              	 .loc 5 760 0
 3579 164e 554B     	 ldr r3,.L130+72
 3580 1650 1B88     	 ldrh r3,[r3]
 3581 1652 DAB2     	 uxtb r2,r3
 3582 1654 504B     	 ldr r3,.L130+60
 3583 1656 DA71     	 strb r2,[r3,#7]
 761:../main.c     **** 												 new_data[9]= Ser_NrL  & 0xff ;
 3584              	 .loc 5 761 0
 3585 1658 424B     	 ldr r3,.L130+8
 3586 165a 1B88     	 ldrh r3,[r3]
 3587 165c 1B0A     	 lsr r3,r3,#8
 3588 165e 9BB2     	 uxth r3,r3
 3589 1660 DAB2     	 uxtb r2,r3
 3590 1662 4D4B     	 ldr r3,.L130+60
 3591 1664 1A72     	 strb r2,[r3,#8]
 762:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 3592              	 .loc 5 762 0
 3593 1666 3F4B     	 ldr r3,.L130+8
 3594 1668 1B88     	 ldrh r3,[r3]
 3595 166a DAB2     	 uxtb r2,r3
 3596 166c 4A4B     	 ldr r3,.L130+60
 3597 166e 5A72     	 strb r2,[r3,#9]
 763:../main.c     **** 												}
 3598              	 .loc 5 763 0
 3599 1670 4A4B     	 ldr r3,.L130+64
 3600 1672 1B78     	 ldrb r3,[r3]
 3601 1674 1C1C     	 mov r4,r3
 3602 1676 4A4A     	 ldr r2,.L130+68
 3603 1678 474B     	 ldr r3,.L130+60
 3604 167a 101C     	 mov r0,r2
 3605 167c 191C     	 mov r1,r3
 3606 167e 221C     	 mov r2,r4
 3607 1680 FFF7FEFF 	 bl UART_Transmit
 3608              	 .loc 5 765 0
 3609 1684 82E3     	 b .L47
 3610              	.L54:
 766:../main.c     **** 				case command_neuSerNrConResi:
 767:../main.c     **** 												if (command_nr == 0x45 &&  Ser_NrH  == (ReadData[1] * 0x100 + ReadData[2]) && Ser_NrL  
 3611              	 .loc 5 767 0
 3612 1686 474B     	 ldr r3,.L130+72
 3613 1688 1B88     	 ldrh r3,[r3]
 3614 168a 452B     	 cmp r3,#69
 3615 168c 44D1     	 bne .L103
 3616              	 .loc 5 767 0 is_stmt 0 discriminator 1
 3617 168e 334B     	 ldr r3,.L130
 3618 1690 1B88     	 ldrh r3,[r3]
 3619 1692 191C     	 mov r1,r3
 3620 1694 324B     	 ldr r3,.L130+4
 3621 1696 5B78     	 ldrb r3,[r3,#1]
 3622 1698 1B02     	 lsl r3,r3,#8
 3623 169a 314A     	 ldr r2,.L130+4
 3624 169c 9278     	 ldrb r2,[r2,#2]
 3625 169e 9B18     	 add r3,r3,r2
 3626 16a0 9942     	 cmp r1,r3
 3627 16a2 39D1     	 bne .L103
 3628              	 .loc 5 767 0 discriminator 2
 3629 16a4 2F4B     	 ldr r3,.L130+8
 3630 16a6 1B88     	 ldrh r3,[r3]
 3631 16a8 191C     	 mov r1,r3
 3632 16aa 2D4B     	 ldr r3,.L130+4
 3633 16ac DB78     	 ldrb r3,[r3,#3]
 3634 16ae 1B02     	 lsl r3,r3,#8
 3635 16b0 2B4A     	 ldr r2,.L130+4
 3636 16b2 1279     	 ldrb r2,[r2,#4]
 3637 16b4 9B18     	 add r3,r3,r2
 3638 16b6 9942     	 cmp r1,r3
 3639 16b8 2ED1     	 bne .L103
 768:../main.c     **** 				                                { command_nr = command_nr + 0x21;
 3640              	 .loc 5 768 0 is_stmt 1
 3641 16ba 3A4B     	 ldr r3,.L130+72
 3642 16bc 1B88     	 ldrh r3,[r3]
 3643 16be 2133     	 add r3,r3,#33
 3644 16c0 9AB2     	 uxth r2,r3
 3645 16c2 384B     	 ldr r3,.L130+72
 3646 16c4 1A80     	 strh r2,[r3]
 769:../main.c     **** 				                                Ser_NrH=neu_Ser_NrH;
 3647              	 .loc 5 769 0
 3648 16c6 3A4B     	 ldr r3,.L130+84
 3649 16c8 1A88     	 ldrh r2,[r3]
 3650 16ca 244B     	 ldr r3,.L130
 3651 16cc 1A80     	 strh r2,[r3]
 770:../main.c     **** 				                                Ser_NrL=neu_Ser_NrL;
 3652              	 .loc 5 770 0
 3653 16ce 394B     	 ldr r3,.L130+88
 3654 16d0 1A88     	 ldrh r2,[r3]
 3655 16d2 244B     	 ldr r3,.L130+8
 3656 16d4 1A80     	 strh r2,[r3]
 771:../main.c     **** 
 772:../main.c     **** 												new_data_HalloBack();
 3657              	 .loc 5 772 0
 3658 16d6 FFF7FEFF 	 bl new_data_HalloBack
 773:../main.c     **** 												 new_data[6]='i';
 3659              	 .loc 5 773 0
 3660 16da 2F4B     	 ldr r3,.L130+60
 3661 16dc 6922     	 mov r2,#105
 3662 16de 9A71     	 strb r2,[r3,#6]
 774:../main.c     **** 												 new_data[7]= command_nr;
 3663              	 .loc 5 774 0
 3664 16e0 304B     	 ldr r3,.L130+72
 3665 16e2 1B88     	 ldrh r3,[r3]
 3666 16e4 DAB2     	 uxtb r2,r3
 3667 16e6 2C4B     	 ldr r3,.L130+60
 3668 16e8 DA71     	 strb r2,[r3,#7]
 775:../main.c     **** 												 new_data[8]= Ser_NrL  / 0x100 ;
 3669              	 .loc 5 775 0
 3670 16ea 1E4B     	 ldr r3,.L130+8
 3671 16ec 1B88     	 ldrh r3,[r3]
 3672 16ee 1B0A     	 lsr r3,r3,#8
 3673 16f0 9BB2     	 uxth r3,r3
 3674 16f2 DAB2     	 uxtb r2,r3
 3675 16f4 284B     	 ldr r3,.L130+60
 3676 16f6 1A72     	 strb r2,[r3,#8]
 776:../main.c     **** 												 new_data[9]= Ser_NrL  & 0xff ;
 3677              	 .loc 5 776 0
 3678 16f8 1A4B     	 ldr r3,.L130+8
 3679 16fa 1B88     	 ldrh r3,[r3]
 3680 16fc DAB2     	 uxtb r2,r3
 3681 16fe 264B     	 ldr r3,.L130+60
 3682 1700 5A72     	 strb r2,[r3,#9]
 777:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 3683              	 .loc 5 777 0
 3684 1702 264B     	 ldr r3,.L130+64
 3685 1704 1B78     	 ldrb r3,[r3]
 3686 1706 1C1C     	 mov r4,r3
 3687 1708 254A     	 ldr r2,.L130+68
 3688 170a 234B     	 ldr r3,.L130+60
 3689 170c 101C     	 mov r0,r2
 3690 170e 191C     	 mov r1,r3
 3691 1710 221C     	 mov r2,r4
 3692 1712 FFF7FEFF 	 bl UART_Transmit
 778:../main.c     **** 				                                }
 779:../main.c     **** 												else
 780:../main.c     **** 												{
 781:../main.c     **** 												 new_data_HalloBack();
 782:../main.c     **** 												 new_data[6]='e';
 783:../main.c     **** 												 new_data[7]= command_nr;
 784:../main.c     **** 												 new_data[8]= Ser_NrL  / 0x100 ;
 785:../main.c     **** 												 new_data[9]= Ser_NrL  & 0xff ;
 786:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 787:../main.c     **** 												}
 788:../main.c     **** 											break;
 3693              	 .loc 5 788 0
 3694 1716 39E3     	 b .L47
 3695              	.L103:
 781:../main.c     **** 												 new_data[6]='e';
 3696              	 .loc 5 781 0
 3697 1718 FFF7FEFF 	 bl new_data_HalloBack
 782:../main.c     **** 												 new_data[7]= command_nr;
 3698              	 .loc 5 782 0
 3699 171c 1E4B     	 ldr r3,.L130+60
 3700 171e 6522     	 mov r2,#101
 3701 1720 9A71     	 strb r2,[r3,#6]
 783:../main.c     **** 												 new_data[8]= Ser_NrL  / 0x100 ;
 3702              	 .loc 5 783 0
 3703 1722 204B     	 ldr r3,.L130+72
 3704 1724 1B88     	 ldrh r3,[r3]
 3705 1726 DAB2     	 uxtb r2,r3
 3706 1728 1B4B     	 ldr r3,.L130+60
 3707 172a DA71     	 strb r2,[r3,#7]
 784:../main.c     **** 												 new_data[9]= Ser_NrL  & 0xff ;
 3708              	 .loc 5 784 0
 3709 172c 0D4B     	 ldr r3,.L130+8
 3710 172e 1B88     	 ldrh r3,[r3]
 3711 1730 1B0A     	 lsr r3,r3,#8
 3712 1732 9BB2     	 uxth r3,r3
 3713 1734 DAB2     	 uxtb r2,r3
 3714 1736 184B     	 ldr r3,.L130+60
 3715 1738 1A72     	 strb r2,[r3,#8]
 785:../main.c     **** 												UART_Transmit(&UART_1, new_data,transmit_buf_size);
 3716              	 .loc 5 785 0
 3717 173a 0A4B     	 ldr r3,.L130+8
 3718 173c 1B88     	 ldrh r3,[r3]
 3719 173e DAB2     	 uxtb r2,r3
 3720 1740 154B     	 ldr r3,.L130+60
 3721 1742 5A72     	 strb r2,[r3,#9]
 786:../main.c     **** 												}
 3722              	 .loc 5 786 0
 3723 1744 154B     	 ldr r3,.L130+64
 3724 1746 1B78     	 ldrb r3,[r3]
 3725 1748 1C1C     	 mov r4,r3
 3726 174a 154A     	 ldr r2,.L130+68
 3727 174c 124B     	 ldr r3,.L130+60
 3728 174e 101C     	 mov r0,r2
 3729 1750 191C     	 mov r1,r3
 3730 1752 221C     	 mov r2,r4
 3731 1754 FFF7FEFF 	 bl UART_Transmit
 3732              	 .loc 5 788 0
 3733 1758 18E3     	 b .L47
 3734              	.L131:
 3735 175a C046     	 .align 2
 3736              	.L130:
 3737 175c 00000000 	 .word Ser_NrH
 3738 1760 00000000 	 .word ReadData
 3739 1764 00000000 	 .word Ser_NrL
 3740 1768 00000000 	 .word RegOnOff
 3741 176c 00000000 	 .word ReadBuffer2
 3742 1770 00000000 	 .word RegOnOff2
 3743 1774 00000000 	 .word Reserve_2
 3744 1778 00000000 	 .word dimOff_Ww
 3745 177c 00000000 	 .word dimOff_Cw
 3746 1780 00000000 	 .word dimNorm1_Ww
 3747 1784 00000000 	 .word dimNorm1_Cw
 3748 1788 00000000 	 .word dimNorm2_Ww
 3749 178c 00000000 	 .word dimNorm2_Cw
 3750 1790 00000000 	 .word resultB2
 3751 1794 00000000 	 .word tester2
 3752 1798 00000000 	 .word new_data
 3753 179c 00000000 	 .word transmit_buf_size
 3754 17a0 00000000 	 .word UART_1
 3755 17a4 00000000 	 .word command_nr
 3756 17a8 00000000 	 .word node_id_neu
 3757 17ac 00000000 	 .word node_id
 3758 17b0 00000000 	 .word neu_Ser_NrH
 3759 17b4 00000000 	 .word neu_Ser_NrL
 3760              	.L49:
 789:../main.c     **** 				case command_eprommInitResi :
 790:../main.c     **** 										if (node_id_neu == 254 &&  Ser_NrH == 0x7b7a && Ser_NrH  == (ReadData[1] * 0x100 + ReadDa
 3761              	 .loc 5 790 0
 3762 17b8 DA4B     	 ldr r3,.L132
 3763 17ba 1B78     	 ldrb r3,[r3]
 3764 17bc FE2B     	 cmp r3,#254
 3765 17be 00D0     	 beq .LCB3176
 3766 17c0 C9E2     	 b .L105
 3767              	.LCB3176:
 3768              	 .loc 5 790 0 is_stmt 0 discriminator 1
 3769 17c2 D94B     	 ldr r3,.L132+4
 3770 17c4 1B88     	 ldrh r3,[r3]
 3771 17c6 D94A     	 ldr r2,.L132+8
 3772 17c8 9342     	 cmp r3,r2
 3773 17ca 00D0     	 beq .LCB3181
 3774 17cc C3E2     	 b .L105
 3775              	.LCB3181:
 3776              	 .loc 5 790 0 discriminator 2
 3777 17ce D64B     	 ldr r3,.L132+4
 3778 17d0 1B88     	 ldrh r3,[r3]
 3779 17d2 191C     	 mov r1,r3
 3780 17d4 D64B     	 ldr r3,.L132+12
 3781 17d6 5B78     	 ldrb r3,[r3,#1]
 3782 17d8 1B02     	 lsl r3,r3,#8
 3783 17da D54A     	 ldr r2,.L132+12
 3784 17dc 9278     	 ldrb r2,[r2,#2]
 3785 17de 9B18     	 add r3,r3,r2
 3786 17e0 9942     	 cmp r1,r3
 3787 17e2 00D0     	 beq .LCB3192
 3788 17e4 B7E2     	 b .L105
 3789              	.LCB3192:
 3790              	 .loc 5 790 0 discriminator 3
 3791 17e6 D34B     	 ldr r3,.L132+16
 3792 17e8 1B88     	 ldrh r3,[r3]
 3793 17ea D34A     	 ldr r2,.L132+20
 3794 17ec 9342     	 cmp r3,r2
 3795 17ee 00D0     	 beq .LCB3197
 3796 17f0 B1E2     	 b .L105
 3797              	.LCB3197:
 3798              	 .loc 5 790 0 discriminator 4
 3799 17f2 D04B     	 ldr r3,.L132+16
 3800 17f4 1B88     	 ldrh r3,[r3]
 3801 17f6 191C     	 mov r1,r3
 3802 17f8 CD4B     	 ldr r3,.L132+12
 3803 17fa DB78     	 ldrb r3,[r3,#3]
 3804 17fc 1B02     	 lsl r3,r3,#8
 3805 17fe CC4A     	 ldr r2,.L132+12
 3806 1800 1279     	 ldrb r2,[r2,#4]
 3807 1802 9B18     	 add r3,r3,r2
 3808 1804 9942     	 cmp r1,r3
 3809 1806 00D0     	 beq .LCB3208
 3810 1808 A5E2     	 b .L105
 3811              	.LCB3208:
 791:../main.c     **** 										{
 792:../main.c     **** 											 if(Dstatus == DAVE_STATUS_SUCCESS)
 3812              	 .loc 5 792 0 is_stmt 1
 3813 180a CC4B     	 ldr r3,.L132+24
 3814 180c 1B78     	 ldrb r3,[r3]
 3815 180e 002B     	 cmp r3,#0
 3816 1810 00D0     	 beq .LCB3212
 3817 1812 86E2     	 b .L106
 3818              	.LCB3212:
 793:../main.c     **** 											 {
 794:../main.c     **** 												 if (resultB2 > min_EEP_Voltage_Uin)
 3819              	 .loc 5 794 0
 3820 1814 CA4B     	 ldr r3,.L132+28
 3821 1816 1A88     	 ldrh r2,[r3]
 3822 1818 BA23     	 mov r3,#186
 3823 181a 1B01     	 lsl r3,r3,#4
 3824 181c 9A42     	 cmp r2,r3
 3825 181e 00D8     	 bhi .LCB3218
 3826 1820 66E2     	 b .L107
 3827              	.LCB3218:
 795:../main.c     **** 												 {
 796:../main.c     **** 											//    	XMC_FLASH_ErasePages( (uint32_t*)E_EEPROM_XMC1_FLASH_BANK0_BASE,16);
 797:../main.c     **** 													clearEpromBuffer();
 3828              	 .loc 5 797 0
 3829 1822 FFF7FEFF 	 bl clearEpromBuffer
 798:../main.c     **** 													sysiniValueB1();
 3830              	 .loc 5 798 0
 3831 1826 FFF7FEFF 	 bl sysiniValueB1
 799:../main.c     **** 
 800:../main.c     **** 													 ReadBuffer1[0]= 	Ser_NrH  / 0x100; //highbyte
 3832              	 .loc 5 800 0
 3833 182a BF4B     	 ldr r3,.L132+4
 3834 182c 1B88     	 ldrh r3,[r3]
 3835 182e 1B0A     	 lsr r3,r3,#8
 3836 1830 9BB2     	 uxth r3,r3
 3837 1832 DAB2     	 uxtb r2,r3
 3838 1834 C34B     	 ldr r3,.L132+32
 3839 1836 1A70     	 strb r2,[r3]
 801:../main.c     **** 													 ReadBuffer1[1]= 	Ser_NrH  & 0xff; //lowbyte
 3840              	 .loc 5 801 0
 3841 1838 BB4B     	 ldr r3,.L132+4
 3842 183a 1B88     	 ldrh r3,[r3]
 3843 183c DAB2     	 uxtb r2,r3
 3844 183e C14B     	 ldr r3,.L132+32
 3845 1840 5A70     	 strb r2,[r3,#1]
 802:../main.c     **** 													 ReadBuffer1[2]= 	Ser_NrL  / 0x100; //highbyte
 3846              	 .loc 5 802 0
 3847 1842 BC4B     	 ldr r3,.L132+16
 3848 1844 1B88     	 ldrh r3,[r3]
 3849 1846 1B0A     	 lsr r3,r3,#8
 3850 1848 9BB2     	 uxth r3,r3
 3851 184a DAB2     	 uxtb r2,r3
 3852 184c BD4B     	 ldr r3,.L132+32
 3853 184e 9A70     	 strb r2,[r3,#2]
 803:../main.c     **** 													 ReadBuffer1[3]= 	Ser_NrL  & 0xff; //lowbyte
 3854              	 .loc 5 803 0
 3855 1850 B84B     	 ldr r3,.L132+16
 3856 1852 1B88     	 ldrh r3,[r3]
 3857 1854 DAB2     	 uxtb r2,r3
 3858 1856 BB4B     	 ldr r3,.L132+32
 3859 1858 DA70     	 strb r2,[r3,#3]
 804:../main.c     **** 													 ReadBuffer1[4]= 	Hard_Vers  / 0x100; //highbyte
 3860              	 .loc 5 804 0
 3861 185a BB4B     	 ldr r3,.L132+36
 3862 185c 1B88     	 ldrh r3,[r3]
 3863 185e 1B0A     	 lsr r3,r3,#8
 3864 1860 9BB2     	 uxth r3,r3
 3865 1862 DAB2     	 uxtb r2,r3
 3866 1864 B74B     	 ldr r3,.L132+32
 3867 1866 1A71     	 strb r2,[r3,#4]
 805:../main.c     **** 													 ReadBuffer1[5]= 	Hard_Vers  & 0xff; //lowbyte
 3868              	 .loc 5 805 0
 3869 1868 B74B     	 ldr r3,.L132+36
 3870 186a 1B88     	 ldrh r3,[r3]
 3871 186c DAB2     	 uxtb r2,r3
 3872 186e B54B     	 ldr r3,.L132+32
 3873 1870 5A71     	 strb r2,[r3,#5]
 806:../main.c     **** 													 ReadBuffer1[6]= 	Soft_Vers  / 0x100; //highbyte
 3874              	 .loc 5 806 0
 3875 1872 B64B     	 ldr r3,.L132+40
 3876 1874 1B88     	 ldrh r3,[r3]
 3877 1876 1B0A     	 lsr r3,r3,#8
 3878 1878 9BB2     	 uxth r3,r3
 3879 187a DAB2     	 uxtb r2,r3
 3880 187c B14B     	 ldr r3,.L132+32
 3881 187e 9A71     	 strb r2,[r3,#6]
 807:../main.c     **** 													 ReadBuffer1[7]= 	Soft_Vers  & 0xff; //lowbyte
 3882              	 .loc 5 807 0
 3883 1880 B24B     	 ldr r3,.L132+40
 3884 1882 1B88     	 ldrh r3,[r3]
 3885 1884 DAB2     	 uxtb r2,r3
 3886 1886 AF4B     	 ldr r3,.L132+32
 3887 1888 DA71     	 strb r2,[r3,#7]
 808:../main.c     **** 													 ReadBuffer1[8]= 	GEH_Vers  / 0x100; //highbyte
 3888              	 .loc 5 808 0
 3889 188a B14B     	 ldr r3,.L132+44
 3890 188c 1B88     	 ldrh r3,[r3]
 3891 188e 1B0A     	 lsr r3,r3,#8
 3892 1890 9BB2     	 uxth r3,r3
 3893 1892 DAB2     	 uxtb r2,r3
 3894 1894 AB4B     	 ldr r3,.L132+32
 3895 1896 1A72     	 strb r2,[r3,#8]
 809:../main.c     **** 													 ReadBuffer1[9]= 	GEH_Vers  & 0xff; //lowbyte
 3896              	 .loc 5 809 0
 3897 1898 AD4B     	 ldr r3,.L132+44
 3898 189a 1B88     	 ldrh r3,[r3]
 3899 189c DAB2     	 uxtb r2,r3
 3900 189e A94B     	 ldr r3,.L132+32
 3901 18a0 5A72     	 strb r2,[r3,#9]
 810:../main.c     **** 													 ReadBuffer1[10]= 	Mon_Vers  / 0x100; //highbyte
 3902              	 .loc 5 810 0
 3903 18a2 AC4B     	 ldr r3,.L132+48
 3904 18a4 1B88     	 ldrh r3,[r3]
 3905 18a6 1B0A     	 lsr r3,r3,#8
 3906 18a8 9BB2     	 uxth r3,r3
 3907 18aa DAB2     	 uxtb r2,r3
 3908 18ac A54B     	 ldr r3,.L132+32
 3909 18ae 9A72     	 strb r2,[r3,#10]
 811:../main.c     **** 													 ReadBuffer1[11]= 	Mon_Vers  & 0xff; //lowbyte
 3910              	 .loc 5 811 0
 3911 18b0 A84B     	 ldr r3,.L132+48
 3912 18b2 1B88     	 ldrh r3,[r3]
 3913 18b4 DAB2     	 uxtb r2,r3
 3914 18b6 A34B     	 ldr r3,.L132+32
 3915 18b8 DA72     	 strb r2,[r3,#11]
 812:../main.c     **** 													 ReadBuffer1[12]= 	LED_WW_Vers  / 0x100; //highbyte
 3916              	 .loc 5 812 0
 3917 18ba A74B     	 ldr r3,.L132+52
 3918 18bc 1B88     	 ldrh r3,[r3]
 3919 18be 1B0A     	 lsr r3,r3,#8
 3920 18c0 9BB2     	 uxth r3,r3
 3921 18c2 DAB2     	 uxtb r2,r3
 3922 18c4 9F4B     	 ldr r3,.L132+32
 3923 18c6 1A73     	 strb r2,[r3,#12]
 813:../main.c     **** 													 ReadBuffer1[13]= 	LED_WW_Vers  & 0xff; //lowbyte
 3924              	 .loc 5 813 0
 3925 18c8 A34B     	 ldr r3,.L132+52
 3926 18ca 1B88     	 ldrh r3,[r3]
 3927 18cc DAB2     	 uxtb r2,r3
 3928 18ce 9D4B     	 ldr r3,.L132+32
 3929 18d0 5A73     	 strb r2,[r3,#13]
 814:../main.c     **** 													 ReadBuffer1[14]= 	LED_CW_Vers  / 0x100; //highbyte
 3930              	 .loc 5 814 0
 3931 18d2 A24B     	 ldr r3,.L132+56
 3932 18d4 1B88     	 ldrh r3,[r3]
 3933 18d6 1B0A     	 lsr r3,r3,#8
 3934 18d8 9BB2     	 uxth r3,r3
 3935 18da DAB2     	 uxtb r2,r3
 3936 18dc 994B     	 ldr r3,.L132+32
 3937 18de 9A73     	 strb r2,[r3,#14]
 815:../main.c     **** 													 ReadBuffer1[15]= 	LED_CW_Vers  & 0xff; //lowbyte
 3938              	 .loc 5 815 0
 3939 18e0 9E4B     	 ldr r3,.L132+56
 3940 18e2 1B88     	 ldrh r3,[r3]
 3941 18e4 DAB2     	 uxtb r2,r3
 3942 18e6 974B     	 ldr r3,.L132+32
 3943 18e8 DA73     	 strb r2,[r3,#15]
 816:../main.c     **** 
 817:../main.c     **** 													 if (resultB2 > min_EEP_Voltage_Uin)
 3944              	 .loc 5 817 0
 3945 18ea 954B     	 ldr r3,.L132+28
 3946 18ec 1A88     	 ldrh r2,[r3]
 3947 18ee BA23     	 mov r3,#186
 3948 18f0 1B01     	 lsl r3,r3,#4
 3949 18f2 9A42     	 cmp r2,r3
 3950 18f4 05D9     	 bls .L108
 818:../main.c     **** 													 {	tester1 = writeSernr_B1_EEprom();
 3951              	 .loc 5 818 0
 3952 18f6 FFF7FEFF 	 bl writeSernr_B1_EEprom
 3953 18fa 031C     	 mov r3,r0
 3954 18fc 9AB2     	 uxth r2,r3
 3955 18fe 984B     	 ldr r3,.L132+60
 3956 1900 1A80     	 strh r2,[r3]
 3957              	.L108:
 819:../main.c     **** 													 }
 820:../main.c     **** 														sysiniValueB2();
 3958              	 .loc 5 820 0
 3959 1902 FFF7FEFF 	 bl sysiniValueB2
 821:../main.c     **** 													 ReadBuffer2[0]= 	node_id_alt; //highbyte
 3960              	 .loc 5 821 0
 3961 1906 974B     	 ldr r3,.L132+64
 3962 1908 1A78     	 ldrb r2,[r3]
 3963 190a 974B     	 ldr r3,.L132+68
 3964 190c 1A70     	 strb r2,[r3]
 822:../main.c     **** 													 ReadBuffer2[1]= 	node_id; //lowbyte
 3965              	 .loc 5 822 0
 3966 190e 974B     	 ldr r3,.L132+72
 3967 1910 1A78     	 ldrb r2,[r3]
 3968 1912 954B     	 ldr r3,.L132+68
 3969 1914 5A70     	 strb r2,[r3,#1]
 823:../main.c     **** 													 ReadBuffer2[2]= 	node_id_16bit  / 0x100; //highbyte
 3970              	 .loc 5 823 0
 3971 1916 964B     	 ldr r3,.L132+76
 3972 1918 1B88     	 ldrh r3,[r3]
 3973 191a 1B0A     	 lsr r3,r3,#8
 3974 191c 9BB2     	 uxth r3,r3
 3975 191e DAB2     	 uxtb r2,r3
 3976 1920 914B     	 ldr r3,.L132+68
 3977 1922 9A70     	 strb r2,[r3,#2]
 824:../main.c     **** 													 ReadBuffer2[3]= 	node_id_16bit   & 0xff; //highbyte
 3978              	 .loc 5 824 0
 3979 1924 924B     	 ldr r3,.L132+76
 3980 1926 1B88     	 ldrh r3,[r3]
 3981 1928 DAB2     	 uxtb r2,r3
 3982 192a 8F4B     	 ldr r3,.L132+68
 3983 192c DA70     	 strb r2,[r3,#3]
 825:../main.c     **** 													 ReadBuffer2[4]= 	val_Pow_Nom  / 0x100; //highbyte
 3984              	 .loc 5 825 0
 3985 192e 914B     	 ldr r3,.L132+80
 3986 1930 1B88     	 ldrh r3,[r3]
 3987 1932 1B0A     	 lsr r3,r3,#8
 3988 1934 9BB2     	 uxth r3,r3
 3989 1936 DAB2     	 uxtb r2,r3
 3990 1938 8B4B     	 ldr r3,.L132+68
 3991 193a 1A71     	 strb r2,[r3,#4]
 826:../main.c     **** 													 ReadBuffer2[5]= 	val_Pow_Nom  & 0xff; //lowbyte
 3992              	 .loc 5 826 0
 3993 193c 8D4B     	 ldr r3,.L132+80
 3994 193e 1B88     	 ldrh r3,[r3]
 3995 1940 DAB2     	 uxtb r2,r3
 3996 1942 894B     	 ldr r3,.L132+68
 3997 1944 5A71     	 strb r2,[r3,#5]
 827:../main.c     **** 													 ReadBuffer2[6]= 	val_Pow_max  / 0x100; //highbyte
 3998              	 .loc 5 827 0
 3999 1946 8C4B     	 ldr r3,.L132+84
 4000 1948 1B88     	 ldrh r3,[r3]
 4001 194a 1B0A     	 lsr r3,r3,#8
 4002 194c 9BB2     	 uxth r3,r3
 4003 194e DAB2     	 uxtb r2,r3
 4004 1950 854B     	 ldr r3,.L132+68
 4005 1952 9A71     	 strb r2,[r3,#6]
 828:../main.c     **** 													 ReadBuffer2[7]= 	val_Pow_max  & 0xff; //lowbyte
 4006              	 .loc 5 828 0
 4007 1954 884B     	 ldr r3,.L132+84
 4008 1956 1B88     	 ldrh r3,[r3]
 4009 1958 DAB2     	 uxtb r2,r3
 4010 195a 834B     	 ldr r3,.L132+68
 4011 195c DA71     	 strb r2,[r3,#7]
 829:../main.c     **** 													 ReadBuffer2[8]= 	val_Spannung_min / 0x100; //highbyte
 4012              	 .loc 5 829 0
 4013 195e 874B     	 ldr r3,.L132+88
 4014 1960 1B88     	 ldrh r3,[r3]
 4015 1962 1B0A     	 lsr r3,r3,#8
 4016 1964 9BB2     	 uxth r3,r3
 4017 1966 DAB2     	 uxtb r2,r3
 4018 1968 7F4B     	 ldr r3,.L132+68
 4019 196a 1A72     	 strb r2,[r3,#8]
 830:../main.c     **** 													 ReadBuffer2[9]= 	val_Spannung_min  & 0xff; //lowbyte
 4020              	 .loc 5 830 0
 4021 196c 834B     	 ldr r3,.L132+88
 4022 196e 1B88     	 ldrh r3,[r3]
 4023 1970 DAB2     	 uxtb r2,r3
 4024 1972 7D4B     	 ldr r3,.L132+68
 4025 1974 5A72     	 strb r2,[r3,#9]
 831:../main.c     **** 													 ReadBuffer2[10]= 	val_Spannung_max  / 0x100; //highbyte
 4026              	 .loc 5 831 0
 4027 1976 824B     	 ldr r3,.L132+92
 4028 1978 1B88     	 ldrh r3,[r3]
 4029 197a 1B0A     	 lsr r3,r3,#8
 4030 197c 9BB2     	 uxth r3,r3
 4031 197e DAB2     	 uxtb r2,r3
 4032 1980 794B     	 ldr r3,.L132+68
 4033 1982 9A72     	 strb r2,[r3,#10]
 832:../main.c     **** 													 ReadBuffer2[11]= 	val_Spannung_max  & 0xff; //lowbyte
 4034              	 .loc 5 832 0
 4035 1984 7E4B     	 ldr r3,.L132+92
 4036 1986 1B88     	 ldrh r3,[r3]
 4037 1988 DAB2     	 uxtb r2,r3
 4038 198a 774B     	 ldr r3,.L132+68
 4039 198c DA72     	 strb r2,[r3,#11]
 833:../main.c     **** 													 ReadBuffer2[12]= 	led_grupp  / 0x100; //highbyte
 4040              	 .loc 5 833 0
 4041 198e 7D4B     	 ldr r3,.L132+96
 4042 1990 1B88     	 ldrh r3,[r3]
 4043 1992 1B0A     	 lsr r3,r3,#8
 4044 1994 9BB2     	 uxth r3,r3
 4045 1996 DAB2     	 uxtb r2,r3
 4046 1998 734B     	 ldr r3,.L132+68
 4047 199a 1A73     	 strb r2,[r3,#12]
 834:../main.c     **** 													 ReadBuffer2[13]= 	led_grupp  & 0xff; //lowbyte
 4048              	 .loc 5 834 0
 4049 199c 794B     	 ldr r3,.L132+96
 4050 199e 1B88     	 ldrh r3,[r3]
 4051 19a0 DAB2     	 uxtb r2,r3
 4052 19a2 714B     	 ldr r3,.L132+68
 4053 19a4 5A73     	 strb r2,[r3,#13]
 835:../main.c     **** 													 ReadBuffer2[14]= 	led_Strom  / 0x100; //highbyte
 4054              	 .loc 5 835 0
 4055 19a6 784B     	 ldr r3,.L132+100
 4056 19a8 1B88     	 ldrh r3,[r3]
 4057 19aa 1B0A     	 lsr r3,r3,#8
 4058 19ac 9BB2     	 uxth r3,r3
 4059 19ae DAB2     	 uxtb r2,r3
 4060 19b0 6D4B     	 ldr r3,.L132+68
 4061 19b2 9A73     	 strb r2,[r3,#14]
 836:../main.c     **** 													 ReadBuffer2[15]= 	led_Strom  & 0xff; //lowbyte
 4062              	 .loc 5 836 0
 4063 19b4 744B     	 ldr r3,.L132+100
 4064 19b6 1B88     	 ldrh r3,[r3]
 4065 19b8 DAB2     	 uxtb r2,r3
 4066 19ba 6B4B     	 ldr r3,.L132+68
 4067 19bc DA73     	 strb r2,[r3,#15]
 837:../main.c     **** 
 838:../main.c     **** 													 if (resultB2 > min_EEP_Voltage_Uin)
 4068              	 .loc 5 838 0
 4069 19be 604B     	 ldr r3,.L132+28
 4070 19c0 1A88     	 ldrh r2,[r3]
 4071 19c2 BA23     	 mov r3,#186
 4072 19c4 1B01     	 lsl r3,r3,#4
 4073 19c6 9A42     	 cmp r2,r3
 4074 19c8 05D9     	 bls .L109
 839:../main.c     **** 													 {
 840:../main.c     **** 													 tester2 = writeNodeid_B2_EEprom();
 4075              	 .loc 5 840 0
 4076 19ca FFF7FEFF 	 bl writeNodeid_B2_EEprom
 4077 19ce 031C     	 mov r3,r0
 4078 19d0 9AB2     	 uxth r2,r3
 4079 19d2 6E4B     	 ldr r3,.L132+104
 4080 19d4 1A80     	 strh r2,[r3]
 4081              	.L109:
 841:../main.c     **** 													 }
 842:../main.c     **** 														sysiniValueB4();
 4082              	 .loc 5 842 0
 4083 19d6 FFF7FEFF 	 bl sysiniValueB4
 843:../main.c     **** 													ReadBuffer2[0]= 	Dimm_Gamma; //highbyte
 4084              	 .loc 5 843 0
 4085 19da 6D4B     	 ldr r3,.L132+108
 4086 19dc 1A78     	 ldrb r2,[r3]
 4087 19de 624B     	 ldr r3,.L132+68
 4088 19e0 1A70     	 strb r2,[r3]
 844:../main.c     **** 													ReadBuffer2[1]= 	Dimm_Stufen; //lowbyte
 4089              	 .loc 5 844 0
 4090 19e2 6C4B     	 ldr r3,.L132+112
 4091 19e4 1A78     	 ldrb r2,[r3]
 4092 19e6 604B     	 ldr r3,.L132+68
 4093 19e8 5A70     	 strb r2,[r3,#1]
 845:../main.c     **** 													ReadBuffer2[2]= 	Dimm_StufenGR  ; //highbyte
 4094              	 .loc 5 845 0
 4095 19ea 6B4B     	 ldr r3,.L132+116
 4096 19ec 1A78     	 ldrb r2,[r3]
 4097 19ee 5E4B     	 ldr r3,.L132+68
 4098 19f0 9A70     	 strb r2,[r3,#2]
 846:../main.c     **** 													ReadBuffer2[3]= 	Dimm_Valu   ; //highbyte
 4099              	 .loc 5 846 0
 4100 19f2 6A4B     	 ldr r3,.L132+120
 4101 19f4 1A78     	 ldrb r2,[r3]
 4102 19f6 5C4B     	 ldr r3,.L132+68
 4103 19f8 DA70     	 strb r2,[r3,#3]
 847:../main.c     **** 													ReadBuffer2[4]= 	Smooth_Value  / 0x100; //highbyte
 4104              	 .loc 5 847 0
 4105 19fa 694B     	 ldr r3,.L132+124
 4106 19fc 1B88     	 ldrh r3,[r3]
 4107 19fe 1B0A     	 lsr r3,r3,#8
 4108 1a00 9BB2     	 uxth r3,r3
 4109 1a02 DAB2     	 uxtb r2,r3
 4110 1a04 584B     	 ldr r3,.L132+68
 4111 1a06 1A71     	 strb r2,[r3,#4]
 848:../main.c     **** 													ReadBuffer2[5]= 	Smooth_Value  & 0xff; //lowbyte
 4112              	 .loc 5 848 0
 4113 1a08 654B     	 ldr r3,.L132+124
 4114 1a0a 1B88     	 ldrh r3,[r3]
 4115 1a0c DAB2     	 uxtb r2,r3
 4116 1a0e 564B     	 ldr r3,.L132+68
 4117 1a10 5A71     	 strb r2,[r3,#5]
 849:../main.c     **** 													ReadBuffer2[6]= 	linearwalk_gen  / 0x100; //highbyte
 4118              	 .loc 5 849 0
 4119 1a12 644B     	 ldr r3,.L132+128
 4120 1a14 1B88     	 ldrh r3,[r3]
 4121 1a16 1B0A     	 lsr r3,r3,#8
 4122 1a18 9BB2     	 uxth r3,r3
 4123 1a1a DAB2     	 uxtb r2,r3
 4124 1a1c 524B     	 ldr r3,.L132+68
 4125 1a1e 9A71     	 strb r2,[r3,#6]
 850:../main.c     **** 													ReadBuffer2[7]= 	linearwalk_gen  & 0xff; //lowbyte
 4126              	 .loc 5 850 0
 4127 1a20 604B     	 ldr r3,.L132+128
 4128 1a22 1B88     	 ldrh r3,[r3]
 4129 1a24 DAB2     	 uxtb r2,r3
 4130 1a26 504B     	 ldr r3,.L132+68
 4131 1a28 DA71     	 strb r2,[r3,#7]
 851:../main.c     **** 													ReadBuffer2[8]= 	Farbe_wwcw_Quot_gen / 0x100; //highbyte
 4132              	 .loc 5 851 0
 4133 1a2a 5F4B     	 ldr r3,.L132+132
 4134 1a2c 1B88     	 ldrh r3,[r3]
 4135 1a2e 1B0A     	 lsr r3,r3,#8
 4136 1a30 9BB2     	 uxth r3,r3
 4137 1a32 DAB2     	 uxtb r2,r3
 4138 1a34 4C4B     	 ldr r3,.L132+68
 4139 1a36 1A72     	 strb r2,[r3,#8]
 852:../main.c     **** 													ReadBuffer2[9]= 	Farbe_wwcw_Quot_gen  & 0xff; //lowbyte
 4140              	 .loc 5 852 0
 4141 1a38 5B4B     	 ldr r3,.L132+132
 4142 1a3a 1B88     	 ldrh r3,[r3]
 4143 1a3c DAB2     	 uxtb r2,r3
 4144 1a3e 4A4B     	 ldr r3,.L132+68
 4145 1a40 5A72     	 strb r2,[r3,#9]
 853:../main.c     **** 													ReadBuffer2[10]= 	Reserve_1  / 0x100; //highbyte
 4146              	 .loc 5 853 0
 4147 1a42 5A4B     	 ldr r3,.L132+136
 4148 1a44 1B88     	 ldrh r3,[r3]
 4149 1a46 1B0A     	 lsr r3,r3,#8
 4150 1a48 9BB2     	 uxth r3,r3
 4151 1a4a DAB2     	 uxtb r2,r3
 4152 1a4c 464B     	 ldr r3,.L132+68
 4153 1a4e 9A72     	 strb r2,[r3,#10]
 854:../main.c     **** 													ReadBuffer2[11]= 	Reserve_1  & 0xff; //lowbyte
 4154              	 .loc 5 854 0
 4155 1a50 564B     	 ldr r3,.L132+136
 4156 1a52 1B88     	 ldrh r3,[r3]
 4157 1a54 DAB2     	 uxtb r2,r3
 4158 1a56 444B     	 ldr r3,.L132+68
 4159 1a58 DA72     	 strb r2,[r3,#11]
 855:../main.c     **** 													ReadBuffer2[12]= 	Dimm_Max_WW  / 0x100; //highbyte
 4160              	 .loc 5 855 0
 4161 1a5a 554B     	 ldr r3,.L132+140
 4162 1a5c 1B88     	 ldrh r3,[r3]
 4163 1a5e 1B0A     	 lsr r3,r3,#8
 4164 1a60 9BB2     	 uxth r3,r3
 4165 1a62 DAB2     	 uxtb r2,r3
 4166 1a64 404B     	 ldr r3,.L132+68
 4167 1a66 1A73     	 strb r2,[r3,#12]
 856:../main.c     **** 													ReadBuffer2[13]= 	Dimm_Max_WW  & 0xff; //lowbyte
 4168              	 .loc 5 856 0
 4169 1a68 514B     	 ldr r3,.L132+140
 4170 1a6a 1B88     	 ldrh r3,[r3]
 4171 1a6c DAB2     	 uxtb r2,r3
 4172 1a6e 3E4B     	 ldr r3,.L132+68
 4173 1a70 5A73     	 strb r2,[r3,#13]
 857:../main.c     **** 													ReadBuffer2[14]= 	Dimm_Max_CW  / 0x100; //highbyte
 4174              	 .loc 5 857 0
 4175 1a72 504B     	 ldr r3,.L132+144
 4176 1a74 1B88     	 ldrh r3,[r3]
 4177 1a76 1B0A     	 lsr r3,r3,#8
 4178 1a78 9BB2     	 uxth r3,r3
 4179 1a7a DAB2     	 uxtb r2,r3
 4180 1a7c 3A4B     	 ldr r3,.L132+68
 4181 1a7e 9A73     	 strb r2,[r3,#14]
 858:../main.c     **** 													ReadBuffer2[15]= 	Dimm_Max_CW & 0xff; //lowbyte
 4182              	 .loc 5 858 0
 4183 1a80 4C4B     	 ldr r3,.L132+144
 4184 1a82 1B88     	 ldrh r3,[r3]
 4185 1a84 DAB2     	 uxtb r2,r3
 4186 1a86 384B     	 ldr r3,.L132+68
 4187 1a88 DA73     	 strb r2,[r3,#15]
 859:../main.c     **** 
 860:../main.c     **** 											       if (resultB2 > min_EEP_Voltage_Uin)
 4188              	 .loc 5 860 0
 4189 1a8a 2D4B     	 ldr r3,.L132+28
 4190 1a8c 1A88     	 ldrh r2,[r3]
 4191 1a8e BA23     	 mov r3,#186
 4192 1a90 1B01     	 lsl r3,r3,#4
 4193 1a92 9A42     	 cmp r2,r3
 4194 1a94 05D9     	 bls .L110
 861:../main.c     **** 													 {
 862:../main.c     **** 													tester3 = writeakt_light_data_B4_EEprom();
 4195              	 .loc 5 862 0
 4196 1a96 FFF7FEFF 	 bl writeakt_light_data_B4_EEprom
 4197 1a9a 031C     	 mov r3,r0
 4198 1a9c 9AB2     	 uxth r2,r3
 4199 1a9e 464B     	 ldr r3,.L132+148
 4200 1aa0 1A80     	 strh r2,[r3]
 4201              	.L110:
 863:../main.c     **** 													 }
 864:../main.c     **** 													sysiniValueB5();
 4202              	 .loc 5 864 0
 4203 1aa2 FFF7FEFF 	 bl sysiniValueB5
 865:../main.c     **** 													    ReadBuffer2[0]=RegOnOff;
 4204              	 .loc 5 865 0
 4205 1aa6 454B     	 ldr r3,.L132+152
 4206 1aa8 1A78     	 ldrb r2,[r3]
 4207 1aaa 2F4B     	 ldr r3,.L132+68
 4208 1aac 1A70     	 strb r2,[r3]
 866:../main.c     **** 													    ReadBuffer2[1]=RegOnOff2;
 4209              	 .loc 5 866 0
 4210 1aae 444B     	 ldr r3,.L132+156
 4211 1ab0 1A78     	 ldrb r2,[r3]
 4212 1ab2 2D4B     	 ldr r3,.L132+68
 4213 1ab4 5A70     	 strb r2,[r3,#1]
 867:../main.c     **** 													    ReadBuffer2[2] = Reserve_2 / 0x100;
 4214              	 .loc 5 867 0
 4215 1ab6 434B     	 ldr r3,.L132+160
 4216 1ab8 1B88     	 ldrh r3,[r3]
 4217 1aba 1B0A     	 lsr r3,r3,#8
 4218 1abc 9BB2     	 uxth r3,r3
 4219 1abe DAB2     	 uxtb r2,r3
 4220 1ac0 294B     	 ldr r3,.L132+68
 4221 1ac2 9A70     	 strb r2,[r3,#2]
 868:../main.c     **** 													    ReadBuffer2[3] = Reserve_2 & 0xff;
 4222              	 .loc 5 868 0
 4223 1ac4 3F4B     	 ldr r3,.L132+160
 4224 1ac6 1B88     	 ldrh r3,[r3]
 4225 1ac8 DAB2     	 uxtb r2,r3
 4226 1aca 274B     	 ldr r3,.L132+68
 4227 1acc DA70     	 strb r2,[r3,#3]
 869:../main.c     **** 													    ReadBuffer2[4] = dimOff_Ww / 0x100;
 4228              	 .loc 5 869 0
 4229 1ace 3E4B     	 ldr r3,.L132+164
 4230 1ad0 1B88     	 ldrh r3,[r3]
 4231 1ad2 1B0A     	 lsr r3,r3,#8
 4232 1ad4 9BB2     	 uxth r3,r3
 4233 1ad6 DAB2     	 uxtb r2,r3
 4234 1ad8 234B     	 ldr r3,.L132+68
 4235 1ada 1A71     	 strb r2,[r3,#4]
 870:../main.c     **** 													    ReadBuffer2[5] = dimOff_Ww & 0xff;
 4236              	 .loc 5 870 0
 4237 1adc 3A4B     	 ldr r3,.L132+164
 4238 1ade 1B88     	 ldrh r3,[r3]
 4239 1ae0 DAB2     	 uxtb r2,r3
 4240 1ae2 214B     	 ldr r3,.L132+68
 4241 1ae4 5A71     	 strb r2,[r3,#5]
 871:../main.c     **** 													    ReadBuffer2[6] = dimOff_Cw / 0x100;
 4242              	 .loc 5 871 0
 4243 1ae6 394B     	 ldr r3,.L132+168
 4244 1ae8 1B88     	 ldrh r3,[r3]
 4245 1aea 1B0A     	 lsr r3,r3,#8
 4246 1aec 9BB2     	 uxth r3,r3
 4247 1aee DAB2     	 uxtb r2,r3
 4248 1af0 1D4B     	 ldr r3,.L132+68
 4249 1af2 9A71     	 strb r2,[r3,#6]
 872:../main.c     **** 													    ReadBuffer2[7] = dimOff_Ww & 0xff;
 4250              	 .loc 5 872 0
 4251 1af4 344B     	 ldr r3,.L132+164
 4252 1af6 1B88     	 ldrh r3,[r3]
 4253 1af8 DAB2     	 uxtb r2,r3
 4254 1afa 1B4B     	 ldr r3,.L132+68
 4255 1afc DA71     	 strb r2,[r3,#7]
 873:../main.c     **** 													    ReadBuffer2[8] = dimNorm1_Ww /0x100;
 4256              	 .loc 5 873 0
 4257 1afe 344B     	 ldr r3,.L132+172
 4258 1b00 1B88     	 ldrh r3,[r3]
 4259 1b02 1B0A     	 lsr r3,r3,#8
 4260 1b04 9BB2     	 uxth r3,r3
 4261 1b06 DAB2     	 uxtb r2,r3
 4262 1b08 174B     	 ldr r3,.L132+68
 4263 1b0a 1A72     	 strb r2,[r3,#8]
 874:../main.c     **** 													    ReadBuffer2[9] = dimNorm1_Ww & 0xff;
 4264              	 .loc 5 874 0
 4265 1b0c 304B     	 ldr r3,.L132+172
 4266 1b0e 1B88     	 ldrh r3,[r3]
 4267 1b10 DAB2     	 uxtb r2,r3
 4268 1b12 154B     	 ldr r3,.L132+68
 4269 1b14 5A72     	 strb r2,[r3,#9]
 875:../main.c     **** 													    ReadBuffer2[10] = dimNorm1_Cw /0x100;
 4270              	 .loc 5 875 0
 4271 1b16 2F4B     	 ldr r3,.L132+176
 4272 1b18 1B88     	 ldrh r3,[r3]
 4273 1b1a 1B0A     	 lsr r3,r3,#8
 4274 1b1c 9BB2     	 uxth r3,r3
 4275 1b1e DAB2     	 uxtb r2,r3
 4276 1b20 5AE0     	 b .L133
 4277              	.L134:
 4278 1b22 C046     	 .align 2
 4279              	.L132:
 4280 1b24 00000000 	 .word node_id_neu
 4281 1b28 00000000 	 .word Ser_NrH
 4282 1b2c 7A7B0000 	 .word 31610
 4283 1b30 00000000 	 .word ReadData
 4284 1b34 00000000 	 .word Ser_NrL
 4285 1b38 59580000 	 .word 22617
 4286 1b3c 00000000 	 .word Dstatus
 4287 1b40 00000000 	 .word resultB2
 4288 1b44 00000000 	 .word ReadBuffer1
 4289 1b48 00000000 	 .word Hard_Vers
 4290 1b4c 00000000 	 .word Soft_Vers
 4291 1b50 00000000 	 .word GEH_Vers
 4292 1b54 00000000 	 .word Mon_Vers
 4293 1b58 00000000 	 .word LED_WW_Vers
 4294 1b5c 00000000 	 .word LED_CW_Vers
 4295 1b60 00000000 	 .word tester1
 4296 1b64 00000000 	 .word node_id_alt
 4297 1b68 00000000 	 .word ReadBuffer2
 4298 1b6c 00000000 	 .word node_id
 4299 1b70 00000000 	 .word node_id_16bit
 4300 1b74 00000000 	 .word val_Pow_Nom
 4301 1b78 00000000 	 .word val_Pow_max
 4302 1b7c 00000000 	 .word val_Spannung_min
 4303 1b80 00000000 	 .word val_Spannung_max
 4304 1b84 00000000 	 .word led_grupp
 4305 1b88 00000000 	 .word led_Strom
 4306 1b8c 00000000 	 .word tester2
 4307 1b90 00000000 	 .word Dimm_Gamma
 4308 1b94 00000000 	 .word Dimm_Stufen
 4309 1b98 00000000 	 .word Dimm_StufenGR
 4310 1b9c 00000000 	 .word Dimm_Valu
 4311 1ba0 00000000 	 .word Smooth_Value
 4312 1ba4 00000000 	 .word linearwalk_gen
 4313 1ba8 00000000 	 .word Farbe_wwcw_Quot_gen
 4314 1bac 00000000 	 .word Reserve_1
 4315 1bb0 00000000 	 .word Dimm_Max_WW
 4316 1bb4 00000000 	 .word Dimm_Max_CW
 4317 1bb8 00000000 	 .word tester3
 4318 1bbc 00000000 	 .word RegOnOff
 4319 1bc0 00000000 	 .word RegOnOff2
 4320 1bc4 00000000 	 .word Reserve_2
 4321 1bc8 00000000 	 .word dimOff_Ww
 4322 1bcc 00000000 	 .word dimOff_Cw
 4323 1bd0 00000000 	 .word dimNorm1_Ww
 4324 1bd4 00000000 	 .word dimNorm1_Cw
 4325              	.L133:
 4326 1bd8 6F4B     	 ldr r3,.L135
 4327 1bda 9A72     	 strb r2,[r3,#10]
 876:../main.c     **** 													    ReadBuffer2[11] = dimNorm1_Cw & 0xff;
 4328              	 .loc 5 876 0
 4329 1bdc 6F4B     	 ldr r3,.L135+4
 4330 1bde 1B88     	 ldrh r3,[r3]
 4331 1be0 DAB2     	 uxtb r2,r3
 4332 1be2 6D4B     	 ldr r3,.L135
 4333 1be4 DA72     	 strb r2,[r3,#11]
 877:../main.c     **** 													    ReadBuffer2[12] = dimNorm2_Ww / 0x100;
 4334              	 .loc 5 877 0
 4335 1be6 6E4B     	 ldr r3,.L135+8
 4336 1be8 1B88     	 ldrh r3,[r3]
 4337 1bea 1B0A     	 lsr r3,r3,#8
 4338 1bec 9BB2     	 uxth r3,r3
 4339 1bee DAB2     	 uxtb r2,r3
 4340 1bf0 694B     	 ldr r3,.L135
 4341 1bf2 1A73     	 strb r2,[r3,#12]
 878:../main.c     **** 													    ReadBuffer2[13] = dimNorm2_Ww & 0xff;
 4342              	 .loc 5 878 0
 4343 1bf4 6A4B     	 ldr r3,.L135+8
 4344 1bf6 1B88     	 ldrh r3,[r3]
 4345 1bf8 DAB2     	 uxtb r2,r3
 4346 1bfa 674B     	 ldr r3,.L135
 4347 1bfc 5A73     	 strb r2,[r3,#13]
 879:../main.c     **** 													    ReadBuffer2[14] = dimNorm2_Cw /0x100;
 4348              	 .loc 5 879 0
 4349 1bfe 694B     	 ldr r3,.L135+12
 4350 1c00 1B88     	 ldrh r3,[r3]
 4351 1c02 1B0A     	 lsr r3,r3,#8
 4352 1c04 9BB2     	 uxth r3,r3
 4353 1c06 DAB2     	 uxtb r2,r3
 4354 1c08 634B     	 ldr r3,.L135
 4355 1c0a 9A73     	 strb r2,[r3,#14]
 880:../main.c     **** 													    ReadBuffer2[15] = dimNorm2_Cw & 0xff;
 4356              	 .loc 5 880 0
 4357 1c0c 654B     	 ldr r3,.L135+12
 4358 1c0e 1B88     	 ldrh r3,[r3]
 4359 1c10 DAB2     	 uxtb r2,r3
 4360 1c12 614B     	 ldr r3,.L135
 4361 1c14 DA73     	 strb r2,[r3,#15]
 881:../main.c     **** 
 882:../main.c     **** 												 if (resultB2 > min_EEP_Voltage_Uin)
 4362              	 .loc 5 882 0
 4363 1c16 644B     	 ldr r3,.L135+16
 4364 1c18 1A88     	 ldrh r2,[r3]
 4365 1c1a BA23     	 mov r3,#186
 4366 1c1c 1B01     	 lsl r3,r3,#4
 4367 1c1e 9A42     	 cmp r2,r3
 4368 1c20 05D9     	 bls .L111
 883:../main.c     **** 												 {
 884:../main.c     **** 											      tester4 = writeOff_light_B5_EEprom();
 4369              	 .loc 5 884 0
 4370 1c22 FFF7FEFF 	 bl writeOff_light_B5_EEprom
 4371 1c26 031C     	 mov r3,r0
 4372 1c28 9AB2     	 uxth r2,r3
 4373 1c2a 604B     	 ldr r3,.L135+20
 4374 1c2c 1A80     	 strh r2,[r3]
 4375              	.L111:
 885:../main.c     **** 												 }
 886:../main.c     **** 												 tester = writeLamp_data_B3_EEprom();
 4376              	 .loc 5 886 0
 4377 1c2e FFF7FEFF 	 bl writeLamp_data_B3_EEprom
 4378 1c32 031C     	 mov r3,r0
 4379 1c34 1A1C     	 mov r2,r3
 4380 1c36 5E4B     	 ldr r3,.L135+24
 4381 1c38 1A60     	 str r2,[r3]
 887:../main.c     **** 												 if (tester1==0x03)
 4382              	 .loc 5 887 0
 4383 1c3a 5E4B     	 ldr r3,.L135+28
 4384 1c3c 1B88     	 ldrh r3,[r3]
 4385 1c3e 032B     	 cmp r3,#3
 4386 1c40 29D1     	 bne .L112
 888:../main.c     **** 											 	 {
 889:../main.c     **** 													new_data_HalloBack();
 4387              	 .loc 5 889 0
 4388 1c42 FFF7FEFF 	 bl new_data_HalloBack
 890:../main.c     **** 												  	 transmit_buf_size=12;
 4389              	 .loc 5 890 0
 4390 1c46 5C4B     	 ldr r3,.L135+32
 4391 1c48 0C22     	 mov r2,#12
 4392 1c4a 1A70     	 strb r2,[r3]
 891:../main.c     **** 													 new_data[6]='i';
 4393              	 .loc 5 891 0
 4394 1c4c 5B4B     	 ldr r3,.L135+36
 4395 1c4e 6922     	 mov r2,#105
 4396 1c50 9A71     	 strb r2,[r3,#6]
 892:../main.c     **** 													 new_data[7]=tester1;
 4397              	 .loc 5 892 0
 4398 1c52 584B     	 ldr r3,.L135+28
 4399 1c54 1B88     	 ldrh r3,[r3]
 4400 1c56 DAB2     	 uxtb r2,r3
 4401 1c58 584B     	 ldr r3,.L135+36
 4402 1c5a DA71     	 strb r2,[r3,#7]
 893:../main.c     **** 													 new_data[8]=tester2;
 4403              	 .loc 5 893 0
 4404 1c5c 584B     	 ldr r3,.L135+40
 4405 1c5e 1B88     	 ldrh r3,[r3]
 4406 1c60 DAB2     	 uxtb r2,r3
 4407 1c62 564B     	 ldr r3,.L135+36
 4408 1c64 1A72     	 strb r2,[r3,#8]
 894:../main.c     **** 													 new_data[9]=tester3;
 4409              	 .loc 5 894 0
 4410 1c66 574B     	 ldr r3,.L135+44
 4411 1c68 1B88     	 ldrh r3,[r3]
 4412 1c6a DAB2     	 uxtb r2,r3
 4413 1c6c 534B     	 ldr r3,.L135+36
 4414 1c6e 5A72     	 strb r2,[r3,#9]
 895:../main.c     **** 													 new_data[10]=tester4;
 4415              	 .loc 5 895 0
 4416 1c70 4E4B     	 ldr r3,.L135+20
 4417 1c72 1B88     	 ldrh r3,[r3]
 4418 1c74 DAB2     	 uxtb r2,r3
 4419 1c76 514B     	 ldr r3,.L135+36
 4420 1c78 9A72     	 strb r2,[r3,#10]
 896:../main.c     **** 													 new_data[11]=0xff;
 4421              	 .loc 5 896 0
 4422 1c7a 504B     	 ldr r3,.L135+36
 4423 1c7c FF22     	 mov r2,#255
 4424 1c7e DA72     	 strb r2,[r3,#11]
 897:../main.c     **** 													UART_Transmit(&UART_1, new_data,transmit_buf_size);
 4425              	 .loc 5 897 0
 4426 1c80 4D4B     	 ldr r3,.L135+32
 4427 1c82 1B78     	 ldrb r3,[r3]
 4428 1c84 1C1C     	 mov r4,r3
 4429 1c86 504A     	 ldr r2,.L135+48
 4430 1c88 4C4B     	 ldr r3,.L135+36
 4431 1c8a 101C     	 mov r0,r2
 4432 1c8c 191C     	 mov r1,r3
 4433 1c8e 221C     	 mov r2,r4
 4434 1c90 FFF7FEFF 	 bl UART_Transmit
 4435 1c94 5EE0     	 b .L115
 4436              	.L112:
 898:../main.c     **** 												  }
 899:../main.c     **** 													else
 900:../main.c     **** 													{new_data_HalloBack();
 4437              	 .loc 5 900 0
 4438 1c96 FFF7FEFF 	 bl new_data_HalloBack
 901:../main.c     **** 												  	 transmit_buf_size=13;
 4439              	 .loc 5 901 0
 4440 1c9a 474B     	 ldr r3,.L135+32
 4441 1c9c 0D22     	 mov r2,#13
 4442 1c9e 1A70     	 strb r2,[r3]
 902:../main.c     **** 													 new_data[6]='e';
 4443              	 .loc 5 902 0
 4444 1ca0 464B     	 ldr r3,.L135+36
 4445 1ca2 6522     	 mov r2,#101
 4446 1ca4 9A71     	 strb r2,[r3,#6]
 903:../main.c     **** 													 new_data[7]=15;
 4447              	 .loc 5 903 0
 4448 1ca6 454B     	 ldr r3,.L135+36
 4449 1ca8 0F22     	 mov r2,#15
 4450 1caa DA71     	 strb r2,[r3,#7]
 904:../main.c     **** 													 new_data[8]=tester1;
 4451              	 .loc 5 904 0
 4452 1cac 414B     	 ldr r3,.L135+28
 4453 1cae 1B88     	 ldrh r3,[r3]
 4454 1cb0 DAB2     	 uxtb r2,r3
 4455 1cb2 424B     	 ldr r3,.L135+36
 4456 1cb4 1A72     	 strb r2,[r3,#8]
 905:../main.c     **** 													 new_data[9]=tester2;
 4457              	 .loc 5 905 0
 4458 1cb6 424B     	 ldr r3,.L135+40
 4459 1cb8 1B88     	 ldrh r3,[r3]
 4460 1cba DAB2     	 uxtb r2,r3
 4461 1cbc 3F4B     	 ldr r3,.L135+36
 4462 1cbe 5A72     	 strb r2,[r3,#9]
 906:../main.c     **** 													 new_data[10]=tester3;
 4463              	 .loc 5 906 0
 4464 1cc0 404B     	 ldr r3,.L135+44
 4465 1cc2 1B88     	 ldrh r3,[r3]
 4466 1cc4 DAB2     	 uxtb r2,r3
 4467 1cc6 3D4B     	 ldr r3,.L135+36
 4468 1cc8 9A72     	 strb r2,[r3,#10]
 907:../main.c     **** 													 new_data[11]=tester4;
 4469              	 .loc 5 907 0
 4470 1cca 384B     	 ldr r3,.L135+20
 4471 1ccc 1B88     	 ldrh r3,[r3]
 4472 1cce DAB2     	 uxtb r2,r3
 4473 1cd0 3A4B     	 ldr r3,.L135+36
 4474 1cd2 DA72     	 strb r2,[r3,#11]
 908:../main.c     **** 													 new_data[12]=0xff;
 4475              	 .loc 5 908 0
 4476 1cd4 394B     	 ldr r3,.L135+36
 4477 1cd6 FF22     	 mov r2,#255
 4478 1cd8 1A73     	 strb r2,[r3,#12]
 909:../main.c     **** 													 UART_Transmit(&UART_1, new_data,transmit_buf_size);
 4479              	 .loc 5 909 0
 4480 1cda 374B     	 ldr r3,.L135+32
 4481 1cdc 1B78     	 ldrb r3,[r3]
 4482 1cde 1C1C     	 mov r4,r3
 4483 1ce0 394A     	 ldr r2,.L135+48
 4484 1ce2 364B     	 ldr r3,.L135+36
 4485 1ce4 101C     	 mov r0,r2
 4486 1ce6 191C     	 mov r1,r3
 4487 1ce8 221C     	 mov r2,r4
 4488 1cea FFF7FEFF 	 bl UART_Transmit
 4489 1cee 31E0     	 b .L115
 4490              	.L107:
 910:../main.c     **** 													}
 911:../main.c     **** 											 } //if result
 912:../main.c     **** 
 913:../main.c     **** 												 else{
 914:../main.c     **** 													new_data_HalloBack();
 4491              	 .loc 5 914 0
 4492 1cf0 FFF7FEFF 	 bl new_data_HalloBack
 915:../main.c     **** 													 new_data[6]='e';
 4493              	 .loc 5 915 0
 4494 1cf4 314B     	 ldr r3,.L135+36
 4495 1cf6 6522     	 mov r2,#101
 4496 1cf8 9A71     	 strb r2,[r3,#6]
 916:../main.c     **** 													 new_data[7]='r';
 4497              	 .loc 5 916 0
 4498 1cfa 304B     	 ldr r3,.L135+36
 4499 1cfc 7222     	 mov r2,#114
 4500 1cfe DA71     	 strb r2,[r3,#7]
 917:../main.c     **** 													 new_data[8]='0';
 4501              	 .loc 5 917 0
 4502 1d00 2E4B     	 ldr r3,.L135+36
 4503 1d02 3022     	 mov r2,#48
 4504 1d04 1A72     	 strb r2,[r3,#8]
 918:../main.c     **** 													 new_data[9]='3';
 4505              	 .loc 5 918 0
 4506 1d06 2D4B     	 ldr r3,.L135+36
 4507 1d08 3322     	 mov r2,#51
 4508 1d0a 5A72     	 strb r2,[r3,#9]
 919:../main.c     **** 													UART_Transmit(&UART_1, new_data,transmit_buf_size);
 4509              	 .loc 5 919 0
 4510 1d0c 2A4B     	 ldr r3,.L135+32
 4511 1d0e 1B78     	 ldrb r3,[r3]
 4512 1d10 1C1C     	 mov r4,r3
 4513 1d12 2D4A     	 ldr r2,.L135+48
 4514 1d14 294B     	 ldr r3,.L135+36
 4515 1d16 101C     	 mov r0,r2
 4516 1d18 191C     	 mov r1,r3
 4517 1d1a 221C     	 mov r2,r4
 4518 1d1c FFF7FEFF 	 bl UART_Transmit
 792:../main.c     **** 											 {
 4519              	 .loc 5 792 0
 4520 1d20 32E0     	 b .L116
 4521              	.L106:
 920:../main.c     **** 												  }
 921:../main.c     **** 										 }//if status
 922:../main.c     **** 											else {
 923:../main.c     **** 											new_data_HalloBack();     // vorgabewerte stimmen nicht
 4522              	 .loc 5 923 0
 4523 1d22 FFF7FEFF 	 bl new_data_HalloBack
 924:../main.c     **** 											 new_data[6]='e';
 4524              	 .loc 5 924 0
 4525 1d26 254B     	 ldr r3,.L135+36
 4526 1d28 6522     	 mov r2,#101
 4527 1d2a 9A71     	 strb r2,[r3,#6]
 925:../main.c     **** 											 new_data[7]='r';
 4528              	 .loc 5 925 0
 4529 1d2c 234B     	 ldr r3,.L135+36
 4530 1d2e 7222     	 mov r2,#114
 4531 1d30 DA71     	 strb r2,[r3,#7]
 926:../main.c     **** 											 new_data[8]='0';
 4532              	 .loc 5 926 0
 4533 1d32 224B     	 ldr r3,.L135+36
 4534 1d34 3022     	 mov r2,#48
 4535 1d36 1A72     	 strb r2,[r3,#8]
 927:../main.c     **** 											 new_data[9]='2';
 4536              	 .loc 5 927 0
 4537 1d38 204B     	 ldr r3,.L135+36
 4538 1d3a 3222     	 mov r2,#50
 4539 1d3c 5A72     	 strb r2,[r3,#9]
 928:../main.c     **** 											 UART_Transmit(&UART_1, new_data,transmit_buf_size);
 4540              	 .loc 5 928 0
 4541 1d3e 1E4B     	 ldr r3,.L135+32
 4542 1d40 1B78     	 ldrb r3,[r3]
 4543 1d42 1C1C     	 mov r4,r3
 4544 1d44 204A     	 ldr r2,.L135+48
 4545 1d46 1D4B     	 ldr r3,.L135+36
 4546 1d48 101C     	 mov r0,r2
 4547 1d4a 191C     	 mov r1,r3
 4548 1d4c 221C     	 mov r2,r4
 4549 1d4e FFF7FEFF 	 bl UART_Transmit
 792:../main.c     **** 											 {
 4550              	 .loc 5 792 0
 4551 1d52 19E0     	 b .L116
 4552              	.L115:
 792:../main.c     **** 											 {
 4553              	 .loc 5 792 0 is_stmt 0 discriminator 13
 4554 1d54 18E0     	 b .L116
 4555              	.L105:
 929:../main.c     **** 											}
 930:../main.c     **** 									 }//if sernr
 931:../main.c     **** 											else {
 932:../main.c     **** 											new_data_HalloBack();     // vorgabewerte stimmen nicht
 4556              	 .loc 5 932 0 is_stmt 1
 4557 1d56 FFF7FEFF 	 bl new_data_HalloBack
 933:../main.c     **** 											 new_data[6]='e';
 4558              	 .loc 5 933 0
 4559 1d5a 184B     	 ldr r3,.L135+36
 4560 1d5c 6522     	 mov r2,#101
 4561 1d5e 9A71     	 strb r2,[r3,#6]
 934:../main.c     **** 											 new_data[7]='r';
 4562              	 .loc 5 934 0
 4563 1d60 164B     	 ldr r3,.L135+36
 4564 1d62 7222     	 mov r2,#114
 4565 1d64 DA71     	 strb r2,[r3,#7]
 935:../main.c     **** 											 new_data[8]='0';
 4566              	 .loc 5 935 0
 4567 1d66 154B     	 ldr r3,.L135+36
 4568 1d68 3022     	 mov r2,#48
 4569 1d6a 1A72     	 strb r2,[r3,#8]
 936:../main.c     **** 											 new_data[9]='1';
 4570              	 .loc 5 936 0
 4571 1d6c 134B     	 ldr r3,.L135+36
 4572 1d6e 3122     	 mov r2,#49
 4573 1d70 5A72     	 strb r2,[r3,#9]
 937:../main.c     **** 											 UART_Transmit(&UART_1, new_data,transmit_buf_size);
 4574              	 .loc 5 937 0
 4575 1d72 114B     	 ldr r3,.L135+32
 4576 1d74 1B78     	 ldrb r3,[r3]
 4577 1d76 1C1C     	 mov r4,r3
 4578 1d78 134A     	 ldr r2,.L135+48
 4579 1d7a 104B     	 ldr r3,.L135+36
 4580 1d7c 101C     	 mov r0,r2
 4581 1d7e 191C     	 mov r1,r3
 4582 1d80 221C     	 mov r2,r4
 4583 1d82 FFF7FEFF 	 bl UART_Transmit
 938:../main.c     **** 											}
 939:../main.c     **** 											break;
 4584              	 .loc 5 939 0
 4585 1d86 01E0     	 b .L47
 4586              	.L116:
 4587              	 .loc 5 939 0 is_stmt 0 discriminator 14
 4588 1d88 00E0     	 b .L47
 4589              	.L119:
 940:../main.c     **** 
 941:../main.c     **** 				default:
 942:../main.c     **** 				break;
 4590              	 .loc 5 942 0 is_stmt 1
 4591 1d8a C046     	 mov r8,r8
 4592              	.L47:
 943:../main.c     **** 				}//switch
 944:../main.c     **** 			  } // else node id == ok
 945:../main.c     **** 
 946:../main.c     **** 				//############
 947:../main.c     **** 				execute = 0;
 4593              	 .loc 5 947 0
 4594 1d8c 0F4B     	 ldr r3,.L135+52
 4595 1d8e 0022     	 mov r2,#0
 4596 1d90 1A70     	 strb r2,[r3]
 4597              	.L25:
 948:../main.c     **** 			} // if ( execute == 1 )
 949:../main.c     **** 		} // if(UART_Receive(&UART_1, ReadData, 1) == UART_STATUS_SUCCESS)
 950:../main.c     **** 	}
 4598              	 .loc 5 950 0
 4599 1d92 FEF7EEFB 	 bl .L117
 4600              	.L136:
 4601 1d96 C046     	 .align 2
 4602              	.L135:
 4603 1d98 00000000 	 .word ReadBuffer2
 4604 1d9c 00000000 	 .word dimNorm1_Cw
 4605 1da0 00000000 	 .word dimNorm2_Ww
 4606 1da4 00000000 	 .word dimNorm2_Cw
 4607 1da8 00000000 	 .word resultB2
 4608 1dac 00000000 	 .word tester4
 4609 1db0 00000000 	 .word tester
 4610 1db4 00000000 	 .word tester1
 4611 1db8 00000000 	 .word transmit_buf_size
 4612 1dbc 00000000 	 .word new_data
 4613 1dc0 00000000 	 .word tester2
 4614 1dc4 00000000 	 .word tester3
 4615 1dc8 00000000 	 .word UART_1
 4616 1dcc 00000000 	 .word execute
 4617              	 .cfi_endproc
 4618              	.LFE290:
 4620              	 .section .text.endofTransmitU1,"ax",%progbits
 4621              	 .align 2
 4622              	 .global endofTransmitU1
 4623              	 .code 16
 4624              	 .thumb_func
 4626              	endofTransmitU1:
 4627              	.LFB291:
 951:../main.c     **** 
 952:../main.c     **** 
 953:../main.c     **** 
 954:../main.c     **** 
 955:../main.c     **** 
 956:../main.c     ****    while(1U)
 957:../main.c     ****    {
 958:../main.c     **** 	   tester =  tester + 1;
 959:../main.c     **** 	   tester =  digitalo();
 960:../main.c     **** 
 961:../main.c     **** 	 //    resultA = ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_ADV_0_Channel_A);
 962:../main.c     **** 	 //    resultB = ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_ADV_0_Channel_B);
 963:../main.c     **** 
 964:../main.c     **** 	  //   XMC_UNUSED_ARG(resultA);
 965:../main.c     **** 	  //   XMC_UNUSED_ARG(resultB);
 966:../main.c     **** 	 //  analog_start () ; //  ADC_MEASUREMENT_ADV_SoftwareTrigger(&ADC_MEASUREMENT_ADV_0);
 967:../main.c     **** 		UART_Transmit(&UART_1, rec_data, sizeof(rec_data));
 968:../main.c     ****    }
 969:../main.c     ****    return (1U);
 970:../main.c     ****  }
 971:../main.c     **** 
 972:../main.c     **** //----------------------------------------------------------------------------------------
 973:../main.c     **** void endofTransmitU1()//Callback functin for "End of transmit" event.
 974:../main.c     ****  {
 4628              	 .loc 5 974 0
 4629              	 .cfi_startproc
 4630 0000 80B5     	 push {r7,lr}
 4631              	.LCFI21:
 4632              	 .cfi_def_cfa_offset 8
 4633              	 .cfi_offset 7,-8
 4634              	 .cfi_offset 14,-4
 4635 0002 00AF     	 add r7,sp,#0
 4636              	.LCFI22:
 4637              	 .cfi_def_cfa_register 7
 975:../main.c     ****  // UART_Receive(&UART_0, rec_data, sizeof(rec_data));
 976:../main.c     **** 	  // DIGITAL_IO_ToggleOutput(&VCC_LED_shtdwn);
 977:../main.c     ****  }
 4638              	 .loc 5 977 0
 4639 0004 BD46     	 mov sp,r7
 4640              	 
 4641 0006 80BD     	 pop {r7,pc}
 4642              	 .cfi_endproc
 4643              	.LFE291:
 4645              	 .section .text.endofReceiveU1,"ax",%progbits
 4646              	 .align 2
 4647              	 .global endofReceiveU1
 4648              	 .code 16
 4649              	 .thumb_func
 4651              	endofReceiveU1:
 4652              	.LFB292:
 978:../main.c     **** //----------------------------------------------------------------------------------------
 979:../main.c     ****  void endofReceiveU1()//Callback function for "End of receive" event.
 980:../main.c     ****  {
 4653              	 .loc 5 980 0
 4654              	 .cfi_startproc
 4655 0000 80B5     	 push {r7,lr}
 4656              	.LCFI23:
 4657              	 .cfi_def_cfa_offset 8
 4658              	 .cfi_offset 7,-8
 4659              	 .cfi_offset 14,-4
 4660 0002 00AF     	 add r7,sp,#0
 4661              	.LCFI24:
 4662              	 .cfi_def_cfa_register 7
 981:../main.c     **** 	//   DIGITAL_IO_ToggleOutput(&DO_SEL_Gain);  //	 LED_Toggle_EverySec( );
 982:../main.c     **** 	//UART_Transmit(&UART_0, rec_data, sizeof(rec_data));
 983:../main.c     ****  }
 4663              	 .loc 5 983 0
 4664 0004 BD46     	 mov sp,r7
 4665              	 
 4666 0006 80BD     	 pop {r7,pc}
 4667              	 .cfi_endproc
 4668              	.LFE292:
 4670              	 .section .text.endofTransmitU0,"ax",%progbits
 4671              	 .align 2
 4672              	 .global endofTransmitU0
 4673              	 .code 16
 4674              	 .thumb_func
 4676              	endofTransmitU0:
 4677              	.LFB293:
 984:../main.c     ****  //----------------------------------------------------------------------------------------
 985:../main.c     ****  void endofTransmitU0()//Callback functin for "End of transmit" event.
 986:../main.c     ****   {
 4678              	 .loc 5 986 0
 4679              	 .cfi_startproc
 4680 0000 80B5     	 push {r7,lr}
 4681              	.LCFI25:
 4682              	 .cfi_def_cfa_offset 8
 4683              	 .cfi_offset 7,-8
 4684              	 .cfi_offset 14,-4
 4685 0002 00AF     	 add r7,sp,#0
 4686              	.LCFI26:
 4687              	 .cfi_def_cfa_register 7
 987:../main.c     ****  //a  UART_Receive(&UART_1, rec_data, sizeof(rec_data));
 988:../main.c     **** 	 //a	  DIGITAL_IO_ToggleOutput(&DO_LED_Shtdwn);
 989:../main.c     ****   }
 4688              	 .loc 5 989 0
 4689 0004 BD46     	 mov sp,r7
 4690              	 
 4691 0006 80BD     	 pop {r7,pc}
 4692              	 .cfi_endproc
 4693              	.LFE293:
 4695              	 .section .text.endofReceiveU0,"ax",%progbits
 4696              	 .align 2
 4697              	 .global endofReceiveU0
 4698              	 .code 16
 4699              	 .thumb_func
 4701              	endofReceiveU0:
 4702              	.LFB294:
 990:../main.c     ****  //----------------------------------------------------------------------------------------
 991:../main.c     ****   void endofReceiveU0()//Callback function for "End of receive" event.
 992:../main.c     ****   {
 4703              	 .loc 5 992 0
 4704              	 .cfi_startproc
 4705 0000 80B5     	 push {r7,lr}
 4706              	.LCFI27:
 4707              	 .cfi_def_cfa_offset 8
 4708              	 .cfi_offset 7,-8
 4709              	 .cfi_offset 14,-4
 4710 0002 00AF     	 add r7,sp,#0
 4711              	.LCFI28:
 4712              	 .cfi_def_cfa_register 7
 993:../main.c     ****  	  // DIGITAL_IO_ToggleOutput(&DO_SEL_Gain);  //	 LED_Toggle_EverySec( );
 994:../main.c     **** 	  //a UART_Transmit(&UART_1, rec_data, sizeof(rec_data));
 995:../main.c     ****   }
 4713              	 .loc 5 995 0
 4714 0004 BD46     	 mov sp,r7
 4715              	 
 4716 0006 80BD     	 pop {r7,pc}
 4717              	 .cfi_endproc
 4718              	.LFE294:
 4720              	 .section .text.VADC0_C0_0_IRQHandler,"ax",%progbits
 4721              	 .align 2
 4722              	 .global VADC0_C0_0_IRQHandler
 4723              	 .code 16
 4724              	 .thumb_func
 4726              	VADC0_C0_0_IRQHandler:
 4727              	.LFB295:
 996:../main.c     ****  //----------------------------------------------------------------------------------------
 997:../main.c     ****   void adcIRQHandler(void)
 998:../main.c     ****   {
 4728              	 .loc 5 998 0
 4729              	 .cfi_startproc
 4730 0000 80B5     	 push {r7,lr}
 4731              	.LCFI29:
 4732              	 .cfi_def_cfa_offset 8
 4733              	 .cfi_offset 7,-8
 4734              	 .cfi_offset 14,-4
 4735 0002 00AF     	 add r7,sp,#0
 4736              	.LCFI30:
 4737              	 .cfi_def_cfa_register 7
 999:../main.c     ****         // read the results of the conversion
1000:../main.c     ****         resultA = ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_ADV_0_xmc_U_in);
 4738              	 .loc 5 1000 0
 4739 0004 354B     	 ldr r3,.L146
 4740 0006 181C     	 mov r0,r3
 4741 0008 FFF7FEFF 	 bl ADC_MEASUREMENT_ADV_GetResult
 4742 000c 031C     	 mov r3,r0
 4743 000e 1A1C     	 mov r2,r3
 4744 0010 334B     	 ldr r3,.L146+4
 4745 0012 1A80     	 strh r2,[r3]
1001:../main.c     ****         resultAalt = (resultA + 3*resultAalt)/4;
 4746              	 .loc 5 1001 0
 4747 0014 324B     	 ldr r3,.L146+4
 4748 0016 1B88     	 ldrh r3,[r3]
 4749 0018 191C     	 mov r1,r3
 4750 001a 324B     	 ldr r3,.L146+8
 4751 001c 1B88     	 ldrh r3,[r3]
 4752 001e 1A1C     	 mov r2,r3
 4753 0020 131C     	 mov r3,r2
 4754 0022 5B00     	 lsl r3,r3,#1
 4755 0024 9B18     	 add r3,r3,r2
 4756 0026 CB18     	 add r3,r1,r3
 4757 0028 002B     	 cmp r3,#0
 4758 002a 00DA     	 bge .L142
 4759 002c 0333     	 add r3,r3,#3
 4760              	.L142:
 4761 002e 9B10     	 asr r3,r3,#2
 4762 0030 9AB2     	 uxth r2,r3
 4763 0032 2C4B     	 ldr r3,.L146+8
 4764 0034 1A80     	 strh r2,[r3]
1002:../main.c     ****         resultB = ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_ADV_0_xmc_ntc);
 4765              	 .loc 5 1002 0
 4766 0036 2C4B     	 ldr r3,.L146+12
 4767 0038 181C     	 mov r0,r3
 4768 003a FFF7FEFF 	 bl ADC_MEASUREMENT_ADV_GetResult
 4769 003e 031C     	 mov r3,r0
 4770 0040 1A1C     	 mov r2,r3
 4771 0042 2A4B     	 ldr r3,.L146+16
 4772 0044 1A80     	 strh r2,[r3]
1003:../main.c     ****         resultBalt = (resultB + 3*resultBalt)/4;
 4773              	 .loc 5 1003 0
 4774 0046 294B     	 ldr r3,.L146+16
 4775 0048 1B88     	 ldrh r3,[r3]
 4776 004a 191C     	 mov r1,r3
 4777 004c 284B     	 ldr r3,.L146+20
 4778 004e 1B88     	 ldrh r3,[r3]
 4779 0050 1A1C     	 mov r2,r3
 4780 0052 131C     	 mov r3,r2
 4781 0054 5B00     	 lsl r3,r3,#1
 4782 0056 9B18     	 add r3,r3,r2
 4783 0058 CB18     	 add r3,r1,r3
 4784 005a 002B     	 cmp r3,#0
 4785 005c 00DA     	 bge .L143
 4786 005e 0333     	 add r3,r3,#3
 4787              	.L143:
 4788 0060 9B10     	 asr r3,r3,#2
 4789 0062 9AB2     	 uxth r2,r3
 4790 0064 224B     	 ldr r3,.L146+20
 4791 0066 1A80     	 strh r2,[r3]
1004:../main.c     ****         resultC = ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_ADV_0_xmc_I_ww);
 4792              	 .loc 5 1004 0
 4793 0068 224B     	 ldr r3,.L146+24
 4794 006a 181C     	 mov r0,r3
 4795 006c FFF7FEFF 	 bl ADC_MEASUREMENT_ADV_GetResult
 4796 0070 031C     	 mov r3,r0
 4797 0072 1A1C     	 mov r2,r3
 4798 0074 204B     	 ldr r3,.L146+28
 4799 0076 1A80     	 strh r2,[r3]
1005:../main.c     ****         resultCalt = (resultC + 3*resultCalt)/4;
 4800              	 .loc 5 1005 0
 4801 0078 1F4B     	 ldr r3,.L146+28
 4802 007a 1B88     	 ldrh r3,[r3]
 4803 007c 191C     	 mov r1,r3
 4804 007e 1F4B     	 ldr r3,.L146+32
 4805 0080 1B88     	 ldrh r3,[r3]
 4806 0082 1A1C     	 mov r2,r3
 4807 0084 131C     	 mov r3,r2
 4808 0086 5B00     	 lsl r3,r3,#1
 4809 0088 9B18     	 add r3,r3,r2
 4810 008a CB18     	 add r3,r1,r3
 4811 008c 002B     	 cmp r3,#0
 4812 008e 00DA     	 bge .L144
 4813 0090 0333     	 add r3,r3,#3
 4814              	.L144:
 4815 0092 9B10     	 asr r3,r3,#2
 4816 0094 9AB2     	 uxth r2,r3
 4817 0096 194B     	 ldr r3,.L146+32
 4818 0098 1A80     	 strh r2,[r3]
1006:../main.c     ****         resultD = ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_ADV_0_xmc_I_cw);
 4819              	 .loc 5 1006 0
 4820 009a 194B     	 ldr r3,.L146+36
 4821 009c 181C     	 mov r0,r3
 4822 009e FFF7FEFF 	 bl ADC_MEASUREMENT_ADV_GetResult
 4823 00a2 031C     	 mov r3,r0
 4824 00a4 1A1C     	 mov r2,r3
 4825 00a6 174B     	 ldr r3,.L146+40
 4826 00a8 1A80     	 strh r2,[r3]
1007:../main.c     ****         resultDalt = (resultD + 3*resultDalt)/4;
 4827              	 .loc 5 1007 0
 4828 00aa 164B     	 ldr r3,.L146+40
 4829 00ac 1B88     	 ldrh r3,[r3]
 4830 00ae 191C     	 mov r1,r3
 4831 00b0 154B     	 ldr r3,.L146+44
 4832 00b2 1B88     	 ldrh r3,[r3]
 4833 00b4 1A1C     	 mov r2,r3
 4834 00b6 131C     	 mov r3,r2
 4835 00b8 5B00     	 lsl r3,r3,#1
 4836 00ba 9B18     	 add r3,r3,r2
 4837 00bc CB18     	 add r3,r1,r3
 4838 00be 002B     	 cmp r3,#0
 4839 00c0 00DA     	 bge .L145
 4840 00c2 0333     	 add r3,r3,#3
 4841              	.L145:
 4842 00c4 9B10     	 asr r3,r3,#2
 4843 00c6 9AB2     	 uxth r2,r3
 4844 00c8 0F4B     	 ldr r3,.L146+44
 4845 00ca 1A80     	 strh r2,[r3]
1008:../main.c     ****         adc_ready=adc_ready + 1;
 4846              	 .loc 5 1008 0
 4847 00cc 0F4B     	 ldr r3,.L146+48
 4848 00ce 1B88     	 ldrh r3,[r3]
 4849 00d0 0133     	 add r3,r3,#1
 4850 00d2 9AB2     	 uxth r2,r3
 4851 00d4 0D4B     	 ldr r3,.L146+48
 4852 00d6 1A80     	 strh r2,[r3]
1009:../main.c     ****         //Start the next round of conversion
1010:../main.c     ****       //  ADC_MEASUREMENT_ADV_SoftwareTrigger(&ADC_MEASUREMENT_ADV_0);
1011:../main.c     ****   }
 4853              	 .loc 5 1011 0
 4854 00d8 BD46     	 mov sp,r7
 4855              	 
 4856 00da 80BD     	 pop {r7,pc}
 4857              	.L147:
 4858              	 .align 2
 4859              	.L146:
 4860 00dc 00000000 	 .word ADC_MEASUREMENT_ADV_0_xmc_U_in_handle
 4861 00e0 00000000 	 .word resultA
 4862 00e4 00000000 	 .word resultAalt
 4863 00e8 00000000 	 .word ADC_MEASUREMENT_ADV_0_xmc_ntc_handle
 4864 00ec 00000000 	 .word resultB
 4865 00f0 00000000 	 .word resultBalt
 4866 00f4 00000000 	 .word ADC_MEASUREMENT_ADV_0_xmc_I_ww_handle
 4867 00f8 00000000 	 .word resultC
 4868 00fc 00000000 	 .word resultCalt
 4869 0100 00000000 	 .word ADC_MEASUREMENT_ADV_0_xmc_I_cw_handle
 4870 0104 00000000 	 .word resultD
 4871 0108 00000000 	 .word resultDalt
 4872 010c 00000000 	 .word adc_ready
 4873              	 .cfi_endproc
 4874              	.LFE295:
 4876              	 .text
 4877              	.Letext0:
 4878              	 .file 6 "c:\\davev4-64bit\\dave-4.3.2\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 4879              	 .file 7 "c:\\davev4-64bit\\dave-4.3.2\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 4880              	 .file 8 "C:/DAVEv4-64Bit/work/Demo_1/Libraries/CMSIS/Infineon/XMC1300_series/Include/XMC1300.h"
 4881              	 .file 9 "C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc/xmc1_gpio.h"
 4882              	 .file 10 "C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc/xmc_usic.h"
 4883              	 .file 11 "C:/DAVEv4-64Bit/work/Demo_1/Libraries/XMCLib/inc/xmc_uart.h"
 4884              	 .file 12 "C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/UART/uart.h"
 4885              	 .file 13 "C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/SYSTIMER/systimer.h"
 4886              	 .file 14 "C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DAVE.h"
 4887              	 .file 15 "C:/DAVEv4-64Bit/work/Demo_1/Libraries/CMSIS/Infineon/XMC1300_series/Include/system_XMC1300.h"
 4888              	 .file 16 "C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/DIGITAL_IO/digital_io_extern.h"
 4889              	 .file 17 "C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/UART/uart_extern.h"
 4890              	 .file 18 "C:/DAVEv4-64Bit/work/Demo_1/Dave/Generated/ADC_MEASUREMENT_ADV/adc_measurement_adv_extern.h"
 4891              	 .file 19 "C:/DAVEv4-64Bit/work/Demo_1/samuel/samuel_io.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
    {standard input}:18     .text.XMC_GPIO_SetOutputHigh:00000000 $t
    {standard input}:22     .text.XMC_GPIO_SetOutputHigh:00000000 XMC_GPIO_SetOutputHigh
    {standard input}:58     .text.XMC_GPIO_SetOutputLow:00000000 $t
    {standard input}:62     .text.XMC_GPIO_SetOutputLow:00000000 XMC_GPIO_SetOutputLow
    {standard input}:98     .text.DIGITAL_IO_SetOutputHigh:00000000 $t
    {standard input}:102    .text.DIGITAL_IO_SetOutputHigh:00000000 DIGITAL_IO_SetOutputHigh
    {standard input}:136    .text.DIGITAL_IO_SetOutputLow:00000000 $t
    {standard input}:140    .text.DIGITAL_IO_SetOutputLow:00000000 DIGITAL_IO_SetOutputLow
    {standard input}:173    .text.XMC_VADC_GROUP_GetResult:00000000 $t
    {standard input}:177    .text.XMC_VADC_GROUP_GetResult:00000000 XMC_VADC_GROUP_GetResult
    {standard input}:212    .text.ADC_MEASUREMENT_ADV_GetResult:00000000 $t
    {standard input}:216    .text.ADC_MEASUREMENT_ADV_GetResult:00000000 ADC_MEASUREMENT_ADV_GetResult
    {standard input}:269    .text.ADC_MEASUREMENT_ADV_GetResult:00000040 $d
                            *COM*:00000002 adc_ready
                            *COM*:00000002 adc_ready20m
                            *COM*:00000002 resultA
                            *COM*:00000002 resultB
                            *COM*:00000002 resultC
                            *COM*:00000002 resultD
                            *COM*:00000002 resultA2
                            *COM*:00000002 resultB2
                            *COM*:00000002 resultC2
                            *COM*:00000002 resultD2
                            *COM*:00000002 resultAalt
                            *COM*:00000002 resultBalt
                            *COM*:00000002 resultCalt
                            *COM*:00000002 resultDalt
                            *COM*:00000002 resultAalt2
                            *COM*:00000002 resultBalt2
                            *COM*:00000002 resultCalt2
                            *COM*:00000002 resultDCalt2
                            *COM*:00000004 delay_count
                            *COM*:00000002 zahler_offlight
                            *COM*:00000002 zahler_lightprog01
                            *COM*:00000002 Ser_NrH
                            *COM*:00000002 Ser_NrL
                            *COM*:00000002 Hard_Vers
                            *COM*:00000002 Soft_Vers
                            *COM*:00000002 GEH_Vers
                            *COM*:00000002 Mon_Vers
                            *COM*:00000002 LED_WW_Vers
                            *COM*:00000002 LED_CW_Vers
                            *COM*:00000002 neu_Ser_NrH
                            *COM*:00000002 neu_Ser_NrL
                            *COM*:00000001 node_id
                            *COM*:00000001 node_id_alt
                            *COM*:00000002 node_id_16bit
                            *COM*:00000002 val_Pow_Nom
                            *COM*:00000002 val_Pow_max
                            *COM*:00000002 val_Spannung_min
                            *COM*:00000002 val_Spannung_max
                            *COM*:00000002 led_grupp
                            *COM*:00000002 led_Strom
                            *COM*:00000001 node_id_resi
                            *COM*:00000001 node_id_neu
                            *COM*:00000001 Dimm_Gamma
                            *COM*:00000001 Dimm_Stufen
                            *COM*:00000001 Dimm_StufenGR
                            *COM*:00000001 Dimm_Valu
                            *COM*:00000002 Smooth_Value
                            *COM*:00000002 linearwalk_gen
                            *COM*:00000002 Farbe_wwcw_Quot_gen
                            *COM*:00000002 Reserve_1
                            *COM*:00000002 Dimm_Max_WW
                            *COM*:00000002 Dimm_Max_CW
                            *COM*:00000002 dimAkt_Ww
                            *COM*:00000002 dimAkt_Cw
                            *COM*:00000002 linearwalk_ww1
                            *COM*:00000002 linearwalk_ww2
                            *COM*:00000002 linearwalk_cw1
                            *COM*:00000002 linearwalk_cw2
                            *COM*:00000002 Farbe_ww1_Quot
                            *COM*:00000002 Farbe_cw1_Quot
                            *COM*:00000002 Farbe_ww2_Quot
                            *COM*:00000002 Farbe_cw2_Quot
                            *COM*:00000002 Farbe_ww1
                            *COM*:00000002 Farbe_ww2
                            *COM*:00000002 Farbe_cw1
                            *COM*:00000002 Farbe_cw2
                            *COM*:00000001 RegOnOff
                            *COM*:00000001 RegOnOff2
                            *COM*:00000002 Reserve_2
                            *COM*:00000002 dimOff_Ww
                            *COM*:00000002 dimOff_Cw
                            *COM*:00000002 dimNorm1_Ww
                            *COM*:00000002 dimNorm1_Cw
                            *COM*:00000002 dimNorm2_Ww
                            *COM*:00000002 dimNorm2_Cw
                            *COM*:00000002 Brightness_Gen
                            *COM*:00000002 ColorQuot_Gen
                            *COM*:00000010 rec_data
                            *COM*:00000010 new_data
                            *COM*:00000020 eeprom_data
                            *COM*:00000001 transmit_buf_size
                            *COM*:00000008 ReadData
                            *COM*:00000001 execute
                            *COM*:00000001 charcount
                            *COM*:00000001 synclevel
                            *COM*:00000001 command
                            *COM*:00000001 framelength
                            *COM*:00000001 Index
                            *COM*:00000010 ReadBuffer1
                            *COM*:00000010 ReadBuffer2
                            *COM*:00000020 ReadBuffer3
                            *COM*:00000064 data_buffer
                            *COM*:00000020 ReadBuffer4
                            *COM*:00000001 B_first_uart
                            *COM*:00000001 B_nextLedOff
                            *COM*:00000004 tester
                            *COM*:00000002 tester1
                            *COM*:00000002 tester2
                            *COM*:00000002 tester3
                            *COM*:00000002 tester4
                            *COM*:00000002 tester5
                            *COM*:00000002 command_nr
                            *COM*:00000001 Dstatus
    {standard input}:377    .text.main:00000000 $t
    {standard input}:382    .text.main:00000000 main
    {standard input}:955    .text.main:000003dc $d
    {standard input}:1008   .text.main:000004a8 $t
    {standard input}:1531   .text.main:000007f0 $d
    {standard input}:1562   .text.main:00000868 $t
    {standard input}:1665   .rodata.main:00000000 $d
    {standard input}:2139   .text.main:00000c20 $d
    {standard input}:2170   .text.main:00000c94 $t
    {standard input}:2727   .text.main:00001058 $d
    {standard input}:2746   .text.main:0000109c $t
    {standard input}:3218   .text.main:000013b8 $d
    {standard input}:3242   .text.main:00001410 $t
    {standard input}:3737   .text.main:0000175c $d
    {standard input}:3762   .text.main:000017b8 $t
    {standard input}:4280   .text.main:00001b24 $d
    {standard input}:4326   .text.main:00001bd8 $t
    {standard input}:4603   .text.main:00001d98 $d
    {standard input}:4621   .text.endofTransmitU1:00000000 $t
    {standard input}:4626   .text.endofTransmitU1:00000000 endofTransmitU1
    {standard input}:4646   .text.endofReceiveU1:00000000 $t
    {standard input}:4651   .text.endofReceiveU1:00000000 endofReceiveU1
    {standard input}:4671   .text.endofTransmitU0:00000000 $t
    {standard input}:4676   .text.endofTransmitU0:00000000 endofTransmitU0
    {standard input}:4696   .text.endofReceiveU0:00000000 $t
    {standard input}:4701   .text.endofReceiveU0:00000000 endofReceiveU0
    {standard input}:4721   .text.VADC0_C0_0_IRQHandler:00000000 $t
    {standard input}:4726   .text.VADC0_C0_0_IRQHandler:00000000 VADC0_C0_0_IRQHandler
    {standard input}:4860   .text.VADC0_C0_0_IRQHandler:000000dc $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
group_ptrs
DAVE_Init
sysiniValueB1
sysiniValueB2
sysiniValueB4
sysiniValueB5
readSerNrEEprom
readNodeIdEEprom
read_akt_light_EEprom
read_off_light_EEprom
new_data_fill
bcuInit
SYSTIMER_CreateTimer
SYSTIMER_StartTimer
ADC_MEASUREMENT_ADV_SoftwareTrigger
UART_Receive
new_data_BroadcastBack
UART_Transmit
new_data_HalloBack
LED_Toggle_EverySec
Time1msec
Time20msec
xmc_lin_en
VCC_LED_shtdwn
ADC_MEASUREMENT_ADV_0
UART_1
new_data_analog1Back
new_data_analog2Back
bcuAktBerechnung
bcuUebergabe
new_data_aktLichtBack
new_data_offLichtBack
bcuColorBerechnung
new_data_Bright_Color_Back
new_data_Quot_Walk_Back
new_data_neuNodeIdBack
new_data_neuSerNrBack
new_data_SerNrBack
new_data_NodeIdBack
new_data_readbuff2Back
writeNodeid_B2_EEprom
writeSernr_B1_EEprom
writeakt_light_data_B4_EEprom
writeOff_light_B5_EEprom
clearEpromBuffer
writeLamp_data_B3_EEprom
ADC_MEASUREMENT_ADV_0_xmc_U_in_handle
ADC_MEASUREMENT_ADV_0_xmc_ntc_handle
ADC_MEASUREMENT_ADV_0_xmc_I_ww_handle
ADC_MEASUREMENT_ADV_0_xmc_I_cw_handle
